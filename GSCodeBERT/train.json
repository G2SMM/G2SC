{"url": "0", "code": "public void setAttribute(final String name, final Attribute attribute) {         if (name.equals(MAP_KEY)) {             this.mapAttribute = (MapAttribute) attribute;         }     }\n", "docstring": "set map attribute\n", "func_name": "0"}
{"url": "1", "code": "@Pure  @SuppressWarnings({\"checkstyle:returncount\", \"checkstyle:npathcomplexity\"})  public static Class<?> forName(String name) throws ClassNotFoundException {   if (name == null || \"\".equals(name) || \"null\".equals(name) //$NON-NLS-1$ //$NON-NLS-2$     || \"void\".equals(name)) { //$NON-NLS-1$    return void.class;   }   if (\"boolean\".equals(name)) { //$NON-NLS-1$    return boolean.class;   }   if (\"byte\".equals(name)) { //$NON-NLS-1$    return byte.class;   }   if (\"char\".equals(name)) { //$NON-NLS-1$    return char.class;   }   if (\"double\".equals(name)) { //$NON-NLS-1$    return double.class;   }   if (\"float\".equals(name)) { //$NON-NLS-1$    return float.class;   }   if (\"int\".equals(name)) { //$NON-NLS-1$    return int.class;   }   if (\"long\".equals(name)) { //$NON-NLS-1$    return long.class;   }   if (\"short\".equals(name)) { //$NON-NLS-1$    return short.class;   }   return Class.forName(name);  } @Pure  @Inline(value = \"ReflectionUtil.forName(($1), true, ($2))\", imported = {ReflectionUtil.class})  public static Class<?> forName(String name, ClassLoader loader) throws ClassNotFoundException {   return forName(name, true, loader);  } @Pure  @SuppressWarnings({\"checkstyle:returncount\", \"checkstyle:npathcomplexity\"})  public static Class<?> forName(String name, boolean typeInitialization, ClassLoader loader) throws ClassNotFoundException {   if (name == null || \"\".equals(name) || \"null\".equals(name) //$NON-NLS-1$ //$NON-NLS-2$     || \"void\".equals(name)) { //$NON-NLS-1$    return void.class;   }   if (\"boolean\".equals(name)) { //$NON-NLS-1$    return boolean.class;   }   if (\"byte\".equals(name)) { //$NON-NLS-1$    return byte.class;   }   if (\"char\".equals(name)) { //$NON-NLS-1$    return char.class;   }   if (\"double\".equals(name)) { //$NON-NLS-1$    return double.class;   }   if (\"float\".equals(name)) { //$NON-NLS-1$    return float.class;   }   if (\"int\".equals(name)) { //$NON-NLS-1$    return int.class;   }   if (\"long\".equals(name)) { //$NON-NLS-1$    return long.class;   }   if (\"short\".equals(name)) { //$NON-NLS-1$    return short.class;   }   return Class.forName(name, typeInitialization, loader);  }\n", "docstring": "replies type corresponds specified class name corresponds primitive type low level type replied method extends link class name string auto boxing support replies type corresponds specified class name corresponds primitive type low level type replied method extends link class name string auto boxing support replies type corresponds specified class name corresponds primitive type low level type replied method extends link class name string auto boxing support\n", "func_name": "1"}
{"url": "2", "code": "public boolean isCurrentUserAdmin() throws RepositoryException {      boolean isAdmin = false;         final JackrabbitSession session = (JackrabbitSession) getSession();         final UserManager userManager = session.getUserManager();         Authorizable a = userManager.getAuthorizable(getRequest().getUserPrincipal());         if (a instanceof org.apache.jackrabbit.api.security.user.User) {          isAdmin = ((org.apache.jackrabbit.api.security.user.User)a).isAdmin();         }         return isAdmin;     }\n", "docstring": "returns current request user admin user\n", "func_name": "2"}
{"url": "3", "code": "public boolean isAutoIncrement(int column) throws SQLException {     fetchFieldMetaData();     Field field = getField(column);     FieldMetadata metadata = field.getMetadata();     return metadata != null && metadata.autoIncrement;   }\n", "docstring": "inherit doc\n", "func_name": "3"}
{"url": "4", "code": "@Override     public Cache getCache(String id) {         Exceptions.checkNotClosed(this.closed.get(), this);          RocksDBCache result;         boolean isNew = false;         synchronized (this.caches) {             result = this.caches.get(id);             if (result == null) {                 result = new RocksDBCache(id, this.config, this::cacheClosed);                 this.caches.put(id, result);                 isNew = true;             }         }          if (isNew) {             result.initialize();         }          return result;     }\n", "docstring": "region cache factory implementation\n", "func_name": "4"}
{"url": "5", "code": "private void copyChildren(int upToChildPosition)     {         // (ensureRoom isn't called here, as we should always be at/behind key additions)         if (copyFromChildPosition >= upToChildPosition)             return;         int len = upToChildPosition - copyFromChildPosition;         if (len > 0)         {             System.arraycopy(copyFrom, getKeyEnd(copyFrom) + copyFromChildPosition, buildChildren, buildChildPosition, len);             copyFromChildPosition = upToChildPosition;             buildChildPosition += len;         }     }\n", "docstring": "copies children copy builder provided index copy exclusive\n", "func_name": "5"}
{"url": "6", "code": "public static CPDefinitionLocalization fetchByCPDefinitionId_LanguageId(   long CPDefinitionId, String languageId, boolean retrieveFromCache) {   return getPersistence()        .fetchByCPDefinitionId_LanguageId(CPDefinitionId,    languageId, retrieveFromCache);  }\n", "docstring": "returns definition localization definition language returns code null code could found optionally using finder cache\n", "func_name": "6"}
{"url": "7", "code": "@Override   public EEnum getIfcFanTypeEnum() {    if (ifcFanTypeEnumEEnum == null) {     ifcFanTypeEnumEEnum = (EEnum) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI).getEClassifiers()       .get(988);    }    return ifcFanTypeEnumEEnum;   }\n", "docstring": "begin user doc end user doc\n", "func_name": "7"}
{"url": "8", "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })  public void setValueForKey(Object key, Object value) throws ReflectorException  {      if(object == null) {    logger.error(\"object is null: did you specify it using the 'inspect()' method?\");    throw new ReflectorException(\"object is null: did you specify it using the 'inspect()' method?\");   }    if(object instanceof Map) {    ((Map)object).put(key, value);   } else {    throw new ReflectorException(\"object is not a map\");   }  }\n", "docstring": "object code map code subclass sets element corresponding given key\n", "func_name": "8"}
{"url": "9", "code": "synchronized void stateChanged(Date date, ChannelState state)     {         final ChannelStateHistoryEntry historyEntry;         final ChannelState oldState = this.state;          if (oldState == state)         {             return;         }          // System.err.println(id + \" state change: \" + oldState + \" => \" + state         // + \" (\" + name + \")\");         historyEntry = new ChannelStateHistoryEntry(date, state);         synchronized (stateHistory)         {             stateHistory.add(historyEntry);         }          this.state = state;         firePropertyChange(PROPERTY_STATE, oldState, state);     }\n", "docstring": "changes state channel\n", "func_name": "9"}
{"url": "10", "code": "public static boolean hasCustomHashCode(Class c)     {         Class origClass = c;         if (_customHash.containsKey(c))         {             return _customHash.get(c);         }          while (!Object.class.equals(c))         {             try             {                 c.getDeclaredMethod(\"hashCode\");                 _customHash.put(origClass, true);                 return true;             }             catch (Exception ignored) { }             c = c.getSuperclass();         }         _customHash.put(origClass, false);         return false;     }\n", "docstring": "determine passed class non object hash code method method caches results concurrent hash map benefit execution performance\n", "func_name": "10"}
{"url": "11", "code": "protected void processClassloader(KieContainer kieContainer, DeployedUnitImpl deployedUnit) {      if (((KieContainerImpl) kieContainer).getKieProject() instanceof KieModuleKieProject && kieContainer.getClassLoader() instanceof ProjectClassLoader) {    ClassLoader parentCl = kieContainer.getClassLoader().getParent();    if (parentCl instanceof URLClassLoader) {     URL[] urls = ((URLClassLoader) parentCl).getURLs();     if (urls == null || urls.length == 0) {      return;     }     ConfigurationBuilder builder = new ConfigurationBuilder();     builder.addUrls(urls);     builder.addClassLoader(kieContainer.getClassLoader());      Reflections reflections = new Reflections(builder);      Set<Class<?>> xmlRootElemClasses = reflections.getTypesAnnotatedWith(XmlRootElement.class);     Set<Class<?>> xmlTypeClasses = reflections.getTypesAnnotatedWith(XmlType.class);     Set<Class<?>> remoteableClasses = reflections.getTypesAnnotatedWith(Remotable.class);      Set<Class<?>> allClasses = new HashSet<Class<?>>();     for( Set<Class<?>> classesToAdd : new Set[] { xmlRootElemClasses, xmlTypeClasses, remoteableClasses } ) {        if( classesToAdd != null ) {            allClasses.addAll(classesToAdd);        }     }      for (Class<?> clazz : allClasses) {         filterClassesAddedToDeployedUnit(deployedUnit, clazz);     }    }      }  }\n", "docstring": "processes deployment dependencies made available link container link class loader\n", "func_name": "11"}
{"url": "12", "code": "public static SkbShellCommand newCommand(String command, SkbShellArgument[] arguments, SkbShellCommandCategory category, String description, String addedHelp){   return new AbstractShellCommand(command, arguments, category, description, addedHelp);  } public static SkbShellCommand newCommand(String command, SkbShellArgument argument, SkbShellCommandCategory category, String description, String addedHelp){   if(argument==null){    return new AbstractShellCommand(command, null, category, description, addedHelp);   }   return SkbShellFactory.newCommand(command, new SkbShellArgument[]{argument}, category, description, addedHelp);  } public static SkbShellCommand newCommand(String command, SkbShellCommandCategory category, String description, String addedHelp){   return new AbstractShellCommand(command, null, category, description, addedHelp);  }\n", "docstring": "returns shell command use factory create one returns shell command use factory create one returns shell command without formal arguments use factory create one\n", "func_name": "12"}
{"url": "13", "code": "public void remove(String applicationName, String modelName, Class<?> robotContext, boolean verbose) {         logger.info(\"Remove model named [{}] in application named [{}]\", modelName, applicationName);         String modelPath = mainPath + File.separator + \"java\" + File.separator + robotContext.getCanonicalName().replaceAll(\"\\\\.\", \"/\").replaceAll(\"utils\", \"application/model/\" + applicationName)                 .replaceAll(\"/\", Matcher.quoteReplacement(File.separator)).replaceAll(robotContext.getSimpleName(), modelName.toUpperCase().charAt(0) + modelName.substring(1)) + \".java\";         String modelsPath = mainPath + File.separator + \"java\" + File.separator + robotContext.getCanonicalName().replaceAll(\"\\\\.\", \"/\").replaceAll(\"utils\", \"application/model/\" + applicationName)                 .replaceAll(\"/\", Matcher.quoteReplacement(File.separator)).replaceAll(robotContext.getSimpleName(), modelName.toUpperCase().charAt(0) + modelName.substring(1)) + \"s.java\";         try {             FileUtils.forceDelete(new File(modelPath));             if (verbose) {                 logger.info(\"{} removed with success.\", modelPath);             }         } catch (IOException e) {             logger.debug(\"{} not revove because do not exist.\", modelPath);         }         try {             FileUtils.forceDelete(new File(modelsPath));             if (verbose) {                 logger.info(\"{} removed with success.\", modelsPath);             }         } catch (IOException e) {             logger.debug(\"{} not revove because do not exist.\", modelsPath);         }         String applicationDirectoryPath = modelPath.substring(0, modelPath.lastIndexOf(File.separator));         try {             Collection<File> l = FileUtils.listFiles(new File(applicationDirectoryPath), TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE);             if (l.isEmpty()) {                 if (verbose) {                     logger.info(\"Empty directory, so remove application directory.\");                 }                 FileUtils.deleteDirectory(new File(applicationDirectoryPath));             }         } catch (IOException e) {             logger.debug(\"{} not revove because do not exist.\", applicationDirectoryPath);         }      }\n", "docstring": "remove model target application robot sample add google google user verbose\n", "func_name": "13"}
{"url": "14", "code": "@Override  public CreateOrUpdateStatus createOrUpdate(Contents contents)    throws SQLException {   verifyCreate(contents);   return super.createOrUpdate(contents);  }\n", "docstring": "inherit doc\n", "func_name": "14"}
{"url": "15", "code": "protected void localRelease() {         super.localRelease();          if(bodyContent != null)             bodyContent.clearBody();          _rows = DIMENSION_DEFAULT_VALUE;         _columns = DIMENSION_DEFAULT_VALUE;         _currentRow = -1;         _currentColumn = -1;         _currentIndex = -1;         _verticalRepeat = false;         _dataList = null;         _currentItem = null;         _valid = true;         _dataSource = null;          if(_tdState != null)             _tdState.clear();         if(_trState != null)             _trState.clear();         if(_tableState != null)             _tableState.clear();          _tableRenderer = null;         _tdRenderer = null;         _trRenderer = null;          _sb = null;         _appender = null;          if(_containerInPageContext) {             DataAccessProviderStack.removeDataAccessProvider(pageContext);             _containerInPageContext = false;         }     }\n", "docstring": "reset fields tag\n", "func_name": "15"}
{"url": "16", "code": "@Override     public ProxyHandler createProxyHandler() {         final HttpProxyHandler handler;          // For reasons that are not immediately clear, HttpProxyHandler doesn't allow null usernames/passwords if         // specified. If we want them to be null, we have to use the constructor that doesn't take a username/password         // at all.         if (this.username != null && this.password != null) {             handler = new HttpProxyHandler(this.proxyAddress, this.username, this.password);         } else {             handler = new HttpProxyHandler(this.proxyAddress);         }          return handler;     }\n", "docstring": "non java doc\n", "func_name": "16"}
{"url": "17", "code": "private void initializeWizardButton() {         Button wizardButton = findViewById(R.id.wizard_button);         wizardButton.setOnClickListener(createWizardButtonListener());     }\n", "docstring": "initializes button allows show\n", "func_name": "17"}
{"url": "18", "code": "@Nullable   public static PasswordAuthentication requestProxyPasswordAuthentication (@Nullable final String sHostName,                                                                            @Nullable final int nPort,                                                                            @Nullable final String sProtocol)   {     return requestPasswordAuthentication (sHostName,                                           (InetAddress) null,                                           nPort,                                           sProtocol,                                           (String) null,                                           (String) null,                                           (URL) null,                                           RequestorType.PROXY);   }\n", "docstring": "shortcut method requesting proxy password authentication method also used class default authentic\n", "func_name": "18"}
{"url": "19", "code": "private void scheduleReadTimeout() {   if (scheduledReadTimeout == null) {    scheduledReadTimeout = eventloop.delayBackground(readTimeout, () -> {     if (inspector != null) inspector.onReadTimeout();     scheduledReadTimeout = null;     close(TIMEOUT_EXCEPTION);    });   }  }\n", "docstring": "time management\n", "func_name": "19"}
{"url": "20", "code": "public void setDateFormatPattern(String dateFormatPattern) {         try {             simpleDateFormat = new SimpleDateFormat(dateFormatPattern);         } catch (Exception e) {             throw new IllegalArgumentException(\"Incorrect date pattern. \" +                     \"Ensure to use formats provided in https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\", e);         }     }\n", "docstring": "property specifying date format see href https docs oracle com java docs api java text simple dateformat html simple dateformat details\n", "func_name": "20"}
{"url": "21", "code": "@Deprecated   public int getClusterSize(String clusterId, String zoneId) {     Cluster cluster = getCluster(clusterId, zoneId);     String message = String.format(\"Cluster %s/%s was not found.\", clusterId, zoneId);     Preconditions.checkNotNull(cluster, message);     return cluster.getServeNodes();   }\n", "docstring": "gets serve node count cluster\n", "func_name": "21"}
{"url": "22", "code": "@SideOnly(Side.CLIENT)  public static void sendAction(ActionType action, int inventoryId, int slotNumber, int code)  {   int windowId = Utils.getClientPlayer().openContainer.windowId;   Packet packet = new Packet(action, inventoryId, slotNumber, code, windowId);   MalisisCore.network.sendToServer(packet);  }\n", "docstring": "sends gui action server link malis inventory container\n", "func_name": "22"}
{"url": "23", "code": "public List<String> encodedPathSegments() {         int pathStart = url.indexOf('/', scheme.length() + 3);         int pathEnd = delimiterOffset(url, pathStart, url.length(), \"?#\");         List<String> result = new ArrayList<>();         for (int i = pathStart; i < pathEnd; ) {             i++; // Skip the '/'.             int segmentEnd = delimiterOffset(url, i, pathEnd, '/');             result.add(url.substring(i, segmentEnd));             i = segmentEnd;         }         return result;     }\n", "docstring": "returns list encoded path segments like code url code http host list never empty though may contain single empty string\n", "func_name": "23"}
{"url": "24", "code": "public ServiceFuture<Void> stopAsync(String resourceGroupName, String accountName, String streamingEndpointName, final ServiceCallback<Void> serviceCallback) {         return ServiceFuture.fromResponse(stopWithServiceResponseAsync(resourceGroupName, accountName, streamingEndpointName), serviceCallback);     }\n", "docstring": "stop streaming endpoint stops existing streaming endpoint\n", "func_name": "24"}
{"url": "25", "code": "private void initializeArtworkTarget() {         mThumbnailArtworkTarget = new Target() {             @Override             public void onBitmapLoaded(Bitmap bitmap, Picasso.LoadedFrom from) {                 mNotificationView.setImageViewBitmap(                         R.id.simple_sound_cloud_notification_thumbnail, bitmap);                 mNotificationExpandedView.setImageViewBitmap(                         R.id.simple_sound_cloud_notification_thumbnail, bitmap);                 mNotificationManager.notify(NOTIFICATION_ID, buildNotification());             }              @Override             public void onBitmapFailed(Drawable errorDrawable) {              }              @Override             public void onPrepareLoad(Drawable placeHolderDrawable) {             }         };     }\n", "docstring": "initialize target used load artwork asynchronously\n", "func_name": "25"}
{"url": "26", "code": "@XmlTransient  public Number getFieldValueAsNumber() {   Object obj = this.getFieldValue();   if(obj == null) {    return null;   }    if(obj instanceof Number) {    return (Number)obj;   }    return null;  }\n", "docstring": "gets value code code field code number\n", "func_name": "26"}
{"url": "27", "code": "public MethodDoc[] methods(boolean filter) {         Names names = tsym.name.table.names;         List<MethodDocImpl> methods = List.nil();         for (Scope.Entry e = tsym.members().elems; e != null; e = e.sibling) {             if (e.sym != null                 && e.sym.kind == Kinds.MTH                 && e.sym.name != names.init                 && e.sym.name != names.clinit) {                 MethodSymbol s = (MethodSymbol)e.sym;                 if (!filter || env.shouldDocument(s)) {                     methods = methods.prepend(env.getMethodDoc(s));                 }             }         }         //### Cache methods here?         return methods.toArray(new MethodDocImpl[methods.length()]);     }\n", "docstring": "return methods class method overridden annotation type doc mpl\n", "func_name": "27"}
{"url": "28", "code": "public void sanityCheck() {      if (mcDepth != 0) {       throw new IllegalPdfSyntaxException(\"Unbalanced marked content operators.\" );      }      if (inText) {       throw new IllegalPdfSyntaxException(\"Unbalanced begin/end text operators.\" );      }      if (layerDepth != null && !layerDepth.isEmpty()) {       throw new IllegalPdfSyntaxException(\"Unbalanced layer operators.\" );      }      if (!stateList.isEmpty()) {       throw new IllegalPdfSyntaxException(\"Unbalanced save/restore state operators.\" );      }     }\n", "docstring": "checks dangling state mismatched save restore state begin end text begin end layer begin end marked content sequence found function throw function called automatically reset document page example writing pdf one possible cause calling pdf graphics dispose leave dangling save state calls\n", "func_name": "28"}
{"url": "29", "code": "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {         Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);         return ifcs.toArray(new Class<?>[ifcs.size()]);     }\n", "docstring": "return interfaces given class implements array including ones implemented classes class gets returned sole\n", "func_name": "29"}
{"url": "30", "code": "public static String getMandatoryConfig(Configuration config, String key)       throws IOException {     String value = config.get(key);     if (Strings.isNullOrEmpty(value)) {       throw new IOException(\"Must supply a value for configuration setting: \" + key);     }     return value;   } public static Map<String, String> getMandatoryConfig(       Configuration config, List<String> keys)       throws IOException {     List<String> missingKeys = new ArrayList<>();     Map<String, String> values = new HashMap<>();     for (String key : keys) {       String value = config.get(key);       if (Strings.isNullOrEmpty(value)) {         missingKeys.add(key);       } else {         values.put(key, value);       }     }     if (missingKeys.size() > 0) {       Joiner joiner = Joiner.on(\", \");       String message = \"Must supply value for configuration settings: \" + joiner.join(missingKeys);       throw new IOException(message);     }     return values;   }\n", "docstring": "gets value given key throws value found gets value given keys throws one values found\n", "func_name": "30"}
{"url": "31", "code": "@Programmatic     public ApplicationRole findByNameCached(final String name) {         return queryResultsCache.execute(new Callable<ApplicationRole>() {             @Override public ApplicationRole call() throws Exception {                 return findByName(name);             }         }, ApplicationRoleRepository.class, \"findByNameCached\", name);     }\n", "docstring": "region find name\n", "func_name": "31"}
{"url": "32", "code": "static String toLowerCamelCaseWithNumericSuffixes(String input) {     // Determine where the numeric suffixes begin     int suffixStart = input.length();     while (suffixStart > 0) {       char ch = '\\0';       int numberStart = suffixStart;       while (numberStart > 0) {         ch = input.charAt(numberStart - 1);         if (Character.isDigit(ch)) {           numberStart--;         } else {           break;         }       }       if ((numberStart > 0) && (numberStart < suffixStart) && (ch == '_')) {         suffixStart = numberStart - 1;       } else {         break;       }     }      if (suffixStart == input.length()) {       return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, input);     } else {       return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,           input.substring(0, suffixStart)) + input.substring(suffixStart);     }   }\n", "docstring": "converts given string upper underscore case lower camel case preserving numeric suffixes example name name letter letter start span start span\n", "func_name": "32"}
{"url": "33", "code": "public final void setLineBreak(LineBreak lineBreak) {          // Copy to the field, but convert null to LineBreak.NONE         _lineBreak = lineBreak != null ? lineBreak : LineBreak.NONE;          // Get the corresponding characters in a separate field         _lineBreakChars = _lineBreak._lineBreakChars;          // If there is no line break, there shall be no indentation         if (_lineBreak == LineBreak.NONE) {             _indentation = \"\";         }          // State has changed, check         checkInvariants();     }\n", "docstring": "sets type line use line set code line none code indentation reset empty string\n", "func_name": "33"}
{"url": "34", "code": "protected char[] resolvePath(char[] basePath, char[] relPath)         throws URIException {          // REMINDME: paths are never null         String base = (basePath == null) ? \"\" : new String(basePath);          // _path could be empty         if (relPath == null || relPath.length == 0) {             return normalize(basePath);         } else if (relPath[0] == '/') {             return normalize(relPath);         } else {             int at = base.lastIndexOf('/');             if (at != -1) {                 basePath = base.substring(0, at + 1).toCharArray();             }             StringBuffer buff = new StringBuffer(base.length()                  + relPath.length);             buff.append((at != -1) ? base.substring(0, at + 1) : \"/\");             buff.append(relPath);             return normalize(buff.toString().toCharArray());         }     }\n", "docstring": "resolve base relative path\n", "func_name": "34"}
{"url": "35", "code": "public boolean removeLayout(final Layout itemLayout) {         boolean removed = false;         if (itemLayout != null && mItemLayouts.remove(itemLayout)) {             // remove the layout from all visible pages             List<Widget>  views = getAllViews();             for (Widget view: views) {                 view.removeLayout(itemLayout);             }             removed = true;         }         return removed;     }\n", "docstring": "remove item layout\n", "func_name": "35"}
{"url": "36", "code": "public Jid getArchiveAddress() {         if (archiveAddress == null) {             EntityFullJid localJid = connection().getUser();             if (localJid == null) {                 return null;             }             return localJid.asBareJid();         }         return archiveAddress;     }\n", "docstring": "xmpp address mam archive note method may return code null mam manager handles local entity archive connection never authenticated least\n", "func_name": "36"}
{"url": "37", "code": "@Override  public void eUnset(int featureID) {   switch (featureID) {    case AfplibPackage.TBM__DIRCTION:     setDIRCTION(DIRCTION_EDEFAULT);     return;    case AfplibPackage.TBM__PRECSION:     setPRECSION(PRECSION_EDEFAULT);     return;    case AfplibPackage.TBM__INCRMENT:     setINCRMENT(INCRMENT_EDEFAULT);     return;   }   super.eUnset(featureID);  }\n", "docstring": "begin user doc end user doc\n", "func_name": "37"}
{"url": "38", "code": "@WebMethod(name = \"config.xml\")     public HttpResponse doConfigDotXml(StaplerRequest req) throws IOException {         if (req.getMethod().equals(\"GET\")) {             // read             checkPermission(READ);             return new HttpResponse() {                 public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {                     rsp.setContentType(\"application/xml\");                     View.this.writeXml(rsp.getOutputStream());                 }             };         }         if (req.getMethod().equals(\"POST\")) {             // submission             updateByXml(new StreamSource(req.getReader()));             return HttpResponses.ok();         }          // huh?         return HttpResponses.error(SC_BAD_REQUEST, \"Unexpected request method \" + req.getMethod());     }\n", "docstring": "accepts\n", "func_name": "38"}
{"url": "39", "code": "public static SQLiteDatabase openOrCreateDatabase(File file, CursorFactory factory) {         return openOrCreateDatabase(file.getPath(), factory);     } public static SQLiteDatabase openOrCreateDatabase(String path, CursorFactory factory) {         return openDatabase(path, factory, CREATE_IF_NECESSARY, null);     } public static SQLiteDatabase openOrCreateDatabase(String path, CursorFactory factory,             DatabaseErrorHandler errorHandler) {         return openDatabase(path, factory, CREATE_IF_NECESSARY, errorHandler);     }\n", "docstring": "equivalent open database file get path factory create necessary equivalent open database path factory create necessary equivalent open database path factory create necessary error handler\n", "func_name": "39"}
{"url": "40", "code": "public void sendInstances(Stream inputStream,               int numberInstances, boolean isTraining, boolean isTesting) {   int numberSamples = 0;    while (streamSource.hasMoreInstances()     && numberSamples < numberInstances) {        numberSamples++;    numberInstancesSent++;    InstanceContentEvent instanceContentEvent = new InstanceContentEvent(      numberInstancesSent, nextInstance(), isTraining, isTesting);           inputStream.put(instanceContentEvent);   }    InstanceContentEvent instanceContentEvent = new InstanceContentEvent(     numberInstancesSent, null, isTraining, isTesting);   instanceContentEvent.setLast(true);   inputStream.put(instanceContentEvent);  }\n", "docstring": "send instances\n", "func_name": "40"}
{"url": "41", "code": "@Override     public DescribeLocationS3Result describeLocationS3(DescribeLocationS3Request request) {         request = beforeClientExecution(request);         return executeDescribeLocationS3(request);     }\n", "docstring": "returns metadata bucket name amazon bucket location\n", "func_name": "41"}
{"url": "42", "code": "public static float map(float minStart, float minStop, float maxStart, float maxStop, float value) {         return maxStart + (maxStop - maxStart) * ((value - minStart) / (minStop - minStart));     }\n", "docstring": "max start max stop switched\n", "func_name": "42"}
{"url": "43", "code": "public static Word2Vec readWord2VecFromText(@NonNull File vectors, @NonNull File hs, @NonNull File h_codes,                                                 @NonNull File h_points, @NonNull VectorsConfiguration configuration) throws IOException {         // first we load syn0         Pair<InMemoryLookupTable, VocabCache> pair = loadTxt(vectors);         InMemoryLookupTable lookupTable = pair.getFirst();         lookupTable.setNegative(configuration.getNegative());         if (configuration.getNegative() > 0)             lookupTable.initNegative();         VocabCache<VocabWord> vocab = (VocabCache<VocabWord>) pair.getSecond();          // now we load syn1         BufferedReader reader = new BufferedReader(new FileReader(hs));         String line = null;         List<INDArray> rows = new ArrayList<>();         while ((line = reader.readLine()) != null) {             String[] split = line.split(\" \");             double array[] = new double[split.length];             for (int i = 0; i < split.length; i++) {                 array[i] = Double.parseDouble(split[i]);             }             rows.add(Nd4j.create(array, new long[]{array.length}, lookupTable.getSyn0().dataType()));         }         reader.close();          // it's possible to have full model without syn1         if (!rows.isEmpty()) {             INDArray syn1 = Nd4j.vstack(rows);             lookupTable.setSyn1(syn1);         }          // now we transform mappings into huffman tree points         reader = new BufferedReader(new FileReader(h_points));         while ((line = reader.readLine()) != null) {             String[] split = line.split(\" \");             VocabWord word = vocab.wordFor(decodeB64(split[0]));             List<Integer> points = new ArrayList<>();             for (int i = 1; i < split.length; i++) {                 points.add(Integer.parseInt(split[i]));             }             word.setPoints(points);         }         reader.close();           // now we transform mappings into huffman tree codes         reader = new BufferedReader(new FileReader(h_codes));         while ((line = reader.readLine()) != null) {             String[] split = line.split(\" \");             VocabWord word = vocab.wordFor(decodeB64(split[0]));             List<Byte> codes = new ArrayList<>();             for (int i = 1; i < split.length; i++) {                 codes.add(Byte.parseByte(split[i]));             }             word.setCodes(codes);             word.setCodeLength((short) codes.size());         }         reader.close();          Word2Vec.Builder builder = new Word2Vec.Builder(configuration).vocabCache(vocab).lookupTable(lookupTable)                 .resetModel(false);          TokenizerFactory factory = getTokenizerFactory(configuration);          if (factory != null)             builder.tokenizerFactory(factory);          Word2Vec w2v = builder.build();          return w2v;     }\n", "docstring": "method allows read paragraph vectors externally originated vectors syn technically method compatible implementation\n", "func_name": "43"}
{"url": "44", "code": "public static String getI18nString(ResourceBundle bundle, String key, String def) {         String s = bundle != null ? bundle.getString(key) : null;         return s != null ? s : def;     }\n", "docstring": "returns internationalized version string available otherwise returns def\n", "func_name": "44"}
{"url": "45", "code": "@Override     protected void extractAndTakeAction(String timestamp, JSONArray jsonAllRows, List<String> joinFields, RequestType requestType, ActionType action) {         Map<Object,List<Object>> newBaseAllRows = new LinkedHashMap<>();         JSONObject eachRow = null;         for (int i = 0; i < jsonAllRows.length(); i++) {             JSONObject jsonItem = jsonAllRows.getJSONObject(i);             eachRow = dataItemAt(jsonItem, requestType, action);             String actualTimestamp = timestamp;             if (timestamp == null) {                 if (requestType == RequestType.SELECT) {                     actualTimestamp = eachRow.optString(\"timestamp\");                     // Because the timestamp is within each row remove them once you extract it.                     eachRow.remove(\"timestamp\");                 } else {                     actualTimestamp = jsonItem.optString(\"timestamp\");                 }             }             Tuple2<Object, List<Object>> row = mapPkToRow(actualTimestamp, eachRow, joinFields);             Object pk = row._1();// Primary key.             List<Object> rowVal = row._2();             if (action == ActionType.FIRST_CUT) {// First cut (no join).                 if (pk != null) {//TODO: Only non-nulls will go through. Address this later.                     baseAllRows.put(pk, rowVal);                 }             } else {// Some Join action.                 if (pk != null) {//TODO: Only non-nulls will go through. Address this later.                     if (baseAllRows.containsKey(pk)) {// If any item in set B exist in set A.                         rowVal.removeAll(splitCompositeKeys(pk.toString()));// Remove key(which is already available in baseAllRows)                         if (!joinFields.contains(\"timestamp\")) {// If join field is not \"timestamp\" then remove timestamp data value from to be joined set.                             rowVal.remove(0);// Because the 1st field is always timestamp.(See extractKeyAndRow() method)                         }                         if (action == ActionType.JOIN || action == ActionType.RIGHT_JOIN) {                             newBaseAllRows.put(pk, baseAllRows.remove(pk));// Remove from existing map and add to new map.                             newBaseAllRows.get(pk).addAll(rowVal);// Update the new map with partial to be joined data.                         } else if (action == ActionType.LEFT_JOIN) {// Left join                             baseAllRows.get(pk).addAll(rowVal);                         }                     } else {// For right join we still need to continue with each row in set B.                         if (action == ActionType.RIGHT_JOIN) {// Right join                             newBaseAllRows.put(pk, rowVal);                         }                     }                 }             }             if (i == 0) {// Fill headers (only once)                 fillHeaders(eachRow, joinFields, action);             }         }         if (!newBaseAllRows.isEmpty()) {// For join and right join.             baseAllRows = newBaseAllRows;         }     }\n", "docstring": "generate tuple list field names map join fei row list json array\n", "func_name": "45"}
{"url": "46", "code": "public void setTrailList(java.util.Collection<Trail> trailList) {         if (trailList == null) {             this.trailList = null;             return;         }          this.trailList = new com.amazonaws.internal.SdkInternalList<Trail>(trailList);     }\n", "docstring": "list trail objects\n", "func_name": "46"}
{"url": "47", "code": "public void waitForCompletion(final long timeout, final TimeUnit unit)     throws InterruptedException, ExecutionException, TimeoutException {   doneLatch.await(timeout, unit);  }\n", "docstring": "wait completion operation timed version\n", "func_name": "47"}
{"url": "48", "code": "public static JsonSimple parse(String input) throws IOException {         ByteArrayInputStream bytes = new ByteArrayInputStream(                 input.getBytes(\"UTF-8\"));         return parse(bytes);     } public static JsonSimple parse(InputStream input) throws IOException {         JsonSimple inputData = new JsonSimple(input);         JsonSimple responseData = new JsonSimple();          // Go through every top level node         JsonObject object = inputData.getJsonObject();         for (Object key : object.keySet()) {             // Ignoring some non-form related nodes             String strKey = validString(key);             if (!EXCLUDED_FIELDS.contains(strKey)) {                 // And parse them into the repsonse                 String data = validString(object.get(key));                 parseField(responseData, strKey, data);             }         }         return responseData;     }\n", "docstring": "wrapper stream based parsing method accepts string internally create stream accept parse raw json data input stream field name string literals broken meaningful json data structures\n", "func_name": "48"}
{"url": "49", "code": "public void marshall(DeleteVaultNotificationsRequest deleteVaultNotificationsRequest, ProtocolMarshaller protocolMarshaller) {          if (deleteVaultNotificationsRequest == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(deleteVaultNotificationsRequest.getAccountId(), ACCOUNTID_BINDING);             protocolMarshaller.marshall(deleteVaultNotificationsRequest.getVaultName(), VAULTNAME_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "49"}
{"url": "50", "code": "private static ServiceProviderFinder _getServiceProviderFinderFromInitParam(ExternalContext context)     {         String initializerClassName = context.getInitParameter(SERVICE_PROVIDER_FINDER_PARAM);         if (initializerClassName != null)         {             try             {                 // get Class object                 Class<?> clazz = ClassUtils.classForName(initializerClassName);                 if (!ServiceProviderFinder.class.isAssignableFrom(clazz))                 {                     throw new FacesException(\"Class \" + clazz                              + \" does not implement ServiceProviderFinder\");                 }                                  // create instance and return it                 return (ServiceProviderFinder) ClassUtils.newInstance(clazz);             }             catch (ClassNotFoundException cnfe)             {                 throw new FacesException(\"Could not find class of specified ServiceProviderFinder\", cnfe);             }         }         return null;     }\n", "docstring": "gets service provider finder web xml config param\n", "func_name": "50"}
{"url": "51", "code": "protected List<Integer> getUserWidths()     {         List<Integer> ret = null;         try {             if (Context.getThreadContext().containsUserAttribute(                             getCacheKey(UITable.UserCacheKey.COLUMNWIDTH))) {                 setUserWidth(true);                 final String widths = Context.getThreadContext().getUserAttribute(                                 getCacheKey(UITable.UserCacheKey.COLUMNWIDTH));                  final StringTokenizer tokens = new StringTokenizer(widths, \";\");                  ret = new ArrayList<>();                  while (tokens.hasMoreTokens()) {                     final String token = tokens.nextToken();                     for (int i = 0; i < token.length(); i++) {                         if (!Character.isDigit(token.charAt(i))) {                             final int width = Integer.parseInt(token.substring(0, i));                             ret.add(width);                             break;                         }                     }                 }             }         } catch (final NumberFormatException e) {             // we don't throw an error because this are only Usersettings             AbstractUIHeaderObject.LOG.error(\"error during the retrieve of UserAttributes in getUserWidths()\", e);         } catch (final EFapsException e) {             // we don't throw an error because this are only Usersettings             AbstractUIHeaderObject.LOG.error(\"error during the retrieve of UserAttributes in getUserWidths()\", e);         }         return ret;     }\n", "docstring": "method retie ves user attribute columnwidth evaluates string\n", "func_name": "51"}
{"url": "52", "code": "public static <T> void concat(T[] sourceFirst, T[] sourceSecond, T[] dest) {         System.arraycopy(sourceFirst, 0, dest, 0, sourceFirst.length);         System.arraycopy(sourceSecond, 0, dest, sourceFirst.length, sourceSecond.length);     }\n", "docstring": "copies order code source first code source second code\n", "func_name": "52"}
{"url": "53", "code": "protected void onRootChoiceUpdate(final AjaxRequestTarget target) {   childTextField.setModelObject(getModelObject().getSelectedChildOption());   target.add(DropdownAutocompleteTextFieldPanel.this.childTextField);  }\n", "docstring": "callback method overwritten provide additional action root choice updated\n", "func_name": "53"}
{"url": "54", "code": "public Instance searchInstance()         throws InstallationException     {         Instance instance = null;         try {             // check if type exists. Necessary for first time installations             if (getCiType().getType() != null) {                 final QueryBuilder queryBldr = new QueryBuilder(getCiType());                 queryBldr.addWhereAttrEqValue(CIAdminProgram.Abstract.Name, this.programName);                 final InstanceQuery query = queryBldr.getQuery();                 query.executeWithoutAccessCheck();                 if (query.next()) {                     instance = query.getCurrentValue();                 }             }         } catch (final EFapsException e)  {             throw new InstallationException(\"Could not find '\" + getCiType() + \"' '\" + this.programName + \"'\", e);         }         return instance;     }\n", "docstring": "method search instance imported\n", "func_name": "54"}
{"url": "55", "code": "public FessMessages addErrorsCrudInvalidMode(String property, String arg0, String arg1) {         assertPropertyNotNull(property);         add(property, new UserMessage(ERRORS_crud_invalid_mode, arg0, arg1));         return this;     }\n", "docstring": "add created action message key errors crud invalid mode parameters pre message invalid mode expected value pre\n", "func_name": "55"}
{"url": "56", "code": "public IterativeState<T,R> setState(IterativeState<T,R> new_state)      {          IterativeState<T,R> old_state = this.state;          this.state = new_state;          return old_state;      }\n", "docstring": "sets supplied state iterative callback\n", "func_name": "56"}
{"url": "57", "code": "protected final List<MvcRequestMatcher> createMvcMatchers(HttpMethod method,    String... mvcPatterns) {   Assert.state(!this.anyRequestConfigured, \"Can't configure mvcMatchers after anyRequest\");   ObjectPostProcessor<Object> opp = this.context.getBean(ObjectPostProcessor.class);   if (!this.context.containsBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME)) {    throw new NoSuchBeanDefinitionException(\"A Bean named \" + HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME +\" of type \" + HandlerMappingIntrospector.class.getName()     + \" is required to use MvcRequestMatcher. Please ensure Spring Security & Spring MVC are configured in a shared ApplicationContext.\");   }   HandlerMappingIntrospector introspector = this.context.getBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME,    HandlerMappingIntrospector.class);   List<MvcRequestMatcher> matchers = new ArrayList<>(     mvcPatterns.length);   for (String mvcPattern : mvcPatterns) {    MvcRequestMatcher matcher = new MvcRequestMatcher(introspector, mvcPattern);    opp.postProcess(matcher);     if (method != null) {     matcher.setMethod(method);    }    matchers.add(matcher);   }   return matchers;  }\n", "docstring": "creates link request match instances method patterns passed\n", "func_name": "57"}
{"url": "58", "code": "@Override     public int replace(Replaceable text,                        int start,                        int limit,                        int[] cursor) {          // First delegate to subordinate replacer         int len = replacer.replace(text, start, limit, cursor);         limit = start + len;          // Now transliterate         limit = translit.transliterate(text, start, limit);          return limit - start;     }\n", "docstring": "unicode replace api\n", "func_name": "58"}
{"url": "59", "code": "public static Document restoreDots(Document document) {         return modifyKeys(document, key -> key.replace(TO_REPLACE_DOTS, \".\"), TO_REPLACE_DOTS);     }\n", "docstring": "restore dots keys\n", "func_name": "59"}
{"url": "60", "code": "public static base_response delete(nitro_service client, nssimpleacl resource) throws Exception {   nssimpleacl deleteresource = new nssimpleacl();   deleteresource.aclname = resource.aclname;   return deleteresource.delete_resource(client);  }\n", "docstring": "use api delete simple\n", "func_name": "60"}
{"url": "61", "code": "protected String resolveExpressionBlock(String expression, EvaluationContext context, boolean urlEncode, EvaluationStrategy strategy, List<String> errors) {         try {             String body = expression.substring(1); // strip prefix              // if expression doesn't start with ( then check it's an allowed top level context reference             if (!body.startsWith(\"(\")) {                 String topLevel = StringUtils.split(body, '.')[0].toLowerCase();                 if (!m_allowedTopLevels.contains(topLevel)) {                     return expression;                 }             }              Object evaluated = evaluateExpression(body, context, strategy);              String rendered = Conversions.toString(evaluated, context); // render result as string             return urlEncode ? ExpressionUtils.urlquote(rendered) : rendered;         }         catch (EvaluationError ex) {             logger.debug(\"Unable to evaluate expression\", ex);             errors.add(ex.getMessage());              return expression; // if we can't evaluate expression, include it as is in the output         }     }\n", "docstring": "resolves expression block found template\n", "func_name": "61"}
{"url": "62", "code": "private void removeFolder(File dir) throws IOException     {       if (PrivilegedFileHelper.isDirectory(dir))       {            for (File subFile : PrivilegedFileHelper.listFiles(dir))          {             removeFolder(subFile);          }                    if (!PrivilegedFileHelper.delete(dir))          {             throw new IOException(\"Index folder was not deleted : \" + PrivilegedFileHelper.getCanonicalPath(dir));          }       }       else       {          if (!PrivilegedFileHelper.delete(dir))          {             throw new IOException(\"Index file was not deleted : \" + PrivilegedFileHelper.getCanonicalPath(dir));          }       }    }\n", "docstring": "remove folder\n", "func_name": "62"}
{"url": "63", "code": "public List<AccessControlEntry> getPermissionEntries()    {       List<AccessControlEntry> list = new ArrayList<AccessControlEntry>();       for (int i = 0, length = accessList.size(); i < length; i++)       {          AccessControlEntry entry = accessList.get(i);          list.add(new AccessControlEntry(entry.getIdentity(), entry.getPermission()));       }       return list;    }\n", "docstring": "gives permission entries\n", "func_name": "63"}
{"url": "64", "code": "public static String unquote(String string) {     if (string.startsWith(\"'\") && string.endsWith(\"'\")) {       string = string.substring(1, string.length() - 1);              if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) ||     (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) ||     (string.indexOf(\"\\\\\\\\\") != -1) ||     (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1) ||    (string.indexOf(\"\\\\u001E\") != -1)) {  string = unbackQuoteChars(string);       }     }      return string;   }\n", "docstring": "unquotes previously quoted string necessary removes single quotes around inverse quote string\n", "func_name": "64"}
{"url": "65", "code": "public FessMessages addSuccessFailureUrlDeleteAll(String property) {         assertPropertyNotNull(property);         add(property, new UserMessage(SUCCESS_failure_url_delete_all));         return this;     }\n", "docstring": "add created action message key success failure url delete parameters pre message deleted failure urls pre\n", "func_name": "65"}
{"url": "66", "code": "public void setManagedByVDC(ClusterComputeResource cluster, boolean status) throws InvalidState, NotFound, RuntimeFault, RemoteException {         getVimService().setManagedByVDC(getMOR(), cluster.getMOR(), status);     }\n", "docstring": "sets whether cluster managed virtual datacenter setting prevent users disabling cluster\n", "func_name": "66"}
{"url": "67", "code": "public void setOutgoingLinks(FSArray v) {     if (Descriptor_Type.featOkTst && ((Descriptor_Type)jcasType).casFeat_outgoingLinks == null)       jcasType.jcas.throwFeatMissing(\"outgoingLinks\", \"de.julielab.jules.types.wikipedia.Descriptor\");     jcasType.ll_cas.ll_setRefValue(addr, ((Descriptor_Type)jcasType).casFeatCode_outgoingLinks, jcasType.ll_cas.ll_getFSRef(v));} public void setOutgoingLinks(int i, Title v) {      if (Descriptor_Type.featOkTst && ((Descriptor_Type)jcasType).casFeat_outgoingLinks == null)       jcasType.jcas.throwFeatMissing(\"outgoingLinks\", \"de.julielab.jules.types.wikipedia.Descriptor\");     jcasType.jcas.checkArrayBounds(jcasType.ll_cas.ll_getRefValue(addr, ((Descriptor_Type)jcasType).casFeatCode_outgoingLinks), i);     jcasType.ll_cas.ll_setRefArrayValue(jcasType.ll_cas.ll_getRefValue(addr, ((Descriptor_Type)jcasType).casFeatCode_outgoingLinks), i, jcasType.ll_cas.ll_getFSRef(v));}\n", "docstring": "setter outgoing links sets list outgoing links pointing wikipedia pages starting wikipedia page indexed setter outgoing links sets indexed value list outgoing links pointing wikipedia pages starting wikipedia page\n", "func_name": "67"}
{"url": "68", "code": "public TypeSignature getTypeDescriptor() {         if (typeDescriptorStr == null) {             return null;         }         if (typeDescriptor == null) {             try {                 typeDescriptor = TypeSignature.parse(typeDescriptorStr, declaringClassName);                 typeDescriptor.setScanResult(scanResult);             } catch (final ParseException e) {                 throw new IllegalArgumentException(e);             }         }         return typeDescriptor;     }\n", "docstring": "returns parsed type descriptor field available\n", "func_name": "68"}
{"url": "69", "code": "private int addExtendedName(int maxlength)     {         for (int i = TYPE_NAMES_.length - 1; i >= 0; i --) {             // for each category, count the length of the category name             // plus 9 =             // 2 for <>             // 1 for -             // 6 for most hex digits per code point             int length = 9 + add(m_nameSet_, TYPE_NAMES_[i]);             if (length > maxlength) {                 maxlength = length;             }         }         return maxlength;     }\n", "docstring": "adds extended names name set equivalent part calc ext name sets lengths\n", "func_name": "69"}
{"url": "70", "code": "protected static double weightedDistance(NumberVector v1, NumberVector v2, long[] weightVector) {     double sqrDist = 0;     for(int i = BitsUtil.nextSetBit(weightVector, 0); i >= 0; i = BitsUtil.nextSetBit(weightVector, i + 1)) {       double manhattanI = v1.doubleValue(i) - v2.doubleValue(i);       sqrDist += manhattanI * manhattanI;     }     return FastMath.sqrt(sqrDist);   }\n", "docstring": "computes weighted distance two specified vectors according given preference vector\n", "func_name": "70"}
{"url": "71", "code": "private void digestInteger(MessageDigest digest, int value) {         byte[] valueBytes = new byte[4];         Util.numberToBytes(value, valueBytes, 0, 4);         digest.update(valueBytes);     }\n", "docstring": "helper method add java integer value message digest\n", "func_name": "71"}
{"url": "72", "code": "public static TypeAnnotationPosition         methodInvocationTypeArg(final List<TypePathEntry> location,                                 final JCLambda onLambda,                                 final int type_index,                                 final int pos) {         return new TypeAnnotationPosition(TargetType.METHOD_INVOCATION_TYPE_ARGUMENT,                                           pos, Integer.MIN_VALUE, onLambda,                                           type_index, Integer.MIN_VALUE,                                           location);     } public static TypeAnnotationPosition         methodInvocationTypeArg(final List<TypePathEntry> location,                                 final int type_index) {         return methodInvocationTypeArg(location, null, type_index, -1);     }\n", "docstring": "create code type annotation position method invocation type argument create code type annotation position method invocation type argument\n", "func_name": "72"}
{"url": "73", "code": "protected boolean isPotentialLazyCrossReference(EStructuralFeature feature) {   return !feature.isDerived() && !feature.isTransient()      && feature instanceof EReference && ((EReference)feature).isResolveProxies();  }\n", "docstring": "return code code given feature may hold proxy resolved\n", "func_name": "73"}
{"url": "74", "code": "public Response unprotectResponse(Response response) throws IOException {         try {             if (!supportsProtection() || !HttpHeaders.hasBody(response)) {                 return response;             }              if (!response.header(\"content-type\").toLowerCase().contains(\"application/jose+json\")) {                 return response;             }              JWSObject jwsObject = JWSObject.deserialize(response.body().string());             JWSHeader jwsHeader = jwsObject.jwsHeader();              if (!jwsHeader.kid().equals(serverSignatureKey.kid()) || !jwsHeader.alg().equals(\"RS256\")) {                 throw new IOException(\"Invalid protected response\");             }              byte[] data = (jwsObject.originalProtected() + \".\" + jwsObject.payload()).getBytes(MESSAGE_ENCODING);             byte[] signature = MessageSecurityHelper.base64UrltoByteArray(jwsObject.signature());              RsaKey serverSignatureRsaKey = new RsaKey(serverSignatureKey.kid(), serverSignatureKey.toRSA(false));             boolean signed = serverSignatureRsaKey.verifyAsync(getSha256(data), signature, \"RS256\").get();             if (!signed) {                 throw new IOException(\"Wrong signature.\");             }              String decrypted = unprotectPayload(jwsObject.payload());              MediaType contentType = response.body().contentType();             ResponseBody body = ResponseBody.create(contentType, decrypted);             return response.newBuilder().body(body).build();         } catch (ExecutionException e) {             // unexpected;             return null;         } catch (InterruptedException e) {             // unexpected;             return null;         } catch (NoSuchAlgorithmException e) {             // unexpected;             return null;         }     }\n", "docstring": "unprotect response needed replaces body unencrypted version\n", "func_name": "74"}
{"url": "75", "code": "private static void resetMapperForCQL3(boolean isCql3Enabled)     {         if (isCql3Enabled)         {             validationClassMapper.put(Byte.class, Int32Type.class);             validationClassMapper.put(byte.class, Int32Type.class);             validationClassMapper.put(Short.class, Int32Type.class);             validationClassMapper.put(short.class, Int32Type.class);             validationClassMapper.put(java.sql.Time.class, TimestampType.class);             validationClassMapper.put(java.sql.Date.class, TimestampType.class);             validationClassMapper.put(java.util.Date.class, TimestampType.class);             validationClassMapper.put(java.sql.Timestamp.class, TimestampType.class);          }     }\n", "docstring": "reset mapper\n", "func_name": "75"}
{"url": "76", "code": "private void callUnbind(NameComponent[] path) throws NamingException {         if (_nc == null)             throw IIOPLogger.ROOT_LOGGER.notANamingContext(path.toString());         try {             _nc.unbind(path);         } catch (NotFound e) {             // If leaf is the one missing, return success             // as per JNDI spec              if (leafNotFound(e, path[path.length - 1])) {                 // do nothing             } else {                 throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, path);             }         } catch (Exception e) {             throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, path);         }     }\n", "docstring": "calls unbind api cos naming uses exception mapper class map exceptions\n", "func_name": "76"}
{"url": "77", "code": "@Deprecated     public static boolean nodeExists(Object json, String path) {         return !getNode(json, path).isMissingNode();     }\n", "docstring": "returns node exists\n", "func_name": "77"}
{"url": "78", "code": "@SneakyThrows     public static PublicKey extractPublicKeyFromResource(final String secretKeyToUse) {         LOGGER.debug(\"Attempting to extract public key from [{}]...\", secretKeyToUse);         val resource = ResourceUtils.getResourceFrom(secretKeyToUse);         val factory = new PublicKeyFactoryBean();         factory.setAlgorithm(RsaKeyUtil.RSA);         factory.setResource(resource);         factory.setSingleton(false);         return factory.getObject();     }\n", "docstring": "extract key resource key\n", "func_name": "78"}
{"url": "79", "code": "synchronized public Set getClassesForPackage( String pack ) {         insureInitialized();         Set set = new HashSet();         Collection c = (Collection)packageMap.get( pack );         if ( c != null )             set.addAll( c );          if ( compPaths != null )             for (int i=0; i<compPaths.size(); i++) {                 c = ((BshClassPath)compPaths.get(i)).getClassesForPackage(                     pack );                 if ( c != null )                     set.addAll( c );             }         return set;     }\n", "docstring": "return set class names specified including component paths\n", "func_name": "79"}
{"url": "80", "code": "ServerSessionContext registerResult(long sequence, ServerStateMachine.Result result) {     results.put(sequence, result);     return this;   }\n", "docstring": "registers session result results stored memory servers order provide linear able semantics command applied state machine command return value stored sequence number client acknowledges receipt command output result cleared memory\n", "func_name": "80"}
{"url": "81", "code": "private void checkMarkupLevel(final int markupLevel) {         if (markupLevel >= this.matchedMarkupLevels.length) {             final int newLen = Math.max(markupLevel + 1, this.matchedMarkupLevels.length + MATCHED_MARKUP_LEVELS_LEN);             final boolean[] newMatchedMarkupLevels = new boolean[newLen];             Arrays.fill(newMatchedMarkupLevels, false);             System.arraycopy(this.matchedMarkupLevels, 0, newMatchedMarkupLevels, 0, this.matchedMarkupLevels.length);             this.matchedMarkupLevels = newMatchedMarkupLevels;         }     }\n", "docstring": "level handling\n", "func_name": "81"}
{"url": "82", "code": "public static MozuUrl deletePackageUrl(String packageId, String returnId)   {    UrlFormatter formatter = new UrlFormatter(\"/api/commerce/returns/{returnId}/packages/{packageId}\");    formatter.formatUrl(\"packageId\", packageId);    formatter.formatUrl(\"returnId\", returnId);    return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.TENANT_POD) ;   }\n", "docstring": "get resource url delete\n", "func_name": "82"}
{"url": "83", "code": "private void emitNode() throws TTIOException {         switch (mRtx.getNode().getKind()) {         case ROOT:             mEvent = mFac.createStartDocument();             break;         case ELEMENT:             final long key = mRtx.getNode().getDataKey();             final QName qName = mRtx.getQNameOfCurrentNode();             mEvent = mFac.createStartElement(qName, new AttributeIterator(mRtx), new NamespaceIterator(mRtx));             mRtx.moveTo(key);             break;         case TEXT:             mEvent = mFac.createCharacters(mRtx.getValueOfCurrentNode());             break;         default:             throw new IllegalStateException(\"Kind not known!\");         }     }\n", "docstring": "emit node\n", "func_name": "83"}
{"url": "84", "code": "public void enableOverride(int overrideId, int pathId, String clientUUID) throws Exception {         // get profileId from pathId         int profileId = PathOverrideService.getInstance().getPath(pathId).getProfileId();         int newPriority = 0;          // we want to limit -1, -2 to only be added once since they are the Custom responses/requests         if (overrideId == Constants.PLUGIN_REQUEST_OVERRIDE_CUSTOM) {             if (this.getEnabledEndpoint(pathId, overrideId, null, clientUUID) != null) {                 return;             }         }          // need to first determine the highest enabled order value for this path         HashMap<String, Object> priorities = sqlService.getFirstResult(             \"SELECT * FROM \" + Constants.DB_TABLE_ENABLED_OVERRIDE +                 \" WHERE \" + Constants.REQUEST_RESPONSE_PATH_ID + \"=\" + pathId +                 \" AND \" + Constants.GENERIC_CLIENT_UUID + \"='\" + clientUUID +                 \"' ORDER BY + \" + Constants.ENABLED_OVERRIDES_PRIORITY + \" DESC\"         );         if (priorities != null) {             newPriority = Integer.valueOf(priorities.get(Constants.ENABLED_OVERRIDES_PRIORITY.toUpperCase()).toString()) + 1;         }          PreparedStatement statement = null;         try (Connection sqlConnection = sqlService.getConnection()) {              PreparedStatement query = null;             ResultSet results = null;             SQLService sqlService = SQLService.getInstance();             com.groupon.odo.proxylib.models.Method method = null;             query = sqlConnection.prepareStatement(                 \"SELECT * FROM \" + Constants.DB_TABLE_OVERRIDE +                     \" WHERE \" + Constants.GENERIC_ID + \" = ?\"             );             query.setString(1, String.valueOf(overrideId));             results = query.executeQuery();             JSONSerializer serializer = new JSONSerializer();             if (results.next()) {                 String className = results.getString(Constants.OVERRIDE_CLASS_NAME);                 String methodName = results.getString(Constants.OVERRIDE_METHOD_NAME);                 method = PluginManager.getInstance().getMethod(className, methodName);             }              statement = sqlConnection.prepareStatement(                 \"INSERT INTO \" + Constants.DB_TABLE_ENABLED_OVERRIDE +                     \"(\" + Constants.GENERIC_PROFILE_ID + \",\" + Constants.GENERIC_CLIENT_UUID + \",\" +                     Constants.REQUEST_RESPONSE_PATH_ID + \",\" + Constants.ENABLED_OVERRIDES_OVERRIDE_ID + \",\" +                     Constants.ENABLED_OVERRIDES_PRIORITY + \",\" + Constants.ENABLED_OVERRIDES_ARGUMENTS +  \",\" +                     Constants.ENABLED_OVERRIDES_RESPONSE_CODE + \")\" +                     \" VALUES (?, ?, ?, ?, ?, ?, ?);\"             );             statement.setInt(1, profileId);             statement.setString(2, clientUUID);             statement.setInt(3, pathId);             statement.setInt(4, overrideId);             statement.setInt(5, newPriority);             if (method == null) {                 statement.setString(6, \"\");             } else {                 ArrayList<String> argDefaults = new ArrayList<String>();                 for (int i = 0; i < method.getMethodArguments().length; i++) {                     if (i < method.getMethodDefaultArguments().length && method.getMethodDefaultArguments()[i] != null) {                         argDefaults.add(String.valueOf(method.getMethodDefaultArguments()[i]));                     } else {                         argDefaults.add(\"\");                     }                 }                 statement.setString(6, serializer.serialize(argDefaults));             }             statement.setString(7,\"200\");             statement.executeUpdate();         } catch (Exception e) {             e.printStackTrace();         } finally {             try {                 if (statement != null) {                     statement.close();                 }             } catch (Exception e) {             }         }     }\n", "docstring": "enable specific path\n", "func_name": "84"}
{"url": "85", "code": "public static <T> Middleware<AsyncHandler<Response<T>>, AsyncHandler<Response<ByteString>>>   htmlSerializeResponse(final String templateName) {     return handler ->         requestContext -> handler.invoke(requestContext)             .thenApply(response -> response                 .withPayload(serialize(templateName, response.payload().orElse(null)))                 .withHeader(CONTENT_TYPE, HTML));   }\n", "docstring": "sync middle ware response object\n", "func_name": "85"}
{"url": "86", "code": "public void updateSite(String siteRoot) {          try {             CmsObject cloneCms = OpenCms.initCmsObject(m_cms);             if (siteRoot == null) {                 siteRoot = \"/system\";             }             cloneCms.getRequestContext().setSiteRoot(siteRoot);             m_cms = cloneCms;         } catch (CmsException e1) {             LOG.error(e1.getLocalizedMessage(), e1);         }         updateValidation();     }\n", "docstring": "updates site root\n", "func_name": "86"}
{"url": "87", "code": "public static ByteBuffer combine(final Collection<ByteBuffer> buffers) {          final ByteBuffer buf = ByteBuffer.allocate(remaining(buffers));          for (final Iterator iter = buffers.iterator(); iter.hasNext();) {              final ByteBuffer curBuf = (ByteBuffer) iter.next();              buf.put(curBuf);          }          buf.flip();          return buf;      }\n", "docstring": "combines remaining data given code collection code code buffer code single consolidated code buffer code\n", "func_name": "87"}
{"url": "88", "code": "private void copy(final InputStream inputStream, final FileOutputStream outputStream) throws IOException {         final byte[] buffer = new byte[1024*4];         int n;         try {             while (-1 != (n = inputStream.read(buffer))) {                 outputStream.write(buffer, 0, n);             }         } finally {             inputStream.close();             outputStream.close();         }     }\n", "docstring": "copies input stream output stream using buffer\n", "func_name": "88"}
{"url": "89", "code": "@Override     public T addAsServiceProviderAndClasses(Class<?> serviceInterface, Class<?>... serviceImpls)         throws IllegalArgumentException {         Validate.notNull(serviceInterface, \"ServiceInterface must be specified\");         Validate.notNullAndNoNullValues(serviceImpls, \"ServiceImpls must be specified and can not contain null values\");          addAsServiceProvider(serviceInterface, serviceImpls);         addClass(serviceInterface);         return addClasses(serviceImpls);     }\n", "docstring": "non java doc\n", "func_name": "89"}
{"url": "90", "code": "public static String collapseDots(String path) {     path = removeExtraneousSlashes(path);     // Optimization: Most paths don't contain dots.     if (!path.contains(\".\")) {       return path;     }      List<String> dstFragments = new ArrayList<>();     for (String fragment : Splitter.on('/').split(path)) {       if (fragment.equals(\"..\")) {         if (!dstFragments.isEmpty()) {           dstFragments.remove(dstFragments.size() - 1);         }       } else if (!fragment.equals(\".\")) {         dstFragments.add(fragment);       }     }      // Special case for Join.join([\"\"]); -> \"/\"     if (dstFragments.size() == 1 && dstFragments.get(0).isEmpty()) {       return \"/\";     }     return Joiner.on(\"/\").join(dstFragments);   }\n", "docstring": "removes entries within given path extra move beyond first directory given removed\n", "func_name": "90"}
{"url": "91", "code": "public void setStorage(java.util.Collection<ValidStorageOptions> storage) {         if (storage == null) {             this.storage = null;             return;         }          this.storage = new java.util.ArrayList<ValidStorageOptions>(storage);     }\n", "docstring": "valid storage options instance\n", "func_name": "91"}
{"url": "92", "code": "public static void memInfo(final Map<String, Object> infos) {         infos.put(\"heap.used\", MEM_BEAN.getHeapMemoryUsage());         infos.put(\"offHeap.used\", MEM_BEAN.getNonHeapMemoryUsage());         infos.put(\"heap.pendingFinalize\", MEM_BEAN.getObjectPendingFinalizationCount());     }\n", "docstring": "collects system information delivered link memory bean\n", "func_name": "92"}
{"url": "93", "code": "static private void parseHeader(String base, XMLStreamReader rdr, List<String> cols, List<String> md) throws XMLStreamException, SparqlException {     logger.debug(\"xml:base is initially {}\", base);     base = getBase(base, rdr);     testOpen(rdr, rdr.nextTag(), HEAD, \"Missing header from XML results\");     base = getBase(base, rdr);     boolean endedVars = false;     int eventType;     while ((eventType = rdr.nextTag()) != END_ELEMENT || !nameIs(rdr, HEAD)) {       if (eventType == START_ELEMENT) {         if (nameIs(rdr, VARIABLE)) {           if (endedVars) throw new SparqlException(\"Encountered a variable after header metadata\");           String var = rdr.getAttributeValue(null, \"name\");           if (var != null) cols.add(var);           else logger.warn(\"<variable> element without 'name' attribute\");         } else if (nameIs(rdr, LINK)) {           String b = getBase(base, rdr); // Copy to a new var since we're looping.           String href = rdr.getAttributeValue(null, HREF);           if (href != null) md.add(resolve(b, href));           else logger.warn(\"<link> element without 'href' attribute\");           endedVars = true;         }       }     }     // ending on </head>. next() should be <results> or <boolean>     testClose(rdr, eventType, HEAD, \"Unexpected element in header: \" + rdr.getLocalName());   }\n", "docstring": "parse head element variables metadata\n", "func_name": "93"}
{"url": "94", "code": "public static String getName(final String aURLString) {         int pathnameEndIndex;         if (isWindows()) {             if (aURLString.contains(SHARP)) {                 pathnameEndIndex = aURLString.lastIndexOf(SHARP);             } else {                 pathnameEndIndex = aURLString.lastIndexOf(WINDOWS_SEPARATOR);                 if (pathnameEndIndex == -1) {                     pathnameEndIndex = aURLString.lastIndexOf(UNIX_SEPARATOR);                 }             }         } else {             if (aURLString.contains(SHARP)) {                 pathnameEndIndex = aURLString.lastIndexOf(SHARP);             }             pathnameEndIndex = aURLString.lastIndexOf(UNIX_SEPARATOR);         }          String schemaLocation;         if (aURLString.contains(SHARP)) {             schemaLocation = aURLString.substring(0, pathnameEndIndex);         } else {             schemaLocation = aURLString.substring(pathnameEndIndex + 1);         }          return schemaLocation;     }\n", "docstring": "get filename path\n", "func_name": "94"}
{"url": "95", "code": "public static MmtfSummaryDataBean getStructureInfo(Structure structure) {   MmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();   // Get all the atoms   List<Atom> theseAtoms = new ArrayList<>();   List<Chain> allChains = new ArrayList<>();   Map<String, Integer> chainIdToIndexMap = new LinkedHashMap<>();   int chainCounter = 0;   int bondCount = 0;   mmtfSummaryDataBean.setAllAtoms(theseAtoms);   mmtfSummaryDataBean.setAllChains(allChains);   mmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);   for (int i=0; i<structure.nrModels(); i++){    List<Chain> chains = structure.getModel(i);    allChains.addAll(chains);    for (Chain chain : chains) {     String idOne = chain.getId();     if (!chainIdToIndexMap.containsKey(idOne)) {      chainIdToIndexMap.put(idOne, chainCounter);     }     chainCounter++;     for (Group g : chain.getAtomGroups()) {      for(Atom atom: getAtomsForGroup(g)){       theseAtoms.add(atom);       // If both atoms are in the group       if (atom.getBonds()!=null){        bondCount+=atom.getBonds().size();       }      }     }    }   }   // Assumes all bonds are referenced twice   mmtfSummaryDataBean.setNumBonds(bondCount/2);   return mmtfSummaryDataBean;   }\n", "docstring": "get summary information structure\n", "func_name": "95"}
{"url": "96", "code": "public HttpServerInterceptorChain<I, O, II, OO> next(final Interceptor<II, OO> next) {         return new HttpServerInterceptorChain<>(new TransformingInterceptor<I, O, II, OO>() {             @Override             public RequestHandler<I, O> intercept(RequestHandler<II, OO> handler) {                 return interceptor.intercept(next.intercept(handler));             }         });     }\n", "docstring": "add next interceptor chain\n", "func_name": "96"}
{"url": "97", "code": "public static <T> boolean arrayContainsRef(T[] array, T value) {    for (int i = 0; i < array.length; i++) {     if (array[i] == value) {      return true;     }    }    return false;   }\n", "docstring": "checks given array contains specified value method works strict reference comparison\n", "func_name": "97"}
{"url": "98", "code": "protected boolean isExtendingTraceeContextProvider(final Object instance) {          if (instance == null) {             return false;         }          return ImplicitContextData.class.isAssignableFrom(instance.getClass()) || WrappedContextData.class.isAssignableFrom(instance.getClass());      }\n", "docstring": "checks whether passed instance extends link implicit context data link trace context logger context provider api wrapped context data types\n", "func_name": "98"}
{"url": "99", "code": "public void setSourceSegments(java.util.Collection<SegmentReference> sourceSegments) {         if (sourceSegments == null) {             this.sourceSegments = null;             return;         }          this.sourceSegments = new java.util.ArrayList<SegmentReference>(sourceSegments);     }\n", "docstring": "base segment build segment source segment defines starting universe endpoints add dimensions segment filters source segment based dimensions specify specify one dimensional segment specify one imported segment\n", "func_name": "99"}
