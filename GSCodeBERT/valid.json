{"url": "327064", "code": "public boolean deleteLedgerMetadata(EditLogLedgerMetadata ledger, int version)       throws IOException {     String ledgerPath = fullyQualifiedPathForLedger(ledger);     try {       zooKeeper.delete(ledgerPath, version);       return true;     } catch (KeeperException.NoNodeException e) {       LOG.warn(ledgerPath + \" does not exist. Returning false, ignoring \" +           e);     } catch (KeeperException.BadVersionException e) {       keeperException(\"Unable to delete \" + ledgerPath + \", version does not match.\" +           \" Updated by another process?\", e);     } catch (KeeperException e) {       keeperException(\"Unrecoverable ZooKeeper error deleting \" + ledgerPath,           e);     } catch (InterruptedException e) {       interruptedException(\"Interrupted deleting \" + ledgerPath, e);     }     return false;   }\n", "docstring": "removes ledger related metadata bookkeeper delete ledger\n", "func_name": "327064"}
{"url": "327065", "code": "@Override  public void body() {    CallQueue queue = (CallQueue) getBeliefbase().getBelief(\"queue\")     .getFact();    Call call = queue.getPendingCall();   if (call.getCustormer().getLanguage().equalsIgnoreCase(\"English\")) {     String target_service = \"report-service\";    String msgContent = \"NewRecordedCall\";     // Looking for reporter agent    IDF df = (IDF) SServiceProvider.getService(getServiceContainer(),      IDF.class, RequiredServiceInfo.SCOPE_PLATFORM).get(this);    IDFServiceDescription sd = df.createDFServiceDescription(      target_service, null, null);    IDFComponentDescription dfadesc = df.createDFComponentDescription(      null, sd);     ISearchConstraints constraints = df.createSearchConstraints(-1, 0);     // Use a subgoal to search    IGoal ft = createGoal(\"dfcap.df_search\");    ft.getParameter(\"description\").setValue(dfadesc);    ft.getParameter(\"constraints\").setValue(constraints);     dispatchSubgoalAndWait(ft);    IDFComponentDescription[] agents = (IDFComponentDescription[]) ft      .getParameterSet(\"result\").getValues();     if (agents.length > 0) {     IMessageEvent msg = createMessageEvent(\"send_inform\");     msg.getParameter(SFipa.CONTENT).setValue(msgContent);     msg.getParameterSet(SFipa.RECEIVERS).addValue(       agents[0].getName());     sendMessage(msg);     logger.info(\"Message sent to: \"       + agents[0].getName().getLocalName());    } else {     logger.severe(\"Service \" + target_service + \" not found.\");    }    } else {     System.out.println(\"Language: \" + call.getCustormer().getLanguage());    String target_service = \"helpdesk-service\";    String msgContent = \"UnknownLanguageCall\";     // Looking for reporter agent    IDF df = (IDF) SServiceProvider.getService(getServiceContainer(),      IDF.class, RequiredServiceInfo.SCOPE_PLATFORM).get(this);    IDFServiceDescription sd = df.createDFServiceDescription(      target_service, null, null);    IDFComponentDescription dfadesc = df.createDFComponentDescription(      null, sd);     ISearchConstraints constraints = df.createSearchConstraints(-1, 0);     // Use a subgoal to search    IGoal ft = createGoal(\"dfcap.df_search\");    ft.getParameter(\"description\").setValue(dfadesc);    ft.getParameter(\"constraints\").setValue(constraints);     dispatchSubgoalAndWait(ft);    IDFComponentDescription[] agents = (IDFComponentDescription[]) ft      .getParameterSet(\"result\").getValues();     IMessageEvent msg = createMessageEvent(\"helpdesk-request\");    msg.getParameter(SFipa.CONTENT).setValue(msgContent);    if (agents.length > 0) {     msg.getParameterSet(SFipa.RECEIVERS).addValue(       agents[0].getName());     sendMessage(msg);     System.out.println(\"Enviado\");    } else {     System.out.println(\"Service \" + target_service + \" not found.\");     logger.severe(\"Service \" + target_service + \" not found.\");    }     logger.info(\"Message sent to: \" + agents[0].getName());    }  }\n", "docstring": "non java doc\n", "func_name": "327065"}
{"url": "327066", "code": "public Sheet createSheetInWorkspace(long workspaceId, Sheet sheet) throws SmartsheetException {         return this.createResource(\"workspaces/\" + workspaceId + \"/sheets\", Sheet.class, sheet);     }\n", "docstring": "create sheet given work space\n", "func_name": "327066"}
{"url": "327067", "code": "@Override   public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, float boost)       throws IOException {     return baseQuery.createWeight(searcher, needsScores, boost);   }\n", "docstring": "non java doc\n", "func_name": "327067"}
{"url": "327068", "code": "public void marshall(PostCommentReplyRequest postCommentReplyRequest, ProtocolMarshaller protocolMarshaller) {          if (postCommentReplyRequest == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(postCommentReplyRequest.getInReplyTo(), INREPLYTO_BINDING);             protocolMarshaller.marshall(postCommentReplyRequest.getClientRequestToken(), CLIENTREQUESTTOKEN_BINDING);             protocolMarshaller.marshall(postCommentReplyRequest.getContent(), CONTENT_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327068"}
{"url": "327069", "code": "public static String getDetailOnlyPageName(         CmsObject cms,         CmsResource pageResource,         String detailPath,         String locale) {          return getDetailOnlyPageNameWithoutLocaleCheck(detailPath, getDetailContainerLocale(cms, locale, pageResource));     }\n", "docstring": "returns site root path detail container page site root path detail content\n", "func_name": "327069"}
{"url": "327070", "code": "public long getPrice(Configuration configuration) {         long total = 0;         for (KnapsackItem knapsackItem : getKnapsackItems()) {             if (configuration.valueAt(knapsackItem.getIndex()) == 1) {                 total += knapsackItem.getPrice();             }         }         return total;     }\n", "docstring": "returns price items given configuration\n", "func_name": "327070"}
{"url": "327071", "code": "public static base_response delete(nitro_service client, nsip resource) throws Exception {   nsip deleteresource = new nsip();   deleteresource.ipaddress = resource.ipaddress;   deleteresource.td = resource.td;   return deleteresource.delete_resource(client);  }\n", "docstring": "use api delete sip\n", "func_name": "327071"}
{"url": "327072", "code": "public float invokeFloat(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {         return ((Number) invoke(operationName, stubStrategy, params)).floatValue();     }\n", "docstring": "sends request message server receives reply server returns code code result caller\n", "func_name": "327072"}
{"url": "327073", "code": "static Injector build(final GuiceRegistry registry,                        ClassScannerFactory scannerFactory,                        final List<PropertyFile> configs,                        final List<GuiceRole> roles,                        final GuiceSetup staticSetup,                        final boolean autoLoadProperties,                        final boolean autoLoadRoles,                        final ClassLoader classloader)  {   final ServiceLoader<GuiceRole> loader = ServiceLoader.load(GuiceRole.class);    // Find additional guice roles from jar files using the Service Provider Interface   if (autoLoadRoles)   {    Iterator<GuiceRole> it = loader.iterator();    while (it.hasNext())    {     final GuiceRole role = it.next();      log.debug(\"Discovered guice role: \" + role);      roles.add(role);    }   }    //  Make sure that the first most basic level of properties is the system environment variables   configs.add(0, getAllEnvironmentVariables());    // Allow all GuiceRole implementations to add/remove/reorder configuration sources   for (GuiceRole role : roles)   {    log.debug(\"Adding requested guice role: \" + role);    role.adjustConfigurations(configs);   }    GuiceConfig properties = new GuiceConfig();    // Generate a random instance ID for this instance of the guice environment   final String instanceId = SimpleId.alphanumeric(32);    // Make the randomly generated instance id available to others   properties.set(GuiceProperties.INSTANCE_ID, instanceId);     for (PropertyFile config : configs)    properties.setAll(config);    // Load all the core property files?   if (autoLoadProperties)   {    applyConfigs(classloader, properties);   }    // This is a bit of a hack really, but let's insert the GuiceRole for network config if network config is enabled   if (hasNetworkConfiguration(properties))   {    final NetworkConfigGuiceRole role = new NetworkConfigGuiceRole();     roles.add(role);   }    // Read the override configuration property to find the override config file   // Load the override config file and pass that along too.   PropertyFile overrideFile = load(properties.get(GuiceProperties.OVERRIDE_FILE_PROPERTY));    // If there are overrides then rebuild the configuration to reflect it   if (overrideFile != null)   {    log.debug(\"Applying overrides: \" + overrideFile.getFile());    properties.setOverrides(overrideFile.toMap());   }     // Set up the class scanner factory (if the scanner property is set and one has not been provided)   if (scannerFactory == null)   {    List<String> packages = properties.getList(GuiceProperties.SCAN_PACKAGES, Collections.emptyList());     if (packages != null && !packages.isEmpty())     scannerFactory = new ClassScannerFactory(packages.toArray(new String[packages.size()]));    else     throw new IllegalArgumentException(\"Property \" + GuiceProperties.SCAN_PACKAGES + \" has not been set!\");   }    final GuiceSetup setup;   if (staticSetup == null)   {    // Load the Setup property and load the Setup class    final Class<? extends GuiceSetup> setupClass = getClass(properties, GuiceSetup.class, GuiceProperties.SETUP_PROPERTY);     try    {     if (setupClass == null)      throw new IllegalArgumentException(\"Could not find a setup class!\");      setup = setupClass.newInstance();      log.debug(\"Constructed GuiceSetup: \" + setupClass);    }    catch (InstantiationException | IllegalAccessException e)    {     throw new IllegalArgumentException(\"Error constructing instance of \" + setupClass, e);    }   }   else   {    log.debug(\"Using static GuiceSetup: \" + staticSetup);    setup = staticSetup;   }    return createInjector(registry, scannerFactory, properties, setup, roles);  }\n", "docstring": "build ice environment achieved following stages load ice role implementations using link service loader service provider allow ice role instances add remove change base configuration load configuration file resources environment properties load network configuration enabled add special ice role network configuration auto reload network configuration enabled load configuration file present set class path scanner using property link ice properties packages instantiate link ice setup class specified link ice properties setup property hand ice setup roles configuration class path scanner link create injector ice registry class scanner factory ice config ice setup list\n", "func_name": "327073"}
{"url": "327074", "code": "public ECDSASignature sign(byte[] messageHash) {         ECDSASignature sig = doSign(messageHash);         // Now we have to work backwards to figure out the recId needed to recover the         // signature.         int recId = -1;         byte[] thisKey = this.pub.getEncoded(/* compressed */ false);         for (int i = 0; i < 4; i++) {             byte[] k = ECKey.recoverPubBytesFromSignature(i, sig, messageHash);             if (k != null && Arrays.equals(k, thisKey)) {                 recId = i;                 break;             }         }         if (recId == -1)             throw new RuntimeException(\"Could not construct a recoverable key. This should never happen.\");         sig.v = (byte) (recId + 27);         return sig;     }\n", "docstring": "takes cca hash bytes data returns cds signature\n", "func_name": "327074"}
{"url": "327075", "code": "public void marshall(HttpHeader httpHeader, ProtocolMarshaller protocolMarshaller) {          if (httpHeader == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(httpHeader.getHeaderName(), HEADERNAME_BINDING);             protocolMarshaller.marshall(httpHeader.getHeaderValue(), HEADERVALUE_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327075"}
{"url": "327076", "code": "public void clear(long index) {         int wordNum = (int)(index >> 6); // div 64         if (wordNum>=wlen) return;         int bit = (int)index & 0x3f;     // mod 64         long bitmask = 1L << bit;         bits[wordNum] &= ~bitmask;     }\n", "docstring": "clears bit allowing access beyond current set size without changing size\n", "func_name": "327076"}
{"url": "327077", "code": "public void add(CSVRecord record) {         if (records == null)             records = new ArrayList<>();         records.add(record);     }\n", "docstring": "add record\n", "func_name": "327077"}
{"url": "327078", "code": "public void runCalendarEntry(Map<String,Object> properties)     {         ProcessRunnerTask task = new ProcessRunnerTask(null, null, properties);         ((Application)this.getTask().getApplication()).getTaskScheduler().addTask(task);     }\n", "docstring": "run calendar entry method\n", "func_name": "327078"}
{"url": "327079", "code": "public static boolean isValidInt(@Nullable final String integerStr) {         if (StringUtils.isBlank(integerStr)) {             return false;         }         final String stripedInteger = StringUtils.strip(integerStr);         try {             NumberUtils.createInteger(stripedInteger);             return true;         } catch (NumberFormatException e) {             return false;         }     } public static boolean isValidInt(@Nullable final String integerStr, final int lowerBound, final int upperBound, final boolean includeLowerBound, final boolean includeUpperBound) {         if (lowerBound > upperBound) {             throw new IllegalArgumentException(ExceptionValues.INVALID_BOUNDS);         } else if (!isValidInt(integerStr)) {             return false;         }         final int aInteger = toInteger(integerStr);         final boolean respectsLowerBound = includeLowerBound ? lowerBound <= aInteger : lowerBound < aInteger;         final boolean respectsUpperBound = includeUpperBound ? aInteger <= upperBound : aInteger < upperBound;         return respectsLowerBound && respectsUpperBound;     } public static boolean isValidInt(@Nullable final String integerStr, final int lowerBound, final int upperBound) {         return isValidInt(integerStr, lowerBound, upperBound, true, false);     }\n", "docstring": "given integer string checks valid integer based apaches number utils create integer given integer string checks valid integer base apaches number utils create integer lower bound upper bound given integer string checks valid integer base apaches number utils create integer lower bound upper bound including lower bound excluding upper bound\n", "func_name": "327079"}
{"url": "327080", "code": "@XmlElementDecl(namespace = \"http://www.w3.org/ns/prov#\", name = \"wasInformedBy\")     public JAXBElement<WasInformedBy> createWasInformedBy(WasInformedBy value) {         return new JAXBElement<WasInformedBy>(_WasInformedBy_QNAME, WasInformedBy.class, null, value);     }\n", "docstring": "create instance link axb element code link informed code\n", "func_name": "327080"}
{"url": "327081", "code": "public static Thread newThread(String name, Runnable runnable, boolean daemon) {         Thread thread = new Thread(runnable, name);         thread.setDaemon(daemon);         return thread;     }\n", "docstring": "create thread\n", "func_name": "327081"}
{"url": "327082", "code": "@GET     @Path(\"{uuid}\")     public Violation getViolationByUuid(@PathParam(\"uuid\") UUID violationUuid) throws NotFoundException{         logger.debug(\"StartOf getViolationByUuid - REQUEST for /violations/{}\", violationUuid);         ViolationHelperE violationRestHelper = getViolationHelper();         Violation violation = violationRestHelper.getViolationByUUID(violationUuid);         if (violation==null){             logger.info(\"getViolationByUuid NotFoundException: There is no violation with id \" + violationUuid + \" in the SLA Repository Database\");                         throw new NotFoundException(\"There is no violation with id \" + violationUuid + \" in the SLA Repository Database\");                 }         logger.debug(\"EndOf getViolationByUuid\");         return violation;     }\n", "docstring": "returns information specific violation given violation database returns empty payload\n", "func_name": "327082"}
{"url": "327083", "code": "private static ValidationResult validateFormatStringVariable(       ExpressionTree formatStringTree,       final Symbol formatStringSymbol,       final List<? extends ExpressionTree> args,       final VisitorState state) {     if (formatStringSymbol.getKind() != ElementKind.LOCAL_VARIABLE) {       return ValidationResult.create(           null,           String.format(               \"Variables used as format strings that are not local variables must be compile time\"                   + \" constants.\\n%s is neither a local variable nor a compile time constant.\",               formatStringTree));     }      // Find the Tree for the block in which the variable is defined. If it is not defined in this     // class (though it may have been in a super class). We require compile time constant values in     // that case.     Symbol owner = formatStringSymbol.owner;     TreePath path = TreePath.getPath(state.getPath(), formatStringTree);     while (path != null && ASTHelpers.getSymbol(path.getLeaf()) != owner) {       path = path.getParentPath();     }      // A local variable must be declared in a parent tree to be accessed. This case should be     // impossible.     if (path == null) {       throw new IllegalStateException(           String.format(               \"Could not find the Tree where local variable %s is declared. \"                   + \"This should be impossible.\",               formatStringTree));     }      // Scan down from the scope where the variable was declared     ValidationResult result =         path.getLeaf()             .accept(                 new TreeScanner<ValidationResult, Void>() {                   @Override                   public ValidationResult visitVariable(VariableTree node, Void unused) {                     if (ASTHelpers.getSymbol(node) == formatStringSymbol) {                       if (node.getInitializer() == null) {                         return ValidationResult.create(                             null,                             String.format(                                 \"Variables used as format strings must be initialized when they are\"                                     + \" declared.\\nInvalid declaration: %s\",                                 node));                       }                       return validateStringFromAssignment(node, node.getInitializer(), args, state);                     }                     return super.visitVariable(node, unused);                   }                    @Override                   public ValidationResult reduce(ValidationResult r1, ValidationResult r2) {                     if (r1 == null && r2 == null) {                       return null;                     }                     return MoreObjects.firstNonNull(r1, r2);                   }                 },                 null);      return result;   }\n", "docstring": "helps\n", "func_name": "327083"}
{"url": "327084", "code": "@SuppressWarnings(\"WeakerAccess\")     public static <K,V> PersistentHashMap<K,V> ofEq(Equator<K> eq, Iterable<Map.Entry<K,V>> es) {         if (es == null) { return empty(eq); }         MutableHashMap<K,V> map = emptyMutable(eq);         for (Map.Entry<K,V> entry : es) {             if (entry != null) {                 map.assoc(entry.getKey(), entry.getValue());             }         }         return map.immutable();     }\n", "docstring": "returns persistent hash map given keys paired values skipping null entries\n", "func_name": "327084"}
{"url": "327085", "code": "@Override     public Set<String> keySet() {         Set<String> keys = new HashSet<>();         keysR(root.getLeft(), -1, keys);         return keys;     }\n", "docstring": "returns copy keys contained trie set\n", "func_name": "327085"}
{"url": "327086", "code": "@Override  public void setFromName(String fromName, java.util.Locale locale) {   _commerceNotificationTemplate.setFromName(fromName, locale);  }\n", "docstring": "sets localized name commerce notification template language\n", "func_name": "327086"}
{"url": "327087", "code": "@Exported     public boolean isLikelyStuck() {         lock.readLock().lock();         try {             if (executable == null) {                 return false;             }         } finally {             lock.readLock().unlock();         }          long elapsed = getElapsedTime();         long d = executableEstimatedDuration;         if (d >= 0) {             // if it's taking 10 times longer than ETA, consider it stuck             return d * 10 < elapsed;         } else {             // if no ETA is available, a build taking longer than a day is considered stuck             return TimeUnit.MILLISECONDS.toHours(elapsed) > 24;         }     }\n", "docstring": "returns current build likely stuck\n", "func_name": "327087"}
{"url": "327088", "code": "public String[] getRegisteredIDs(RESTRequest request,                                      int clientID,                                      String source_objName,                                      String listener_objName) {         //Get the client area         ClientNotificationArea clientArea = getInboxIfAvailable(clientID, null);          List<ServerNotification> registrations = clientArea.getServerRegistrations(request, source_objName);          if (registrations != null) {             List<String> ids = new ArrayList<String>();              //loop registrations to match request             for (ServerNotification registration : registrations) {                 if (registration.listener.getCanonicalName().equals(listener_objName)) {                     //found a matching registration, so add ID to list                     ids.add(registration.filter + \"_\" + registration.handback);                 }             }              return ids.toArray(new String[ids.size()]);         }          return null;     }\n", "docstring": "return array ids strings represent server side notifications given source mbe given listener mbe\n", "func_name": "327088"}
{"url": "327089", "code": "private void npnReceived(ServerHello mesg) throws IOException     {         NextProtoNegoExtension extension = (NextProtoNegoExtension)mesg.extensions.get(ExtensionType.EXT_NEXT_PROTOCOL_NEGOTIATION);         if (extension != null)         {             protocols = extension.getProtocols();             if (NextProtoNego.debug)                 System.err.println(new StringBuilder(\"[C] NPN protocols \").append(protocols).append(\" received from server for \").append(conn != null ? conn : engine));         }         else         {             if (NextProtoNego.debug)                 System.err.println(new StringBuilder(\"[C] NPN protocols not sent by server for \").append(conn != null ? conn : engine));         }     }\n", "docstring": "changes begin\n", "func_name": "327089"}
{"url": "327090", "code": "public void generateMethodTypesScript(Map<String,Integer> typeMap,             Set<MethodTypes> methodTypes) {         String sep = \"\";         StringBuilder vars = new StringBuilder(\"var methods = {\");         for (Map.Entry<String,Integer> entry : typeMap.entrySet()) {             vars.append(sep);             sep = \",\";             vars.append(\"\\\"\")                     .append(entry.getKey())                     .append(\"\\\":\")                     .append(entry.getValue());         }         vars.append(\"};\").append(DocletConstants.NL);         sep = \"\";         vars.append(\"var tabs = {\");         for (MethodTypes entry : methodTypes) {             vars.append(sep);             sep = \",\";             vars.append(entry.value())                     .append(\":\")                     .append(\"[\")                     .append(\"\\\"\")                     .append(entry.tabId())                     .append(\"\\\"\")                     .append(sep)                     .append(\"\\\"\")                     .append(configuration.getText(entry.resourceKey()))                     .append(\"\\\"]\");         }         vars.append(\"};\")                 .append(DocletConstants.NL);         addStyles(HtmlStyle.altColor, vars);         addStyles(HtmlStyle.rowColor, vars);         addStyles(HtmlStyle.tableTab, vars);         addStyles(HtmlStyle.activeTableTab, vars);         script.addContent(new RawHtml(vars.toString()));     }\n", "docstring": "generated javascript variables document\n", "func_name": "327090"}
{"url": "327091", "code": "public void insert(final Parse constituent) {     Span ic = constituent.span;     if (span.contains(ic)) {       //double oprob=c.prob;       int pi=0;       int pn = parts.size();       for (; pi < pn; pi++) {         Parse subPart = (Parse) parts.get(pi);         //System.err.println(\"Parse.insert:con=\"+constituent+\" sp[\"+pi+\"] \"+subPart+\" \"+subPart.getType());         Span sp = subPart.span;         if (sp.getStart() >= ic.getEnd()) {           break;         }         // constituent contains subPart         else if (ic.contains(sp)) {           //System.err.println(\"Parse.insert:con contains subPart\");           parts.remove(pi);           pi--;           constituent.parts.add(subPart);           subPart.setParent(constituent);           //System.err.println(\"Parse.insert: \"+subPart.hashCode()+\" -> \"+subPart.getParent().hashCode());           pn = parts.size();         }         else if (sp.contains(ic)) {           //System.err.println(\"Parse.insert:subPart contains con\");           subPart.insert(constituent);           return;         }       }       //System.err.println(\"Parse.insert:adding con=\"+constituent+\" to \"+this);       parts.add(pi, constituent);       constituent.setParent(this);       //System.err.println(\"Parse.insert: \"+constituent.hashCode()+\" -> \"+constituent.getParent().hashCode());     }     else {       throw (new InternalError(\"Inserting constituent not contained in the sentence!\"));     }   }\n", "docstring": "inserts specified constituent parse based text span method assumes specified constituent inserted parse\n", "func_name": "327091"}
{"url": "327092", "code": "public EClass getAMB() {   if (ambEClass == null) {    ambEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(322);   }   return ambEClass;  }\n", "docstring": "begin user doc end user doc\n", "func_name": "327092"}
{"url": "327093", "code": "private GraphicsDocument createLabelDocument(StringWriter writer, LabelStyleInfo labelStyleInfo)    throws RenderException {    if (TileMetadata.PARAM_SVG_RENDERER.equalsIgnoreCase(renderer)) {    DefaultSvgDocument document = new DefaultSvgDocument(writer, false);    document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);    document.registerWriter(InternalTileImpl.class, new SvgLabelTileWriter(getTransformer(), labelStyleInfo,      geoService, textService));    return document;   } else if (TileMetadata.PARAM_VML_RENDERER.equalsIgnoreCase(renderer)) {    DefaultVmlDocument document = new DefaultVmlDocument(writer);    int coordWidth = tile.getScreenWidth();    int coordHeight = tile.getScreenHeight();    document.registerWriter(InternalFeatureImpl.class, new VmlFeatureWriter(getTransformer(), coordWidth,      coordHeight));    document.registerWriter(InternalTileImpl.class, new VmlLabelTileWriter(coordWidth, coordHeight,      getTransformer(), labelStyleInfo, geoService, textService));    document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);    return document;   } else {    throw new RenderException(ExceptionCode.RENDERER_TYPE_NOT_SUPPORTED, renderer);   }  }\n", "docstring": "create document parses tile label fragment using graphics writer classes\n", "func_name": "327093"}
{"url": "327094", "code": "public static List<String> findAll(CharSequence self, CharSequence regex) {         return findAll(self, Pattern.compile(regex.toString()));     } public static <T> List<T> findAll(CharSequence self, CharSequence regex, @ClosureParams(value=SimpleType.class, options=\"java.lang.String[]\") Closure<T> closure) {         return findAll(self, Pattern.compile(regex.toString()), closure);     } public static List<String> findAll(CharSequence self, Pattern pattern) {         Matcher matcher = pattern.matcher(self.toString());         boolean hasGroup = hasGroup(matcher);         List<String> list = new ArrayList<String>();         for (Iterator iter = iterator(matcher); iter.hasNext();) {             if (hasGroup) {                 list.add((String) ((List) iter.next()).get(0));             } else {                 list.add((String) iter.next());             }         }         return new ArrayList<String>(list);     } public static <T> List<T> findAll(CharSequence self, Pattern pattern, @ClosureParams(value=SimpleType.class, options=\"java.lang.String[]\") Closure<T> closure) {         Matcher matcher = pattern.matcher(self.toString());         return DefaultGroovyMethods.collect(matcher, closure);     }\n", "docstring": "returns possibly empty list occurrences regular expression provided sequence found within sequence example regex match returns empty list pre foo find fish pre regular expression matches returned list regex capture groupings ignored full match returned pre def expected one fish two fish red fish blue fish expected one fish two fish red fish blue fish find fish pre need work capture groups use closure version method use groovy match operators use match finds occurrences regular expression string within sequence matches passed specified closure closure expected full match first parameter capture groups placed subsequent parameters matches closure called empty list returned example regex match returns empty list pre foo find fish match first word return first word pre regular expression matches passed closure capture groups one parameter match pre could would fox find match match pre capture groups first parameter match followed one parameter capture group pre def orig woc ket pocket woc ket pocket orig find ock match first letter first letter match pre returns possibly empty list occurrences regular expression pattern format found within sequence example pattern match returns empty list pre foo find fish pre regular expression matches returned list regex capture groupings ignored full match returned pre def expected one fish two fish red fish blue fish expected one fish two fish red fish blue fish find fish pre finds occurrences compiled regular expression pattern within sequence matches passed specified closure closure expected full match first parameter capture groups placed subsequent parameters matches closure called empty list returned example pattern match returns empty list pre foo find fish match first word return first word pre regular expression matches passed closure capture groups one parameter match pre could would fox find match match pre capture groups first parameter match followed one parameter capture group pre def orig woc ket pocket woc ket pocket orig find ock match first letter first letter match pre\n", "func_name": "327094"}
{"url": "327095", "code": "protected void fill(int fromIndex, int endIndex) {         fromIndex = fromIndex == -1 ? 0 : fromIndex;         endIndex = endIndex == -1 || endIndex > this.timeSeries.length ? this.timeSeries.length : endIndex;          final T val;         if (applyZero()) {             val = zero();         } else {             val = null;         }          // set the values         for (int i = fromIndex; i < endIndex; i++) {             set(i, val);         }     }\n", "docstring": "resets values index end index\n", "func_name": "327095"}
{"url": "327096", "code": "public final String getConfigurationValue(String key)     {         //get value         String value=this.serviceConfiguration.getConfigurationValue(key);                  return value;     }\n", "docstring": "returns value component configuration based provided configuration key value trimmed trimmed configuration value empty string null returned instead\n", "func_name": "327096"}
{"url": "327097", "code": "public boolean setListOption(String fieldName, String[] exportValues, String[] displayValues) {         if (exportValues == null && displayValues == null)             return false;         if (exportValues != null && displayValues != null && exportValues.length != displayValues.length)             throw new IllegalArgumentException(\"The export and the display array must have the same size.\");         int ftype = getFieldType(fieldName);         if (ftype != FIELD_TYPE_COMBO && ftype != FIELD_TYPE_LIST)             return false;         Item fd = (Item)fields.get(fieldName);         String[] sing = null;         if (exportValues == null && displayValues != null)             sing = displayValues;         else if (exportValues != null && displayValues == null)             sing = exportValues;         PdfArray opt = new PdfArray();         if (sing != null) {             for (int k = 0; k < sing.length; ++k)                 opt.add(new PdfString(sing[k], PdfObject.TEXT_UNICODE));         }         else {             for (int k = 0; k < exportValues.length; ++k) {                 PdfArray a = new PdfArray();                 a.add(new PdfString(exportValues[k], PdfObject.TEXT_UNICODE));                 a.add(new PdfString(displayValues[k], PdfObject.TEXT_UNICODE));                 opt.add(a);             }         }         fd.writeToAll( PdfName.OPT, opt, Item.WRITE_VALUE | Item.WRITE_MERGED );         return true;     }\n", "docstring": "sets option list fields type list combo one code export values code code display values code may code null code method set list set value appearance calling code set field code required example pre pdf reader pdf pdf reader input pdf pdfs tamper stp pdfs tamper pdf file output stream output pdf cro fields stp get cro fields set list option combo box string string first second third set field combo box stp close pre\n", "func_name": "327097"}
{"url": "327098", "code": "public boolean detectFirefoxOSPhone() {            //First, let's make sure we're NOT on another major mobile OS.          if (detectIos() || detectAndroid() || detectSailfish()) {              return false;          }            if ((userAgent.indexOf(engineFirefox) != -1) && (userAgent.indexOf(mobile) != -1)) {              return true;          }            return false;      }\n", "docstring": "detects phone probably running firefox\n", "func_name": "327098"}
{"url": "327099", "code": "public boolean addAll(Collection otherCollection,                           Transaction transaction)                     throws ObjectManagerException     {         boolean modified = false;         try {             for (Iterator iterator = otherCollection.iterator();;)                 modified = add((Token) iterator.next(transaction), transaction);         } catch (java.util.NoSuchElementException exception) {             // No FFDC code needed.             // We have run off the end of the other collection.         } // try.            return modified;     }\n", "docstring": "non java doc\n", "func_name": "327099"}
{"url": "327100", "code": "public Cluster withClusterSecurityGroups(ClusterSecurityGroupMembership... clusterSecurityGroups) {         if (this.clusterSecurityGroups == null) {             setClusterSecurityGroups(new com.amazonaws.internal.SdkInternalList<ClusterSecurityGroupMembership>(clusterSecurityGroups.length));         }         for (ClusterSecurityGroupMembership ele : clusterSecurityGroups) {             this.clusterSecurityGroups.add(ele);         }         return this;     }\n", "docstring": "list cluster security group associated cluster security group represented element contains code cluster security group name code code cluster security group status code sub elements cluster security groups used cluster created amazon virtual cloud clusters created use security groups listed security groups parameter note method appends values existing list use link set cluster security groups java util collection link cluster security groups java util collection want existing values\n", "func_name": "327100"}
{"url": "327101", "code": "public WebApp start() {   log = LoggerFactory.getLogger(WebApp.class);    log.debug(\"Initializing Madvoc WebApp\");    //// params & props   for (final Map<String, Object> params : paramsList) {    madvocContainer.defineParams(params);   }   for (final Props props : propsList) {    madvocContainer.defineParams(props);   }   propsList = null;     //// components   registerMadvocComponents();    madvocComponents.forEach(    madvocComponent -> madvocContainer.registerComponent(madvocComponent.type(), madvocComponent.consumer()));   madvocComponents = null;    madvocComponentInstances.forEach(madvocContainer::registerComponentInstance);   madvocComponentInstances = null;    configureDefaults();     //// listeners   madvocContainer.fireEvent(Init.class);    //// component configuration   componentConfigs.accept(madvocContainer);   componentConfigs = null;    initialized();    madvocContainer.fireEvent(Start.class);    if (!madvocRouterConsumers.isEmpty()) {     final MadvocRouter madvocRouter = MadvocRouter.create();     madvocContainer.registerComponentInstance(madvocRouter);     madvocRouterConsumers.accept(madvocRouter);   }   madvocRouterConsumers = null;    started();    madvocContainer.fireEvent(Ready.class);    ready();    return this;  }\n", "docstring": "initializes starts web application\n", "func_name": "327101"}
{"url": "327102", "code": "public void setLogPaths(java.util.Collection<String> logPaths) {         if (logPaths == null) {             this.logPaths = null;             return;         }          this.logPaths = new java.util.ArrayList<String>(logPaths);     }\n", "docstring": "parameter longer used instead specify amazon game lift store log files server process shuts use amazon game lift server api code process ready code specify one directory paths code log parameters code see information href https docs amazon com game lift latest developer guide game lift sdk server api ref html game lift sdk server api ref data pes process server api reference\n", "func_name": "327102"}
{"url": "327103", "code": "public static boolean isCertPathBuilderException(Throwable cause) {         if (cause == null)             return false;         if (cause instanceof java.security.cert.CertPathBuilderException)             return true;         return isCertPathBuilderException(cause.getCause());     }\n", "docstring": "checks cause instance cert path builder exception\n", "func_name": "327103"}
{"url": "327104", "code": "public static <T> void write(final String fileName, Graph<T> g, boolean writeMapping) throws IOException {     File file = new File(fileName.endsWith(\".col\") ? fileName : fileName + \".col\");     Map<Node<T>, Long> node2id = new LinkedHashMap<>();     long i = 1;     for (Node<T> node : g.nodes()) {       node2id.put(node, i++);     }      StringBuilder sb = new StringBuilder(\"p edge \");     Set<Pair<Node<T>, Node<T>>> edges = new LinkedHashSet<>();     Set<Node<T>> doneNodes = new LinkedHashSet<>();     for (Node<T> d : g.nodes()) {       for (Node<T> n : d.neighbours()) {         if (!doneNodes.contains(n)) {           edges.add(new Pair<>(d, n));         }       }       doneNodes.add(d);     }     sb.append(node2id.size()).append(\" \").append(edges.size()).append(System.lineSeparator());      for (Pair<Node<T>, Node<T>> edge : edges) {       sb.append(\"e \").append(node2id.get(edge.first())).append(\" \").append(node2id.get(edge.second())).append(System.lineSeparator());     }      try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))) {       writer.append(sb);       writer.flush();     }     if (writeMapping) {       String mappingFileName = (fileName.endsWith(\".col\") ? fileName.substring(0, fileName.length() - 4) : fileName) + \".map\";       writeMapping(new File(mappingFileName), node2id);     }   }\n", "docstring": "writes given graph internal data structure imacs file\n", "func_name": "327104"}
{"url": "327105", "code": "private void gibbs(int K, float alpha, float beta) {          this.K = K;          this.alpha = alpha;          this.beta = beta;            // init sampler statistics          if (SAMPLE_LAG > 0) {              thetasum = new float[documents.length][K];              phisum = new float[K][V];              numstats = 0;          }            // initial state of the Markov chain:          initialState(K);            System.out.println(\"Sampling \" + ITERATIONS              + \" iterations with burn-in of \" + BURN_IN + \" (B/S=\"              + THIN_INTERVAL + \").\");            for (int i = 0; i < ITERATIONS; i++) {                // for all z_i              for (int m = 0; m < z.length; m++) {                  for (int n = 0; n < z[m].length; n++) {                        // (z_i = z[m][n])                      // sample from p(z_i|z_-i, w)                      int topic = sampleFullConditional(m, n);                      z[m][n] = topic;                  }              }                if ((i < BURN_IN) && (i % THIN_INTERVAL == 0)) {                  System.out.print(\"B\");                  dispcol++;              }              // display progress              if ((i > BURN_IN) && (i % THIN_INTERVAL == 0)) {                  System.out.print(\"S\");                  dispcol++;              }              // get statistics after burn-in              if ((i > BURN_IN) && (SAMPLE_LAG > 0) && (i % SAMPLE_LAG == 0)) {                  updateParams();                  System.out.print(\"|\");                  if (i % THIN_INTERVAL != 0)                      dispcol++;              }              if (dispcol >= 100) {                  System.out.println();                  dispcol = 0;              }          }      }\n", "docstring": "main method select initial state repeat large number times select element update conditional elements appropriate output summary run\n", "func_name": "327105"}
{"url": "327106", "code": "@Override   public String requestDepositAddress(Currency currency, String... arguments) throws IOException {      final BitsoDepositAddress response = getBitsoBitcoinDepositAddress();     return response.getDepositAddress();   }\n", "docstring": "returns currently set deposit address generate address repeated calls return address\n", "func_name": "327106"}
{"url": "327107", "code": "public void marshall(GetCampaignRequest getCampaignRequest, ProtocolMarshaller protocolMarshaller) {          if (getCampaignRequest == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(getCampaignRequest.getApplicationId(), APPLICATIONID_BINDING);             protocolMarshaller.marshall(getCampaignRequest.getCampaignId(), CAMPAIGNID_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327107"}
{"url": "327108", "code": "public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {   UserDetails user = registeredUsers.get(id);    if (user == null) {    throw new UsernameNotFoundException(id);   }    return user;  }\n", "docstring": "implementation\n", "func_name": "327108"}
{"url": "327109", "code": "protected Model getModel(EnforcerRuleHelper helper) throws EnforcerRuleException     {         MavenProject project = getMavenProject(helper);         Model model;         Reader reader = null;         try {             reader = new FileReader(project.getFile());             MavenXpp3Reader xpp3Reader = new MavenXpp3Reader();             model = xpp3Reader.read(reader);         } catch (Exception e) {             throw new EnforcerRuleException(\"Failed to read pom file [\" + project.getFile() + \"]\", e);         } finally {             if (reader != null) {                 try {                     reader.close();                 } catch (Exception ee) {                     throw new EnforcerRuleException(\"Failed to close stream after reading pom file [\"                         + project.getFile() + \"]\", ee);                 }             }         }         return model;     }\n", "docstring": "maven model present project code pom xml non resolved\n", "func_name": "327109"}
{"url": "327110", "code": "protected Object getInstantiatedClass(String query) {         if (query.equals(Constants.ROBOTIUM_SOLO)) {             return solo;         } else if (query.equals(Constants.REMOTE_TEST_CLASS)) {             return testClass;         }         return null;     }\n", "docstring": "get instantiated solo requested\n", "func_name": "327110"}
{"url": "327111", "code": "public static Bbox scale(Bbox bbox, double factor) {   if (factor > 0) {    double scaledWidth = bbox.getWidth() * factor;    double scaledHeight = bbox.getHeight() * factor;    Coordinate center = getCenterPoint(bbox);    return new Bbox(center.getX() - scaledWidth / 2, center.getY() - scaledHeight / 2, scaledWidth,      scaledHeight);   }   throw new IllegalArgumentException(\"Scale factor must always be strictly positive.\");  }\n", "docstring": "return bounding box center position scaled specified factor\n", "func_name": "327111"}
{"url": "327112", "code": "public String convertPTD1XPBASEToString(EDataType eDataType, Object instanceValue) {   return instanceValue == null ? null : instanceValue.toString();  }\n", "docstring": "begin user doc end user doc\n", "func_name": "327112"}
{"url": "327113", "code": "public Any execute(DeviceImpl device, Any in_any) throws DevFailed  {   Util.out4.println(\"SetLoggingLevelCmd::execute(): arrived\");          DevVarLongStringArray dvlsa = null;   try {       dvlsa = extract_DevVarLongStringArray(in_any);   }   catch (DevFailed df) {    Util.out3.println(\"SetLoggingLevelCmd::execute() --> Wrong argument type\");    Except.re_throw_exception(df,                                 \"API_IncompatibleCmdArgumentType\",                                 \"Imcompatible command argument type, expected type is : DevVarLongStringArray\",                                 \"SetLoggingLevelCmd.execute\");   }          Logging.instance().set_logging_level(dvlsa);          return Util.return_empty_any(\"SetLoggingLevel\");  }\n", "docstring": "executes set logging level tango command\n", "func_name": "327113"}
{"url": "327114", "code": "@Nonnull     public BugInstance addSuperclass(PreorderVisitor visitor) {         String className = ClassName.toDottedClassName(visitor.getSuperclassName());         addClass(className);         return this;     }\n", "docstring": "add class annotation superclass class visitor currently visiting\n", "func_name": "327114"}
{"url": "327115", "code": "public static <X> TypeInformation<X> getForClass(Class<X> clazz) {   final ArrayList<Type> typeHierarchy = new ArrayList<>();   typeHierarchy.add(clazz);   return new TypeExtractor().privateGetForClass(clazz, typeHierarchy);  }\n", "docstring": "creates type information given class integer string jos\n", "func_name": "327115"}
{"url": "327116", "code": "public NodeSchema toTVEAndFixColumns(Map<String, Pair<String, Integer>> nameMap) {       final NodeSchema ns = copyAndReplaceWithTVE();    // First convert all non-TVE expressions to TVE in a copy        m_columns.clear();        m_columnsMapHelper.clear();        for(int indx = 0; indx < ns.size(); ++indx) {    // then update columns            final SchemaColumn sc = ns.getColumn(indx);            assert(sc.getExpression() instanceof TupleValueExpression);            if(nameMap.containsKey(sc.getColumnName())) {                final String newColName = nameMap.get(sc.getColumnName()).getFirst();                sc.reset(sc.getTableName(), sc.getTableAlias(), newColName, sc.getColumnAlias());                sc.setDifferentiator(indx);                TupleValueExpression exp = (TupleValueExpression) sc.getExpression();                exp.setColumnIndex(indx);                exp.setColumnName(newColName);                exp.setDifferentiator(indx);            }        }        for(SchemaColumn sc : ns) {            addColumn(sc);        }        return this;     }\n", "docstring": "pre columns map param\n", "func_name": "327116"}
{"url": "327117", "code": "private Set<Artifact> resolveExecutableDependencies( Artifact executablePomArtifact )         throws MojoExecutionException     {          Set<Artifact> executableDependencies = new LinkedHashSet<>();         try         {             ProjectBuildingRequest buildingRequest = getSession().getProjectBuildingRequest();                          MavenProject executableProject =                 this.projectBuilder.build( executablePomArtifact, buildingRequest ).getProject();              for ( ArtifactResult artifactResult : dependencyResolver.resolveDependencies( buildingRequest, executableProject.getModel(), null ) )             {                 executableDependencies.add( artifactResult.getArtifact() );             }         }         catch ( Exception ex )         {             throw new MojoExecutionException( \"Encountered problems resolving dependencies of the executable \"                 + \"in preparation for its execution.\", ex );         }          return executableDependencies;     }\n", "docstring": "resolve executable dependencies specified project\n", "func_name": "327117"}
{"url": "327118", "code": "public static Map<String, String> filterProperties(Properties props, String prefix, boolean removePrefix) {    List<String> excludedProperties = Collections.emptyList();   return filterProperties(props, prefix, removePrefix, excludedProperties);  } public static Map<String, String> filterProperties(Properties props, String prefix, boolean removePrefix,    List<String> excludedProperties) {    Map<String, String> filteredProps = new HashMap<>();   Set<Entry<Object, Object>> entrySet = props.entrySet();   for (Entry<Object, Object> propEntry : entrySet) {    String key = (String) propEntry.getKey();    if (key.startsWith(prefix)) {      String newKey = key;     if (removePrefix) {      newKey = key.substring(prefix.length());     }     if (!excludedProperties.contains(key)) {      filteredProps.put(newKey, (String) propEntry.getValue());     } else {      if (LOGGER.isWarnEnabled()) {       LOGGER.warn(\"The property '\" + key + \"' has been excluded.\");      }     }    }   }    return filteredProps;  }\n", "docstring": "filters properties file using prefix given parameter filters properties file using prefix given parameter\n", "func_name": "327118"}
{"url": "327119", "code": "private static String calculateMessageBodyMd5(String messageBody) {         if (log.isDebugEnabled()) {             log.debug(\"Message body: \" + messageBody);         }         byte[] expectedMd5;         try {             expectedMd5 = Md5Utils.computeMD5Hash(messageBody.getBytes(UTF8));         } catch (Exception e) {             throw new AmazonClientException(\"Unable to calculate the MD5 hash of the message body. \" + e.getMessage(),                     e);         }         String expectedMd5Hex = BinaryUtils.toHex(expectedMd5);         if (log.isDebugEnabled()) {             log.debug(\"Expected  MD5 of message body: \" + expectedMd5Hex);         }         return expectedMd5Hex;     }\n", "docstring": "returns hex encoded hash string given message body\n", "func_name": "327119"}
{"url": "327120", "code": "public void handleSimpleCORS(final HttpServletRequest request,              final HttpServletResponse response, final FilterChain filterChain)              throws IOException, ServletException {          CORSFilter.CORSRequestType requestType =                  checkRequestType(request);          if (!(requestType == CORSFilter.CORSRequestType.SIMPLE          || requestType == CORSFilter.CORSRequestType.ACTUAL)) {              String message =                      \"Expects a HttpServletRequest object of type \"                              + CORSFilter.CORSRequestType.SIMPLE                              + \" or \"                              + CORSFilter.CORSRequestType.ACTUAL;              throw new IllegalArgumentException(message);          }            final String origin =                  request.getHeader(CORSFilter.REQUEST_HEADER_ORIGIN);          final String method = request.getMethod();            // Section 6.1.2          if (!isOriginAllowed(origin)) {              handleInvalidCORS(request, response, filterChain);              return;          }            if (!allowedHttpMethods.contains(method)) {              handleInvalidCORS(request, response, filterChain);              return;          }            // Section 6.1.3          // Add a single Access-Control-Allow-Origin header.          if (anyOriginAllowed && !supportsCredentials) {              // If resource doesn't support credentials and if any origin is              // allowed              // to make CORS request, return header with '*'.              response.addHeader(                      CORSFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN, \"*\");          } else {              // If the resource supports credentials add a single              // Access-Control-Allow-Origin header, with the value of the Origin              // header as value.              response.addHeader(                      CORSFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,                      origin);          }          // Section 6.1.3          // If the resource supports credentials, add a single          // Access-Control-Allow-Credentials header with the case-sensitive          // string \"true\" as value.          if (supportsCredentials) {              response.addHeader(                      CORSFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,                      \"true\");          }            // Section 6.1.4          // If the list of exposed headers is not empty add one or more          // Access-Control-Expose-Headers headers, with as values the header          // field names given in the list of exposed headers.          if ((exposedHeaders != null) && (exposedHeaders.size() > 0)) {              String exposedHeadersString = join(exposedHeaders, \",\");              response.addHeader(                      CORSFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS,                      exposedHeadersString);          }            // Forward the request down the filter chain.          filterChain.doFilter(request, response);      }\n", "docstring": "handles cor request type link cor request type simple\n", "func_name": "327120"}
{"url": "327121", "code": "@SuppressWarnings(\"deprecation\")     @RequestMapping(value = \"/api/backup\", method = RequestMethod.GET)     public     @ResponseBody     String getBackup(Model model, HttpServletResponse response) throws Exception {         response.addHeader(\"Content-Disposition\", \"attachment; filename=backup.json\");         response.setContentType(\"application/json\");          Backup backup = BackupService.getInstance().getBackupData();         ObjectMapper objectMapper = new ObjectMapper();         ObjectWriter writer = objectMapper.writerWithDefaultPrettyPrinter();          return writer.withView(ViewFilters.Default.class).writeValueAsString(backup);     }\n", "docstring": "get backup data\n", "func_name": "327121"}
{"url": "327122", "code": "public int indexOfValue(int value) {         for (int i = 0; i < mSize; i++)             if (mValues[i] == value)                 return i;          return -1;     }\n", "docstring": "returns index\n", "func_name": "327122"}
{"url": "327123", "code": "public float getScalarFloat(StructureMembers.Member m) {     Array data = getArray(m);     return data.getFloat(Index.scalarIndexImmutable);   }\n", "docstring": "get member data type\n", "func_name": "327123"}
{"url": "327124", "code": "protected void warpImageTaylor(GrayF32 before, GrayF32 flowX , GrayF32 flowY , GrayF32 after) {   interp.setBorder(FactoryImageBorder.single(before.getImageType().getImageClass(), BorderType.EXTENDED));   interp.setImage(before);    for( int y = 0; y < before.height; y++ ) {    int pixelIndex = y*before.width;    for (int x = 0; x < before.width; x++, pixelIndex++ ) {     float u = flowX.data[pixelIndex];     float v = flowY.data[pixelIndex];      float wx = x + u;     float wy = y + v;      after.data[pixelIndex] = interp.get(wx, wy);    }   }  }\n", "docstring": "takes flow previous lower resolution layer uses initialize flow current layer adjusts change image scale\n", "func_name": "327124"}
{"url": "327125", "code": "public static NodeList xpathNodeList(Node document, String xpathExpression, Map<String, String> namespaceMapping) throws XPathException,                 MarshallingException     {         return (NodeList) executeXPath(document, xpathExpression, namespaceMapping, XPathConstants.NODESET);     } public static NodeList xpathNodeList(Node document, XPathExpression xpathExpression) throws XPathException, MarshallingException     {         return (NodeList) executeXPath(document, xpathExpression, XPathConstants.NODESET);     }\n", "docstring": "runs given path returns runs given path returns\n", "func_name": "327125"}
{"url": "327126", "code": "protected boolean getBoolean(String key, boolean defaultValue) {          try {              return getConfig().getBoolean(key, defaultValue);          } catch (ConversionException e) {              logConversionException(key, e);          }          return defaultValue;      }\n", "docstring": "gets code given configuration key default value returned key exist code\n", "func_name": "327126"}
{"url": "327127", "code": "@Override  public Connection getConnection() {   try {    String jdbcUrl = props.get(PROPS_JDBC_URL);    String jdbcUser = props.get(PROPS_JDBC_USER);    String jdbcPassword = props.get(PROPS_JDBC_PASSWORD);     Connection connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword);     String schema = getSchema();    if (schema != null) {     connection.setSchema(schema);    }    connection.setAutoCommit(getAutoCommit());    connection.setReadOnly(getReadOnly());    int transactionIsolation = getTransactionIsolation();    if (transactionIsolation > 0) {     connection.setTransactionIsolation(transactionIsolation);    }    return connection;   } catch (SQLException ex) {    ex.printStackTrace();    return null;   }  }\n", "docstring": "inherit doc\n", "func_name": "327127"}
{"url": "327128", "code": "public AnnotationValueImpl addAnnotationValue(String name, Object value) {         AnnotationValueImpl annotationValue = new AnnotationValueImpl(value);          addAnnotationValue(name, annotationValue);          return annotationValue;     } public AnnotationValueImpl addAnnotationValue(String name, String enumClassName, String enumName) {         AnnotationValueImpl annotationValue = new AnnotationValueImpl(enumClassName, enumName);          addAnnotationValue(name, annotationValue);          return annotationValue;     }\n", "docstring": "base value enumeration class name enumeration literal value\n", "func_name": "327128"}
{"url": "327129", "code": "private void doText(Element received, Element source) {         if (log.isDebugEnabled()) {             log.debug(\"Validating node value for element: \" + received.getLocalName());         }          String receivedText = DomUtils.getTextValue(received);         String sourceText = DomUtils.getTextValue(source);          if (receivedText != null) {             Assert.isTrue(sourceText != null,                     ValidationUtils.buildValueMismatchErrorMessage(\"Node value not equal for element '\"                             + received.getLocalName() + \"'\", null, receivedText.trim()));              Assert.isTrue(receivedText.trim().equals(sourceText.trim()),                     ValidationUtils.buildValueMismatchErrorMessage(\"Node value not equal for element '\"                             + received.getLocalName() + \"'\", sourceText.trim(),                             receivedText.trim()));         } else {             Assert.isTrue(sourceText == null,                     ValidationUtils.buildValueMismatchErrorMessage(\"Node value not equal for element '\"                             + received.getLocalName() + \"'\", sourceText.trim(), null));         }          if (log.isDebugEnabled()) {             log.debug(\"Node value '\" + receivedText.trim() + \"': OK\");         }     }\n", "docstring": "handle text node validation\n", "func_name": "327129"}
{"url": "327130", "code": "@SuppressWarnings(\"unchecked\")  public JSONNavi<T> array() {   if (failure)    return this;   if (current == null && readonly)    failure(\"Can not create Array child in readonly\", null);   if (current != null) {    if (isArray())     return this;    if (isObject())     failure(\"can not use Object feature on Array.\", null);    failure(\"Can not use current possition as Object\", null);   } else {    current = mapper.createArray();   }   if (root == null)    root = (T) current;   else    store();   return this;  }\n", "docstring": "set current value json array also skip call arrays create automatically\n", "func_name": "327130"}
{"url": "327131", "code": "public void init(ContextConfig config) {          this.config = config;                    PropertyMap properties = config.getProperties();          String edenSpace = properties.getString(\"EdenSpace\");          if (edenSpace != null) {              this.setEdenMemoryPool(edenSpace);          }                    String survivorSpace = properties.getString(\"SurvivorSpace\");          if (survivorSpace != null) {              this.setSurvivorMemoryPool(survivorSpace);          }                    String tenuredGen = properties.getString(\"TenuredGen\");          if (tenuredGen != null) {              this.setTenuredMemoryPool(tenuredGen);          }                    String permGen = properties.getString(\"PermGen\");          if (permGen != null) {              this.setPermGenMemoryPool(permGen);          }                    String youngCollector = properties.getString(\"YoungCollector\");          if (youngCollector != null) {              this.setYoungCollector(youngCollector);          }                    String tenuredCollector = properties.getString(\"TenuredCollector\");          if (tenuredCollector != null) {              this.setTenuredCollector(tenuredCollector);          }                    // enable contention          getThreadMXBean().setThreadCpuTimeEnabled(true);          getThreadMXBean().setThreadContentionMonitoringEnabled(true);                    // load the settings if possible          loadJMXSettings();      }\n", "docstring": "initialize context instance following configuration parameters supported\n", "func_name": "327131"}
{"url": "327132", "code": "public static ChaincodeCollectionConfiguration fromYamlFile(File configFile) throws InvalidArgumentException, IOException, ChaincodeCollectionConfigurationException {         return fromFile(configFile, false);     }\n", "docstring": "creates chain code collection configuration instance configured details supplied yam file\n", "func_name": "327132"}
{"url": "327133", "code": "public static String contentShowTagAction(         I_CmsXmlContentContainer container,         PageContext context,         String element,         Locale locale,         boolean escape) {          // get the current users OpenCms context         CmsObject cms = CmsFlexController.getCmsObject(context.getRequest());          // get loaded content from content container         I_CmsXmlDocument xmlContent = container.getXmlDocument();          if (CmsStringUtil.isEmpty(element)) {             element = container.getXmlDocumentElement();         } else {             element = CmsXmlUtils.concatXpath(container.getXmlDocumentElement(), element);         }          String content;         if (CmsMacroResolver.isMacro(element)) {             // this is a macro, initialize a macro resolver             String resourcename = CmsJspTagResourceLoad.getResourceName(cms, container);             CmsMacroResolver resolver = CmsMacroResolver.newInstance().setCmsObject(cms).setJspPageContext(                 context).setResourceName(resourcename).setKeepEmptyMacros(true);             // resolve the macro             content = resolver.resolveMacros(element);         } else if (xmlContent == null) {             // no XML content- no output             content = null;         } else {              // determine the locale to display             if (locale == null) {                 // no locale was set, use default from parent tag (usually \"contentload\")                 locale = container.getXmlDocumentLocale();             }             // now get the content element value to display              if (xmlContent.hasValue(element, locale)) {                 try {                     // read the element from the content                     content = xmlContent.getStringValue(cms, element, locale);                 } catch (Exception e) {                     LOG.error(Messages.get().getBundle().key(Messages.LOG_ERR_CONTENT_SHOW_1, element), e);                     content = null;                 }             } else {                 content = null;             }              // make sure that no null String is returned             if (content == null) {                 content = CmsMessages.formatUnknownKey(element);             }             if (escape) {                 // HTML escape the value                 content = CmsEncoder.escapeHtml(content);             }         }          return content;     }\n", "docstring": "internal action method show element xml content document\n", "func_name": "327133"}
{"url": "327134", "code": "@Override  public long writeBooleans(boolean value, long count) {   if (count < 0L) throw new IllegalArgumentException(\"negative count\");   if (position + count > size) throw new EndOfBitStreamException();   int boundary = BitBoundary.BYTE.bitsFrom(position);   int bits = value ? -1 : 0;   if (count <= boundary) return write(bits, (int) count);    long c = write(bits, boundary);   long d = (count - c) >> 3;   fillBytes(bits, d);   d <<= 3;   position += d;   c += d;   c += write(bits, (int) (count - c));    return c;  }\n", "docstring": "bit writer methods\n", "func_name": "327134"}
{"url": "327135", "code": "private static int[] getUnionForAppendInstrumentationLevel(                                                                int[] oldCounters, int[] newCounters) {          int[] merged = new int[newCounters.length + oldCounters.length];         int i, j, k = -1;          // Copying the Old Counters to the merged array         for (i = 0; i < oldCounters.length; i++) {             merged[i] = oldCounters[i];             k++;         }          // Checking for the duplicate elements         boolean flag = false;         for (i = 0; i < newCounters.length; i++, flag = false) {             for (j = 0; (j < oldCounters.length) && (flag == false); j++) {                 if (newCounters[i] == oldCounters[j]) {                     flag = true; // If the array element is a duplicate then                     // breaking the loop.                 }             }             if (flag == false) {                 k++;                 merged[k] = newCounters[i]; // If the array element is not                 // present, then adding it to the                 // Merged array.             }         }          // Forming an array without duplicates.         int[] final_result = new int[k + 1];         for (i = 0; i <= k; i++)             final_result[i] = merged[i];         return final_result;      }\n", "docstring": "implementation\n", "func_name": "327135"}
{"url": "327136", "code": "public CmsFile writeFile(CmsFile resource) throws CmsException {          return getResourceType(resource).writeFile(this, m_securityManager, resource);     }\n", "docstring": "writes resource open cms including content\n", "func_name": "327136"}
{"url": "327137", "code": "public String getLastName() {     if (AuthorInfo_Type.featOkTst && ((AuthorInfo_Type)jcasType).casFeat_lastName == null)       jcasType.jcas.throwFeatMissing(\"lastName\", \"de.julielab.jules.types.AuthorInfo\");     return jcasType.ll_cas.ll_getStringValue(addr, ((AuthorInfo_Type)jcasType).casFeatCode_lastName);}\n", "docstring": "get ter lastname gets last name author\n", "func_name": "327137"}
{"url": "327138", "code": "public static <T> Callable<T> decorate(final Callable<T> callable) {     return new ContextPropagatingCallable<T>(callable);   }\n", "docstring": "decorates callable link context propagating callable making possible access link context within decorated callable\n", "func_name": "327138"}
{"url": "327139", "code": "public static void basicExample001() throws IOException {         final String rawMessage = new StringBuilder(\"BYE sip:bob@127.0.0.1:5060 SIP/2.0\\r\\n\")                 .append(\"Via: SIP/2.0/UDP 127.0.1.1:5061;branch=z9hG4bK-28976-1-7\\r\\n\")                 .append(\"From: alice <sip:alice@127.0.1.1:5061>;tag=28976SIPpTag001\\r\\n\")                 .append(\"To: bob <sip:bob@127.0.0.1:5060>;tag=28972SIPpTag011\\r\\n\")                 .append(\"Call-ID: 1-28976@127.0.1.1\\r\\n\")                 .append(\"CSeq: 2 BYE\\r\\n\")                 .append(\"Contact: sip:alice@127.0.1.1:5061\\r\\n\")                 .append(\"Max-Forwards: 70\\r\\n\")                 .append(\"Subject: Example BYE Message\\r\\n\")                 .append(\"Content-Length: 0\\r\\n\")                 .append(\"\\r\\n\").toString();          // Every object in SIP Lib has a frame-method, which         // will attempt to frame the raw content into that object.         // This is true for SIP messages, SIP header, SIP URIs         // etc etc. All frame-methods are overloaded and accept         // Strings, Buffers and byte-arrays.         final SipMessage msg = SipMessage.frame(rawMessage);          // Once the message has successfully been parsed you         // can access headers etc within the SIP message.         final FromHeader from = msg.getFromHeader();          // All headers that typically are needed for any application, and         // in particular for SIP stacks, have explicit methods and returns         // explicit objects. You may still use the generic getHeader but then         // you will get a generic SIP header back.         final ContactHeader contact = msg.getContactHeader();          // Instead of having to do SipMessage.getMethod().equals(\"BYE\") etc         // the SIP message has many convenience methods for making the code         // more readable, less error prone and less boiler place to write.         if (msg.isBye()) {             System.out.println(\"Yay, this was a BYE message\");         }          if (msg.isRequest()) {             System.out.println(\"Yay, this was SIP request\");         }     }\n", "docstring": "basic example showing parse sip message based string example ones creating raw message typically would read network perhaps file building tool sort\n", "func_name": "327139"}
{"url": "327140", "code": "boolean matchLevels(List<GridRecord> records) {      // first create a new list     List<LevelCoord> levelList = new ArrayList<LevelCoord>(records.size());     for (GridRecord record : records) {       LevelCoord lc = new LevelCoord(record.getLevel1(), record.getLevel2());       if (!levelList.contains(lc)) {         levelList.add(lc);       }     }      Collections.sort(levelList);     if (positive.equals(\"down\")) {       Collections.reverse(levelList);     }      // gotta equal existing list     return levelList.equals(levels);   }\n", "docstring": "match levels\n", "func_name": "327140"}
{"url": "327141", "code": "public Observation addComponent(ObservationComponentComponent t) { //3        if (t == null)          return this;        if (this.component == null)          this.component = new ArrayList<ObservationComponentComponent>();        this.component.add(t);        return this;      }\n", "docstring": "syntactic sugar\n", "func_name": "327141"}
{"url": "327142", "code": "public URI toURI() throws URISyntaxException {          if (m_isStrict && m_errorFree) {             // we have already verified that the URI contains no errors             return new URI(m_uri);         }         // create a new URI from the components         // using this constructor the input will be escaped if required         return new URI(null, m_prefix + (m_query != null ? \"?\" + m_query : \"\"), m_anchor);     }\n", "docstring": "returns uri object created original input string\n", "func_name": "327142"}
{"url": "327143", "code": "public void setTIRID(Integer newTIRID) {   Integer oldTIRID = tirid;   tirid = newTIRID;   if (eNotificationRequired())    eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.INCLUDE_TILE__TIRID, oldTIRID, tirid));  }\n", "docstring": "begin user doc end user doc\n", "func_name": "327143"}
{"url": "327144", "code": "public void prepare(String sql, com.couchbase.lite.internal.database.sqlite.SQLiteStatementInfo outStatementInfo) {         if (sql == null) {             throw new IllegalArgumentException(\"sql must not be null.\");         }          final int cookie = mRecentOperations.beginOperation(\"prepare\", sql, null);         try {             final PreparedStatement statement = acquirePreparedStatement(sql);             try {                 if (outStatementInfo != null) {                     outStatementInfo.numParameters = statement.mNumParameters;                     outStatementInfo.readOnly = statement.mReadOnly;                      final int columnCount = nativeGetColumnCount(                             mConnectionPtr, statement.mStatementPtr);                     if (columnCount == 0) {                         outStatementInfo.columnNames = EMPTY_STRING_ARRAY;                     } else {                         outStatementInfo.columnNames = new String[columnCount];                         for (int i = 0; i < columnCount; i++) {                             outStatementInfo.columnNames[i] = nativeGetColumnName(                                     mConnectionPtr, statement.mStatementPtr, i);                         }                     }                 }             } finally {                 releasePreparedStatement(statement);             }         } catch (RuntimeException ex) {             mRecentOperations.failOperation(cookie, ex);             throw ex;         } finally {             mRecentOperations.endOperation(cookie);         }     }\n", "docstring": "prepares statement execution bind parameters execute method used check syntax errors compilation prior execution statement code statement info argument null provided link com couch base lite internal database lite lite statement info object populated information statement prepared statement makes reference arguments may eventually bound consequently possible cache certain prepared statements select insert update statements statement cache able stored cache later take advantage behavior optimization connection pool provides method acquire connection already given sql statement prepared statement cache ready execution\n", "func_name": "327144"}
{"url": "327145", "code": "public static ScalarOperation<Double> doubleMultiplicationOp() {   return new ScalarOperation<Double>(new ScalarFunction<Double>() {     @Override    public Double scale(Double a, double b) {     return a * b;    }    }, 1d);  }\n", "docstring": "builds scaling operation doubles multiplying operation factor\n", "func_name": "327145"}
{"url": "327146", "code": "@Override     public String getMetaZoneDisplayName(String mzID, NameType type) {         if (mzID == null || mzID.length() == 0) {             return null;         }         return loadMetaZoneNames(mzID).getName(type);     }\n", "docstring": "non java doc\n", "func_name": "327146"}
{"url": "327147", "code": "public static String addTrailingSeparator(String path) {          int l = path.length();         if ((l == 0) || (path.charAt(l - 1) != '/')) {             return path.concat(\"/\");         } else {             return path;         }     }\n", "docstring": "adds trailing separator path required\n", "func_name": "327147"}
{"url": "327148", "code": "public int indexOf(Field field)     {         requireNonNull(field, \"field cannot be null\");         Integer index = fieldIndexes.get(field);         checkArgument(index != null, \"Field %s not found\", field);         return index;     }\n", "docstring": "gets index specified field\n", "func_name": "327148"}
{"url": "327149", "code": "public String[] resolveParamNames(final Method actionClassMethod) {   MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod);    String[] names = new String[methodParameters.length];    for (int i = 0; i < methodParameters.length; i++) {    names[i] = methodParameters[i].getName();   }    return names;  }\n", "docstring": "returns method parameter names\n", "func_name": "327149"}
{"url": "327150", "code": "@Nullable   public static List<LbConfig> getChildPolicyFromXdsConfig(LbConfig xdsConfig) {     Map<String, ?> map = xdsConfig.getRawConfigValue();     List<?> rawChildPolicies = getList(map, XDS_CONFIG_CHILD_POLICY_KEY);     if (rawChildPolicies != null) {       return unwrapLoadBalancingConfigList(checkObjectList(rawChildPolicies));     }     return null;   }\n", "docstring": "extracts list child policies load balancer config\n", "func_name": "327150"}
{"url": "327151", "code": "public HsqlName getSubqueryTableName() {          HsqlName hsqlName = new HsqlName(this, SqlInvariants.SYSTEM_SUBQUERY,                                          false, SchemaObject.TABLE);          hsqlName.schema = SqlInvariants.SYSTEM_SCHEMA_HSQLNAME;          return hsqlName;     }\n", "docstring": "name string different objects serial number\n", "func_name": "327151"}
{"url": "327152", "code": "public Observable<Page<RouteFilterInner>> listNextAsync(final String nextPageLink) {         return listNextWithServiceResponseAsync(nextPageLink)             .map(new Func1<ServiceResponse<Page<RouteFilterInner>>, Page<RouteFilterInner>>() {                 @Override                 public Page<RouteFilterInner> call(ServiceResponse<Page<RouteFilterInner>> response) {                     return response.body();                 }             });     }\n", "docstring": "gets route filters subscription\n", "func_name": "327152"}
{"url": "327153", "code": "public void marshall(BrokerNodeGroupInfo brokerNodeGroupInfo, ProtocolMarshaller protocolMarshaller) {          if (brokerNodeGroupInfo == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(brokerNodeGroupInfo.getBrokerAZDistribution(), BROKERAZDISTRIBUTION_BINDING);             protocolMarshaller.marshall(brokerNodeGroupInfo.getClientSubnets(), CLIENTSUBNETS_BINDING);             protocolMarshaller.marshall(brokerNodeGroupInfo.getInstanceType(), INSTANCETYPE_BINDING);             protocolMarshaller.marshall(brokerNodeGroupInfo.getSecurityGroups(), SECURITYGROUPS_BINDING);             protocolMarshaller.marshall(brokerNodeGroupInfo.getStorageInfo(), STORAGEINFO_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327153"}
{"url": "327154", "code": "public void marshall(RemoveAttributesRequest removeAttributesRequest, ProtocolMarshaller protocolMarshaller) {          if (removeAttributesRequest == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(removeAttributesRequest.getApplicationId(), APPLICATIONID_BINDING);             protocolMarshaller.marshall(removeAttributesRequest.getAttributeType(), ATTRIBUTETYPE_BINDING);             protocolMarshaller.marshall(removeAttributesRequest.getUpdateAttributesRequest(), UPDATEATTRIBUTESREQUEST_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327154"}
{"url": "327155", "code": "public Map<String, T> asMap() {         final Map<String, T> nameToInfoObject = new HashMap<>();         for (final T i : this) {             nameToInfoObject.put(i.getName(), i);         }         return nameToInfoObject;     }\n", "docstring": "get index list map name list item obtained calling code get name list item list item\n", "func_name": "327155"}
{"url": "327156", "code": "public static boolean containsNone(String str, char[] invalidChars) {       if (str == null || invalidChars == null) {           return true;       }       int strSize = str.length();       int validSize = invalidChars.length;       for (int i = 0; i < strSize; i++) {           char ch = str.charAt(i);           for (int j = 0; j < validSize; j++) {               if (invalidChars[j] == ch) {                   return false;               }           }       }       return true;   } public static boolean containsNone(String str, String invalidChars) {       if (str == null || invalidChars == null) {           return true;       }       return containsNone(str, invalidChars.toCharArray());   }\n", "docstring": "checks string contain certain characters checks string contain certain characters\n", "func_name": "327156"}
{"url": "327157", "code": "public SourcedValue getSourced() {         boolean fromCache = true;         int cacheVersion = stampedValue.getStamp();         int latestVersion = parentContainer.getMasterVersion();         String key = parentContainer.getKey();         SourcedValue sourcedValue = null;         if (cacheVersion != latestVersion) {             SourcedValue currentValue = stampedValue.getReference();             SourcedValue newValue = config.getSourcedValue(type, key);              if (stampedValue.compareAndSet(currentValue, newValue, cacheVersion, latestVersion)) {                 sourcedValue = newValue;                 fromCache = false;             }         }         if (fromCache) {             sourcedValue = stampedValue.getReference();         }          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {             if (sourcedValue != null) {                 Tr.debug(tc, \"get: Key={0}, Value={1}\", key, sourcedValue);             } else {                 Tr.debug(tc, \"get: Key={0} not found\", key);             }         }          return sourcedValue;     }\n", "docstring": "fetch latest version property date resolve latest value inline\n", "func_name": "327157"}
{"url": "327158", "code": "private static AWSCredentialsProvider getCredentialsProvider(final Properties configProps, final String configPrefix) {   CredentialProvider credentialProviderType;   if (!configProps.containsKey(configPrefix)) {    if (configProps.containsKey(AWSConfigConstants.accessKeyId(configPrefix))     && configProps.containsKey(AWSConfigConstants.secretKey(configPrefix))) {     // if the credential provider type is not specified, but the Access Key ID and Secret Key are given, it will default to BASIC     credentialProviderType = CredentialProvider.BASIC;    } else {     // if the credential provider type is not specified, it will default to AUTO     credentialProviderType = CredentialProvider.AUTO;    }   } else {    credentialProviderType = CredentialProvider.valueOf(configProps.getProperty(configPrefix));   }    switch (credentialProviderType) {    case ENV_VAR:     return new EnvironmentVariableCredentialsProvider();     case SYS_PROP:     return new SystemPropertiesCredentialsProvider();     case PROFILE:     String profileName = configProps.getProperty(       AWSConfigConstants.profileName(configPrefix), null);     String profileConfigPath = configProps.getProperty(       AWSConfigConstants.profilePath(configPrefix), null);     return (profileConfigPath == null)      ? new ProfileCredentialsProvider(profileName)      : new ProfileCredentialsProvider(profileConfigPath, profileName);     case BASIC:     return new AWSCredentialsProvider() {      @Override      public AWSCredentials getCredentials() {       return new BasicAWSCredentials(        configProps.getProperty(AWSConfigConstants.accessKeyId(configPrefix)),        configProps.getProperty(AWSConfigConstants.secretKey(configPrefix)));      }       @Override      public void refresh() {       // do nothing      }     };     case ASSUME_ROLE:     final AWSSecurityTokenService baseCredentials = AWSSecurityTokenServiceClientBuilder.standard()       .withCredentials(getCredentialsProvider(configProps, AWSConfigConstants.roleCredentialsProvider(configPrefix)))       .withRegion(configProps.getProperty(AWSConfigConstants.AWS_REGION))       .build();     return new STSAssumeRoleSessionCredentialsProvider.Builder(       configProps.getProperty(AWSConfigConstants.roleArn(configPrefix)),       configProps.getProperty(AWSConfigConstants.roleSessionName(configPrefix)))       .withExternalId(configProps.getProperty(AWSConfigConstants.externalId(configPrefix)))       .withStsClient(baseCredentials)       .build();     default:    case AUTO:     return new DefaultAWSCredentialsProviderChain();   }  }\n", "docstring": "provider assume role credentials assuming role determined recursively\n", "func_name": "327158"}
{"url": "327159", "code": "public AwsSecurityFindingFilters withThreatIntelIndicatorLastObservedAt(DateFilter... threatIntelIndicatorLastObservedAt) {         if (this.threatIntelIndicatorLastObservedAt == null) {             setThreatIntelIndicatorLastObservedAt(new java.util.ArrayList<DateFilter>(threatIntelIndicatorLastObservedAt.length));         }         for (DateFilter ele : threatIntelIndicatorLastObservedAt) {             this.threatIntelIndicatorLastObservedAt.add(ele);         }         return this;     }\n", "docstring": "date time last observation threat intel indicator note method appends values existing list use link set threat intel indicator last observed java util collection link threat intel indicator last observed java util collection want existing values\n", "func_name": "327159"}
{"url": "327160", "code": "private boolean dominates(double point1[], double point2[], int noObjectives) {     int i;     int betterInAnyObjective;      betterInAnyObjective = 0;     for (i = 0; i < noObjectives && point1[i] >= point2[i]; i++) {       if (point1[i] > point2[i]) {         betterInAnyObjective = 1;       }     }      return ((i >= noObjectives) && (betterInAnyObjective > 0));   }\n", "docstring": "returns point dominates points respect first objectives objectives\n", "func_name": "327160"}
{"url": "327161", "code": "private boolean preValidateAssignedWriter(final ITopicNode topic) {         if (topic.getAssignedWriter(true) == null) {             log.error(String.format(ProcessorConstants.ERROR_NO_WRITER_MSG, topic.getLineNumber(), topic.getText()));             return false;         }          return true;     }\n", "docstring": "checks make sure assigned writer topic valid\n", "func_name": "327161"}
{"url": "327162", "code": "public static void setCookie(HttpServletResponse response, String name,                                  String value, String domain, int maxAge) {         if (value == null) {             value = \"\";         }         Cookie cookie = new Cookie(name, value);         cookie.setMaxAge(maxAge);         if (domain != null && !\"\".equals(domain)) {             cookie.setDomain(domain);         }         cookie.setPath(\"/\");         response.addCookie(cookie);     }\n", "docstring": "https code google com util java source browse trunk utils cookie utils java\n", "func_name": "327162"}
{"url": "327163", "code": "private void writeObject(ObjectOutputStream oos) throws IOException {         // Write out the non-transient fields         // (revocationDate, reason, authority)         oos.defaultWriteObject();          // Write out the size (number of mappings) of the extensions map         oos.writeInt(extensions.size());          // For each extension in the map, the following are emitted (in order):         // the OID String (Object), the criticality flag (boolean), the length         // of the encoded extension value byte array (int), and the encoded         // extension value byte array. The extensions themselves are emitted         // in no particular order.         for (Map.Entry<String, Extension> entry : extensions.entrySet()) {             Extension ext = entry.getValue();             oos.writeObject(ext.getId());             oos.writeBoolean(ext.isCritical());             byte[] extVal = ext.getValue();             oos.writeInt(extVal.length);             oos.write(extVal);         }     }\n", "docstring": "serialize code certificate revoked exception instance\n", "func_name": "327163"}
