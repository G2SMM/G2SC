{"url": "0", "code": "public void setAttribute(final String name, final Attribute attribute) {         if (name.equals(MAP_KEY)) {             this.mapAttribute = (MapAttribute) attribute;         }     }\n", "docstring": "set map attribute\n", "func_name": "0", "dfs": "name.equals(MAP_KEY) this.mapAttribute = (MapAttribute)attribute; final Attribute attribute final String name"}
{"url": "1", "code": "@Pure  @SuppressWarnings({\"checkstyle:returncount\", \"checkstyle:npathcomplexity\"})  public static Class<?> forName(String name) throws ClassNotFoundException {   if (name == null || \"\".equals(name) || \"null\".equals(name) //$NON-NLS-1$ //$NON-NLS-2$     || \"void\".equals(name)) { //$NON-NLS-1$    return void.class;   }   if (\"boolean\".equals(name)) { //$NON-NLS-1$    return boolean.class;   }   if (\"byte\".equals(name)) { //$NON-NLS-1$    return byte.class;   }   if (\"char\".equals(name)) { //$NON-NLS-1$    return char.class;   }   if (\"double\".equals(name)) { //$NON-NLS-1$    return double.class;   }   if (\"float\".equals(name)) { //$NON-NLS-1$    return float.class;   }   if (\"int\".equals(name)) { //$NON-NLS-1$    return int.class;   }   if (\"long\".equals(name)) { //$NON-NLS-1$    return long.class;   }   if (\"short\".equals(name)) { //$NON-NLS-1$    return short.class;   }   return Class.forName(name);  } @Pure  @Inline(value = \"ReflectionUtil.forName(($1), true, ($2))\", imported = {ReflectionUtil.class})  public static Class<?> forName(String name, ClassLoader loader) throws ClassNotFoundException {   return forName(name, true, loader);  } @Pure  @SuppressWarnings({\"checkstyle:returncount\", \"checkstyle:npathcomplexity\"})  public static Class<?> forName(String name, boolean typeInitialization, ClassLoader loader) throws ClassNotFoundException {   if (name == null || \"\".equals(name) || \"null\".equals(name) //$NON-NLS-1$ //$NON-NLS-2$     || \"void\".equals(name)) { //$NON-NLS-1$    return void.class;   }   if (\"boolean\".equals(name)) { //$NON-NLS-1$    return boolean.class;   }   if (\"byte\".equals(name)) { //$NON-NLS-1$    return byte.class;   }   if (\"char\".equals(name)) { //$NON-NLS-1$    return char.class;   }   if (\"double\".equals(name)) { //$NON-NLS-1$    return double.class;   }   if (\"float\".equals(name)) { //$NON-NLS-1$    return float.class;   }   if (\"int\".equals(name)) { //$NON-NLS-1$    return int.class;   }   if (\"long\".equals(name)) { //$NON-NLS-1$    return long.class;   }   if (\"short\".equals(name)) { //$NON-NLS-1$    return short.class;   }   return Class.forName(name, typeInitialization, loader);  }\n", "docstring": "replies type corresponds specified class name corresponds primitive type low level type replied method extends link class name string auto boxing support replies type corresponds specified class name corresponds primitive type low level type replied method extends link class name string auto boxing support replies type corresponds specified class name corresponds primitive type low level type replied method extends link class name string auto boxing support\n", "func_name": "1", "dfs": "String name"}
{"url": "2", "code": "public boolean isCurrentUserAdmin() throws RepositoryException {      boolean isAdmin = false;         final JackrabbitSession session = (JackrabbitSession) getSession();         final UserManager userManager = session.getUserManager();         Authorizable a = userManager.getAuthorizable(getRequest().getUserPrincipal());         if (a instanceof org.apache.jackrabbit.api.security.user.User) {          isAdmin = ((org.apache.jackrabbit.api.security.user.User)a).isAdmin();         }         return isAdmin;     }\n", "docstring": "returns current request user admin user\n", "func_name": "2", "dfs": "return isAdmin; isAdmin = ((org.apache.jackrabbit.api.security.user.User)a).isAdmin(); a instanceof org.apache.jackrabbit.api.security.user.User Authorizable a = userManager.getAuthorizable(getRequest().getUserPrincipal()); final UserManager userManager = session.getUserManager(); final JackrabbitSession session = (JackrabbitSession)getSession(); boolean isAdmin = false;"}
{"url": "3", "code": "public boolean isAutoIncrement(int column) throws SQLException {     fetchFieldMetaData();     Field field = getField(column);     FieldMetadata metadata = field.getMetadata();     return metadata != null && metadata.autoIncrement;   }\n", "docstring": "inherit doc\n", "func_name": "3", "dfs": "return metadata != null && metadata.autoIncrement; FieldMetadata metadata = field.getMetadata(); Field field = getField(column); fetchFieldMetaData(); int column"}
{"url": "4", "code": "@Override     public Cache getCache(String id) {         Exceptions.checkNotClosed(this.closed.get(), this);          RocksDBCache result;         boolean isNew = false;         synchronized (this.caches) {             result = this.caches.get(id);             if (result == null) {                 result = new RocksDBCache(id, this.config, this::cacheClosed);                 this.caches.put(id, result);                 isNew = true;             }         }          if (isNew) {             result.initialize();         }          return result;     }\n", "docstring": "region cache factory implementation\n", "func_name": "4", "dfs": "String id"}
{"url": "5", "code": "private void copyChildren(int upToChildPosition)     {         // (ensureRoom isn't called here, as we should always be at/behind key additions)         if (copyFromChildPosition >= upToChildPosition)             return;         int len = upToChildPosition - copyFromChildPosition;         if (len > 0)         {             System.arraycopy(copyFrom, getKeyEnd(copyFrom) + copyFromChildPosition, buildChildren, buildChildPosition, len);             copyFromChildPosition = upToChildPosition;             buildChildPosition += len;         }     }\n", "docstring": "copies children copy builder provided index copy exclusive\n", "func_name": "5", "dfs": "int upToChildPosition"}
{"url": "6", "code": "public static CPDefinitionLocalization fetchByCPDefinitionId_LanguageId(   long CPDefinitionId, String languageId, boolean retrieveFromCache) {   return getPersistence()        .fetchByCPDefinitionId_LanguageId(CPDefinitionId,    languageId, retrieveFromCache);  }\n", "docstring": "returns definition localization definition language returns code null code could found optionally using finder cache\n", "func_name": "6", "dfs": "return getPersistence().fetchByCPDefinitionId_LanguageId(CPDefinitionId,languageId,retrieveFromCache); boolean retrieveFromCache String languageId long CPDefinitionId"}
{"url": "7", "code": "@Override   public EEnum getIfcFanTypeEnum() {    if (ifcFanTypeEnumEEnum == null) {     ifcFanTypeEnumEEnum = (EEnum) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI).getEClassifiers()       .get(988);    }    return ifcFanTypeEnumEEnum;   }\n", "docstring": "begin user doc end user doc\n", "func_name": "7", "dfs": "return ifcFanTypeEnumEEnum; ifcFanTypeEnumEEnum = (EEnum)EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI).getEClassifiers().get(988); ifcFanTypeEnumEEnum == null"}
{"url": "8", "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })  public void setValueForKey(Object key, Object value) throws ReflectorException  {      if(object == null) {    logger.error(\"object is null: did you specify it using the 'inspect()' method?\");    throw new ReflectorException(\"object is null: did you specify it using the 'inspect()' method?\");   }    if(object instanceof Map) {    ((Map)object).put(key, value);   } else {    throw new ReflectorException(\"object is not a map\");   }  }\n", "docstring": "object code map code subclass sets element corresponding given key\n", "func_name": "8", "dfs": "object instanceof Map throw new ReflectorException(\\\"object is not a map\\\"); ((Map)object).put(key,value); throw new ReflectorException(\\\"object is null: did you specify it using the 'inspect()' method?\\\"); logger.error(\\\"object is null: did you specify it using the 'inspect()' method?\\\"); object == null Object value Object key"}
{"url": "9", "code": "synchronized void stateChanged(Date date, ChannelState state)     {         final ChannelStateHistoryEntry historyEntry;         final ChannelState oldState = this.state;          if (oldState == state)         {             return;         }          // System.err.println(id + \" state change: \" + oldState + \" => \" + state         // + \" (\" + name + \")\");         historyEntry = new ChannelStateHistoryEntry(date, state);         synchronized (stateHistory)         {             stateHistory.add(historyEntry);         }          this.state = state;         firePropertyChange(PROPERTY_STATE, oldState, state);     }\n", "docstring": "changes state channel\n", "func_name": "9", "dfs": "oldState == state return; final ChannelState oldState = this.state; final ChannelStateHistoryEntry historyEntry; ChannelState state Date date"}
{"url": "10", "code": "public static boolean hasCustomHashCode(Class c)     {         Class origClass = c;         if (_customHash.containsKey(c))         {             return _customHash.get(c);         }          while (!Object.class.equals(c))         {             try             {                 c.getDeclaredMethod(\"hashCode\");                 _customHash.put(origClass, true);                 return true;             }             catch (Exception ignored) { }             c = c.getSuperclass();         }         _customHash.put(origClass, false);         return false;     }\n", "docstring": "determine passed class non object hash code method method caches results concurrent hash map benefit execution performance\n", "func_name": "10", "dfs": "return false; _customHash.put(origClass,false); !.equals(c) c = c.getSuperclass();  Exception ignored return true; _customHash.put(origClass,true); c.getDeclaredMethod(\\\"hashCode\\\"); return _customHash.get(c); _customHash.containsKey(c) Class origClass = c; Class c"}
{"url": "11", "code": "protected void processClassloader(KieContainer kieContainer, DeployedUnitImpl deployedUnit) {      if (((KieContainerImpl) kieContainer).getKieProject() instanceof KieModuleKieProject && kieContainer.getClassLoader() instanceof ProjectClassLoader) {    ClassLoader parentCl = kieContainer.getClassLoader().getParent();    if (parentCl instanceof URLClassLoader) {     URL[] urls = ((URLClassLoader) parentCl).getURLs();     if (urls == null || urls.length == 0) {      return;     }     ConfigurationBuilder builder = new ConfigurationBuilder();     builder.addUrls(urls);     builder.addClassLoader(kieContainer.getClassLoader());      Reflections reflections = new Reflections(builder);      Set<Class<?>> xmlRootElemClasses = reflections.getTypesAnnotatedWith(XmlRootElement.class);     Set<Class<?>> xmlTypeClasses = reflections.getTypesAnnotatedWith(XmlType.class);     Set<Class<?>> remoteableClasses = reflections.getTypesAnnotatedWith(Remotable.class);      Set<Class<?>> allClasses = new HashSet<Class<?>>();     for( Set<Class<?>> classesToAdd : new Set[] { xmlRootElemClasses, xmlTypeClasses, remoteableClasses } ) {        if( classesToAdd != null ) {            allClasses.addAll(classesToAdd);        }     }      for (Class<?> clazz : allClasses) {         filterClassesAddedToDeployedUnit(deployedUnit, clazz);     }    }      }  }\n", "docstring": "processes deployment dependencies made available link container link class loader\n", "func_name": "11", "dfs": "((KieContainerImpl)kieContainer).getKieProject() instanceof KieModuleKieProject && kieContainer.getClassLoader() instanceof ProjectClassLoader parentCl instanceof URLClassLoader filterClassesAddedToDeployedUnit(deployedUnit,clazz); allClasses.addAll(classesToAdd); allClasses Class<?> clazz classesToAdd != null new Set[][]yoshikihigo.tinypdg.pe.ExpressionInfo@7ddcb Set<Class<?>> classesToAdd Set<Class<?>> allClasses = new HashSet<Class<?>>(); Set<Class<?>> remoteableClasses = reflections.getTypesAnnotatedWith(); Set<Class<?>> xmlTypeClasses = reflections.getTypesAnnotatedWith(); Set<Class<?>> xmlRootElemClasses = reflections.getTypesAnnotatedWith(); Reflections reflections = new Reflections(builder); builder.addClassLoader(kieContainer.getClassLoader()); builder.addUrls(urls); ConfigurationBuilder builder = new ConfigurationBuilder(); return; urls == null || urls.length == 0 URL[] urls = ((URLClassLoader)parentCl).getURLs(); ClassLoader parentCl = kieContainer.getClassLoader().getParent(); DeployedUnitImpl deployedUnit KieContainer kieContainer"}
{"url": "12", "code": "public static SkbShellCommand newCommand(String command, SkbShellArgument[] arguments, SkbShellCommandCategory category, String description, String addedHelp){   return new AbstractShellCommand(command, arguments, category, description, addedHelp);  } public static SkbShellCommand newCommand(String command, SkbShellArgument argument, SkbShellCommandCategory category, String description, String addedHelp){   if(argument==null){    return new AbstractShellCommand(command, null, category, description, addedHelp);   }   return SkbShellFactory.newCommand(command, new SkbShellArgument[]{argument}, category, description, addedHelp);  } public static SkbShellCommand newCommand(String command, SkbShellCommandCategory category, String description, String addedHelp){   return new AbstractShellCommand(command, null, category, description, addedHelp);  }\n", "docstring": "returns shell command use factory create one returns shell command use factory create one returns shell command without formal arguments use factory create one\n", "func_name": "12", "dfs": "return new AbstractShellCommand(command,arguments,category,description,addedHelp); String addedHelp String description SkbShellCommandCategory category SkbShellArgument[] arguments String command return SkbShellFactory.newCommand(command,new SkbShellArgument[][]yoshikihigo.tinypdg.pe.ExpressionInfo@fd8e8,category,description,addedHelp); return new AbstractShellCommand(command,null,category,description,addedHelp); argument == null String addedHelp String description SkbShellCommandCategory category SkbShellArgument argument String command return new AbstractShellCommand(command,null,category,description,addedHelp); String addedHelp String description SkbShellCommandCategory category String command"}
{"url": "13", "code": "public void remove(String applicationName, String modelName, Class<?> robotContext, boolean verbose) {         logger.info(\"Remove model named [{}] in application named [{}]\", modelName, applicationName);         String modelPath = mainPath + File.separator + \"java\" + File.separator + robotContext.getCanonicalName().replaceAll(\"\\\\.\", \"/\").replaceAll(\"utils\", \"application/model/\" + applicationName)                 .replaceAll(\"/\", Matcher.quoteReplacement(File.separator)).replaceAll(robotContext.getSimpleName(), modelName.toUpperCase().charAt(0) + modelName.substring(1)) + \".java\";         String modelsPath = mainPath + File.separator + \"java\" + File.separator + robotContext.getCanonicalName().replaceAll(\"\\\\.\", \"/\").replaceAll(\"utils\", \"application/model/\" + applicationName)                 .replaceAll(\"/\", Matcher.quoteReplacement(File.separator)).replaceAll(robotContext.getSimpleName(), modelName.toUpperCase().charAt(0) + modelName.substring(1)) + \"s.java\";         try {             FileUtils.forceDelete(new File(modelPath));             if (verbose) {                 logger.info(\"{} removed with success.\", modelPath);             }         } catch (IOException e) {             logger.debug(\"{} not revove because do not exist.\", modelPath);         }         try {             FileUtils.forceDelete(new File(modelsPath));             if (verbose) {                 logger.info(\"{} removed with success.\", modelsPath);             }         } catch (IOException e) {             logger.debug(\"{} not revove because do not exist.\", modelsPath);         }         String applicationDirectoryPath = modelPath.substring(0, modelPath.lastIndexOf(File.separator));         try {             Collection<File> l = FileUtils.listFiles(new File(applicationDirectoryPath), TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE);             if (l.isEmpty()) {                 if (verbose) {                     logger.info(\"Empty directory, so remove application directory.\");                 }                 FileUtils.deleteDirectory(new File(applicationDirectoryPath));             }         } catch (IOException e) {             logger.debug(\"{} not revove because do not exist.\", applicationDirectoryPath);         }      }\n", "docstring": "remove model target application robot sample add google google user verbose\n", "func_name": "13", "dfs": "l.isEmpty() FileUtils.deleteDirectory(new File(applicationDirectoryPath)); logger.info(\\\"Empty directory, so remove application directory.\\\"); verbose Collection<File> l = FileUtils.listFiles(new File(applicationDirectoryPath),TrueFileFilter.INSTANCE,TrueFileFilter.INSTANCE); String applicationDirectoryPath = modelPath.substring(0,modelPath.lastIndexOf(File.separator)); logger.debug(\\\"{} not revove because do not exist.\\\",modelsPath); IOException e logger.info(\\\"{} removed with success.\\\",modelsPath); verbose FileUtils.forceDelete(new File(modelsPath)); logger.debug(\\\"{} not revove because do not exist.\\\",modelPath); IOException e logger.info(\\\"{} removed with success.\\\",modelPath); verbose FileUtils.forceDelete(new File(modelPath)); String modelsPath = mainPath + File.separator + \\\"java\\\" + File.separator + robotContext.getCanonicalName().replaceAll(\\\"\\.\\\",\\\"/\\\").replaceAll(\\\"utils\\\",\\\"application/model/\\\" + applicationName).replaceAll(\\\"/\\\",Matcher.quoteReplacement(File.separator)).replaceAll(robotContext.getSimpleName(),modelName.toUpperCase().charAt(0) + modelName.substring(1)) + \\\"s.java\\\"; String modelPath = mainPath + File.separator + \\\"java\\\" + File.separator + robotContext.getCanonicalName().replaceAll(\\\"\\.\\\",\\\"/\\\").replaceAll(\\\"utils\\\",\\\"application/model/\\\" + applicationName).replaceAll(\\\"/\\\",Matcher.quoteReplacement(File.separator)).replaceAll(robotContext.getSimpleName(),modelName.toUpperCase().charAt(0) + modelName.substring(1)) + \\\".java\\\"; logger.info(\\\"Remove model named [{}] in application named [{}]\\\",modelName,applicationName); boolean verbose Class<?> robotContext String modelName String applicationName"}
{"url": "14", "code": "@Override  public CreateOrUpdateStatus createOrUpdate(Contents contents)    throws SQLException {   verifyCreate(contents);   return super.createOrUpdate(contents);  }\n", "docstring": "inherit doc\n", "func_name": "14", "dfs": "return super.yoshikihigo.tinypdg.pe.ExpressionInfo@1fefbacontents; verifyCreate(contents); Contents contents"}
{"url": "15", "code": "protected void localRelease() {         super.localRelease();          if(bodyContent != null)             bodyContent.clearBody();          _rows = DIMENSION_DEFAULT_VALUE;         _columns = DIMENSION_DEFAULT_VALUE;         _currentRow = -1;         _currentColumn = -1;         _currentIndex = -1;         _verticalRepeat = false;         _dataList = null;         _currentItem = null;         _valid = true;         _dataSource = null;          if(_tdState != null)             _tdState.clear();         if(_trState != null)             _trState.clear();         if(_tableState != null)             _tableState.clear();          _tableRenderer = null;         _tdRenderer = null;         _trRenderer = null;          _sb = null;         _appender = null;          if(_containerInPageContext) {             DataAccessProviderStack.removeDataAccessProvider(pageContext);             _containerInPageContext = false;         }     }\n", "docstring": "reset fields tag\n", "func_name": "15", "dfs": "_containerInPageContext _containerInPageContext = false; DataAccessProviderStack.removeDataAccessProvider(pageContext); _appender = null; _sb = null; _trRenderer = null; _tdRenderer = null; _tableRenderer = null; _tableState.clear(); _tableState != null _trState.clear(); _trState != null _tdState.clear(); _tdState != null _dataSource = null; _valid = true; _currentItem = null; _dataList = null; _verticalRepeat = false; _currentIndex = -1; _currentColumn = -1; _currentRow = -1; _columns = DIMENSION_DEFAULT_VALUE; _rows = DIMENSION_DEFAULT_VALUE; bodyContent.clearBody(); bodyContent != null super.yoshikihigo.tinypdg.pe.ExpressionInfo@2812bd;"}
{"url": "16", "code": "@Override     public ProxyHandler createProxyHandler() {         final HttpProxyHandler handler;          // For reasons that are not immediately clear, HttpProxyHandler doesn't allow null usernames/passwords if         // specified. If we want them to be null, we have to use the constructor that doesn't take a username/password         // at all.         if (this.username != null && this.password != null) {             handler = new HttpProxyHandler(this.proxyAddress, this.username, this.password);         } else {             handler = new HttpProxyHandler(this.proxyAddress);         }          return handler;     }\n", "docstring": "non java doc\n", "func_name": "16", "dfs": "final HttpProxyHandler handler;"}
{"url": "17", "code": "private void initializeWizardButton() {         Button wizardButton = findViewById(R.id.wizard_button);         wizardButton.setOnClickListener(createWizardButtonListener());     }\n", "docstring": "initializes button allows show\n", "func_name": "17", "dfs": "wizardButton.setOnClickListener(createWizardButtonListener()); Button wizardButton = findViewById(R.id.wizard_button);"}
{"url": "18", "code": "@Nullable   public static PasswordAuthentication requestProxyPasswordAuthentication (@Nullable final String sHostName,                                                                            @Nullable final int nPort,                                                                            @Nullable final String sProtocol)   {     return requestPasswordAuthentication (sHostName,                                           (InetAddress) null,                                           nPort,                                           sProtocol,                                           (String) null,                                           (String) null,                                           (URL) null,                                           RequestorType.PROXY);   }\n", "docstring": "shortcut method requesting proxy password authentication method also used class default authentic\n", "func_name": "18", "dfs": "return requestPasswordAuthentication(sHostName,(InetAddress)null,nPort,sProtocol,(String)null,(String)null,(URL)null,RequestorType.PROXY); @Nullable final String sProtocol @Nullable final int nPort @Nullable final String sHostName"}
{"url": "20", "code": "public void setDateFormatPattern(String dateFormatPattern) {         try {             simpleDateFormat = new SimpleDateFormat(dateFormatPattern);         } catch (Exception e) {             throw new IllegalArgumentException(\"Incorrect date pattern. \" +                     \"Ensure to use formats provided in https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\", e);         }     }\n", "docstring": "property specifying date format see href https docs oracle com java docs api java text simple dateformat html simple dateformat details\n", "func_name": "20", "dfs": "simpleDateFormat = new SimpleDateFormat(dateFormatPattern); String dateFormatPattern"}
{"url": "21", "code": "@Deprecated   public int getClusterSize(String clusterId, String zoneId) {     Cluster cluster = getCluster(clusterId, zoneId);     String message = String.format(\"Cluster %s/%s was not found.\", clusterId, zoneId);     Preconditions.checkNotNull(cluster, message);     return cluster.getServeNodes();   }\n", "docstring": "gets serve node count cluster\n", "func_name": "21", "dfs": "return cluster.getServeNodes(); Preconditions.checkNotNull(cluster,message); String message = String.format(\\\"Cluster %s/%s was not found.\\\",clusterId,zoneId); Cluster cluster = getCluster(clusterId,zoneId); String zoneId String clusterId"}
{"url": "22", "code": "@SideOnly(Side.CLIENT)  public static void sendAction(ActionType action, int inventoryId, int slotNumber, int code)  {   int windowId = Utils.getClientPlayer().openContainer.windowId;   Packet packet = new Packet(action, inventoryId, slotNumber, code, windowId);   MalisisCore.network.sendToServer(packet);  }\n", "docstring": "sends gui action server link malis inventory container\n", "func_name": "22", "dfs": "MalisisCore.network.sendToServer(packet); Packet packet = new Packet(action,inventoryId,slotNumber,code,windowId); int windowId = Utils.getClientPlayer().openContainer.windowId; int code int slotNumber int inventoryId ActionType action"}
{"url": "24", "code": "public ServiceFuture<Void> stopAsync(String resourceGroupName, String accountName, String streamingEndpointName, final ServiceCallback<Void> serviceCallback) {         return ServiceFuture.fromResponse(stopWithServiceResponseAsync(resourceGroupName, accountName, streamingEndpointName), serviceCallback);     }\n", "docstring": "stop streaming endpoint stops existing streaming endpoint\n", "func_name": "24", "dfs": "return ServiceFuture.fromResponse(stopWithServiceResponseAsync(resourceGroupName,accountName,streamingEndpointName),serviceCallback); final ServiceCallback<Void> serviceCallback String streamingEndpointName String accountName String resourceGroupName"}
{"url": "25", "code": "private void initializeArtworkTarget() {         mThumbnailArtworkTarget = new Target() {             @Override             public void onBitmapLoaded(Bitmap bitmap, Picasso.LoadedFrom from) {                 mNotificationView.setImageViewBitmap(                         R.id.simple_sound_cloud_notification_thumbnail, bitmap);                 mNotificationExpandedView.setImageViewBitmap(                         R.id.simple_sound_cloud_notification_thumbnail, bitmap);                 mNotificationManager.notify(NOTIFICATION_ID, buildNotification());             }              @Override             public void onBitmapFailed(Drawable errorDrawable) {              }              @Override             public void onPrepareLoad(Drawable placeHolderDrawable) {             }         };     }\n", "docstring": "initialize target used load artwork asynchronously\n", "func_name": "25", "dfs": "mThumbnailArtworkTarget = new"}
{"url": "26", "code": "@XmlTransient  public Number getFieldValueAsNumber() {   Object obj = this.getFieldValue();   if(obj == null) {    return null;   }    if(obj instanceof Number) {    return (Number)obj;   }    return null;  }\n", "docstring": "gets value code code field code number\n", "func_name": "26", "dfs": "return null; return (Number)obj; obj instanceof Number return null; obj == null Object obj = this.getFieldValue();"}
{"url": "27", "code": "public MethodDoc[] methods(boolean filter) {         Names names = tsym.name.table.names;         List<MethodDocImpl> methods = List.nil();         for (Scope.Entry e = tsym.members().elems; e != null; e = e.sibling) {             if (e.sym != null                 && e.sym.kind == Kinds.MTH                 && e.sym.name != names.init                 && e.sym.name != names.clinit) {                 MethodSymbol s = (MethodSymbol)e.sym;                 if (!filter || env.shouldDocument(s)) {                     methods = methods.prepend(env.getMethodDoc(s));                 }             }         }         //### Cache methods here?         return methods.toArray(new MethodDocImpl[methods.length()]);     }\n", "docstring": "return methods class method overridden annotation type doc mpl\n", "func_name": "27", "dfs": "e != null e.sym != null && e.sym.kind == Kinds.MTH && e.sym.name != names.init && e.sym.name != names.clinit !filter || env.shouldDocument(s) methods = methods.prepend(env.getMethodDoc(s)); MethodSymbol s = (MethodSymbol)e.sym; e = e.sibling Scope.Entry e = tsym.members().elems List<MethodDocImpl> methods = List.nil(); Names names = tsym.name.table.names; boolean filter"}
{"url": "28", "code": "public void sanityCheck() {      if (mcDepth != 0) {       throw new IllegalPdfSyntaxException(\"Unbalanced marked content operators.\" );      }      if (inText) {       throw new IllegalPdfSyntaxException(\"Unbalanced begin/end text operators.\" );      }      if (layerDepth != null && !layerDepth.isEmpty()) {       throw new IllegalPdfSyntaxException(\"Unbalanced layer operators.\" );      }      if (!stateList.isEmpty()) {       throw new IllegalPdfSyntaxException(\"Unbalanced save/restore state operators.\" );      }     }\n", "docstring": "checks dangling state mismatched save restore state begin end text begin end layer begin end marked content sequence found function throw function called automatically reset document page example writing pdf one possible cause calling pdf graphics dispose leave dangling save state calls\n", "func_name": "28", "dfs": "!stateList.isEmpty() throw new IllegalPdfSyntaxException(\\\"Unbalanced save/restore state operators.\\\"); throw new IllegalPdfSyntaxException(\\\"Unbalanced layer operators.\\\"); layerDepth != null && !layerDepth.isEmpty() throw new IllegalPdfSyntaxException(\\\"Unbalanced begin/end text operators.\\\"); inText throw new IllegalPdfSyntaxException(\\\"Unbalanced marked content operators.\\\"); mcDepth != 0"}
{"url": "29", "code": "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {         Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);         return ifcs.toArray(new Class<?>[ifcs.size()]);     }\n", "docstring": "return interfaces given class implements array including ones implemented classes class gets returned sole\n", "func_name": "29", "dfs": "return ifcs.toArray(new Class<?>[][]); Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz,classLoader); ClassLoader classLoader Class<?> clazz"}
{"url": "30", "code": "public static String getMandatoryConfig(Configuration config, String key)       throws IOException {     String value = config.get(key);     if (Strings.isNullOrEmpty(value)) {       throw new IOException(\"Must supply a value for configuration setting: \" + key);     }     return value;   } public static Map<String, String> getMandatoryConfig(       Configuration config, List<String> keys)       throws IOException {     List<String> missingKeys = new ArrayList<>();     Map<String, String> values = new HashMap<>();     for (String key : keys) {       String value = config.get(key);       if (Strings.isNullOrEmpty(value)) {         missingKeys.add(key);       } else {         values.put(key, value);       }     }     if (missingKeys.size() > 0) {       Joiner joiner = Joiner.on(\", \");       String message = \"Must supply value for configuration settings: \" + joiner.join(missingKeys);       throw new IOException(message);     }     return values;   }\n", "docstring": "gets value given key throws value found gets value given keys throws one values found\n", "func_name": "30", "dfs": "return value; throw new IOException(\\\"Must supply a value for configuration setting: \\\" + key); Strings.isNullOrEmpty(value) String value = config.get(key); String key Configuration config return values; throw new IOException(message); String message = \\\"Must supply value for configuration settings: \\\" + joiner.join(missingKeys); Joiner joiner = Joiner.on(\\\", \\\"); missingKeys.size() > 0 values.put(key,value); missingKeys.add(key); Strings.isNullOrEmpty(value) String value = config.get(key); keys String key Map<String,String> values = new HashMap<>(); List<String> missingKeys = new ArrayList<>(); List<String> keys Configuration config"}
{"url": "31", "code": "@Programmatic     public ApplicationRole findByNameCached(final String name) {         return queryResultsCache.execute(new Callable<ApplicationRole>() {             @Override public ApplicationRole call() throws Exception {                 return findByName(name);             }         }, ApplicationRoleRepository.class, \"findByNameCached\", name);     }\n", "docstring": "region find name\n", "func_name": "31", "dfs": "return queryResultsCache.execute(new final String name"}
{"url": "32", "code": "static String toLowerCamelCaseWithNumericSuffixes(String input) {     // Determine where the numeric suffixes begin     int suffixStart = input.length();     while (suffixStart > 0) {       char ch = '\\0';       int numberStart = suffixStart;       while (numberStart > 0) {         ch = input.charAt(numberStart - 1);         if (Character.isDigit(ch)) {           numberStart--;         } else {           break;         }       }       if ((numberStart > 0) && (numberStart < suffixStart) && (ch == '_')) {         suffixStart = numberStart - 1;       } else {         break;       }     }      if (suffixStart == input.length()) {       return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, input);     } else {       return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,           input.substring(0, suffixStart)) + input.substring(suffixStart);     }   }\n", "docstring": "converts given string upper underscore case lower camel case preserving numeric suffixes example name name letter letter start span start span\n", "func_name": "32", "dfs": "String input"}
{"url": "33", "code": "public final void setLineBreak(LineBreak lineBreak) {          // Copy to the field, but convert null to LineBreak.NONE         _lineBreak = lineBreak != null ? lineBreak : LineBreak.NONE;          // Get the corresponding characters in a separate field         _lineBreakChars = _lineBreak._lineBreakChars;          // If there is no line break, there shall be no indentation         if (_lineBreak == LineBreak.NONE) {             _indentation = \"\";         }          // State has changed, check         checkInvariants();     }\n", "docstring": "sets type line use line set code line none code indentation reset empty string\n", "func_name": "33", "dfs": "LineBreak lineBreak"}
{"url": "34", "code": "protected char[] resolvePath(char[] basePath, char[] relPath)         throws URIException {          // REMINDME: paths are never null         String base = (basePath == null) ? \"\" : new String(basePath);          // _path could be empty         if (relPath == null || relPath.length == 0) {             return normalize(basePath);         } else if (relPath[0] == '/') {             return normalize(relPath);         } else {             int at = base.lastIndexOf('/');             if (at != -1) {                 basePath = base.substring(0, at + 1).toCharArray();             }             StringBuffer buff = new StringBuffer(base.length()                  + relPath.length);             buff.append((at != -1) ? base.substring(0, at + 1) : \"/\");             buff.append(relPath);             return normalize(buff.toString().toCharArray());         }     }\n", "docstring": "resolve base relative path\n", "func_name": "34", "dfs": "char[] relPath char[] basePath"}
{"url": "35", "code": "public boolean removeLayout(final Layout itemLayout) {         boolean removed = false;         if (itemLayout != null && mItemLayouts.remove(itemLayout)) {             // remove the layout from all visible pages             List<Widget>  views = getAllViews();             for (Widget view: views) {                 view.removeLayout(itemLayout);             }             removed = true;         }         return removed;     }\n", "docstring": "remove item layout\n", "func_name": "35", "dfs": "final Layout itemLayout"}
{"url": "36", "code": "public Jid getArchiveAddress() {         if (archiveAddress == null) {             EntityFullJid localJid = connection().getUser();             if (localJid == null) {                 return null;             }             return localJid.asBareJid();         }         return archiveAddress;     }\n", "docstring": "xmpp address mam archive note method may return code null mam manager handles local entity archive connection never authenticated least\n", "func_name": "36", "dfs": "return archiveAddress; return localJid.asBareJid(); return null; localJid == null EntityFullJid localJid = connection().getUser(); archiveAddress == null"}
{"url": "37", "code": "@Override  public void eUnset(int featureID) {   switch (featureID) {    case AfplibPackage.TBM__DIRCTION:     setDIRCTION(DIRCTION_EDEFAULT);     return;    case AfplibPackage.TBM__PRECSION:     setPRECSION(PRECSION_EDEFAULT);     return;    case AfplibPackage.TBM__INCRMENT:     setINCRMENT(INCRMENT_EDEFAULT);     return;   }   super.eUnset(featureID);  }\n", "docstring": "begin user doc end user doc\n", "func_name": "37", "dfs": "super.yoshikihigo.tinypdg.pe.ExpressionInfo@b94a85featureID; return; setINCRMENT(INCRMENT_EDEFAULT); return; setPRECSION(PRECSION_EDEFAULT); return; setDIRCTION(DIRCTION_EDEFAULT); featureID int featureID"}
{"url": "38", "code": "@WebMethod(name = \"config.xml\")     public HttpResponse doConfigDotXml(StaplerRequest req) throws IOException {         if (req.getMethod().equals(\"GET\")) {             // read             checkPermission(READ);             return new HttpResponse() {                 public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {                     rsp.setContentType(\"application/xml\");                     View.this.writeXml(rsp.getOutputStream());                 }             };         }         if (req.getMethod().equals(\"POST\")) {             // submission             updateByXml(new StreamSource(req.getReader()));             return HttpResponses.ok();         }          // huh?         return HttpResponses.error(SC_BAD_REQUEST, \"Unexpected request method \" + req.getMethod());     }\n", "docstring": "accepts\n", "func_name": "38", "dfs": "StaplerRequest req"}
{"url": "39", "code": "public static SQLiteDatabase openOrCreateDatabase(File file, CursorFactory factory) {         return openOrCreateDatabase(file.getPath(), factory);     } public static SQLiteDatabase openOrCreateDatabase(String path, CursorFactory factory) {         return openDatabase(path, factory, CREATE_IF_NECESSARY, null);     } public static SQLiteDatabase openOrCreateDatabase(String path, CursorFactory factory,             DatabaseErrorHandler errorHandler) {         return openDatabase(path, factory, CREATE_IF_NECESSARY, errorHandler);     }\n", "docstring": "equivalent open database file get path factory create necessary equivalent open database path factory create necessary equivalent open database path factory create necessary error handler\n", "func_name": "39", "dfs": "return openOrCreateDatabase(file.getPath(),factory); CursorFactory factory File file return openDatabase(path,factory,CREATE_IF_NECESSARY,null); CursorFactory factory String path return openDatabase(path,factory,CREATE_IF_NECESSARY,errorHandler); DatabaseErrorHandler errorHandler CursorFactory factory String path"}
{"url": "40", "code": "public void sendInstances(Stream inputStream,               int numberInstances, boolean isTraining, boolean isTesting) {   int numberSamples = 0;    while (streamSource.hasMoreInstances()     && numberSamples < numberInstances) {        numberSamples++;    numberInstancesSent++;    InstanceContentEvent instanceContentEvent = new InstanceContentEvent(      numberInstancesSent, nextInstance(), isTraining, isTesting);           inputStream.put(instanceContentEvent);   }    InstanceContentEvent instanceContentEvent = new InstanceContentEvent(     numberInstancesSent, null, isTraining, isTesting);   instanceContentEvent.setLast(true);   inputStream.put(instanceContentEvent);  }\n", "docstring": "send instances\n", "func_name": "40", "dfs": "inputStream.put(instanceContentEvent); instanceContentEvent.setLast(true); InstanceContentEvent instanceContentEvent = new InstanceContentEvent(numberInstancesSent,null,isTraining,isTesting); numberInstancesSent++; InstanceContentEvent instanceContentEvent = new InstanceContentEvent(numberInstancesSent,nextInstance(),isTraining,isTesting); inputStream.put(instanceContentEvent); numberSamples++; streamSource.hasMoreInstances() && numberSamples < numberInstances int numberSamples = 0; boolean isTesting boolean isTraining int numberInstances Stream inputStream"}
{"url": "41", "code": "@Override     public DescribeLocationS3Result describeLocationS3(DescribeLocationS3Request request) {         request = beforeClientExecution(request);         return executeDescribeLocationS3(request);     }\n", "docstring": "returns metadata bucket name amazon bucket location\n", "func_name": "41", "dfs": "return executeDescribeLocationS3(request); request = beforeClientExecution(request); DescribeLocationS3Request request"}
{"url": "42", "code": "public static float map(float minStart, float minStop, float maxStart, float maxStop, float value) {         return maxStart + (maxStop - maxStart) * ((value - minStart) / (minStop - minStart));     }\n", "docstring": "max start max stop switched\n", "func_name": "42", "dfs": "return maxStart + (maxStop - maxStart) * ((value - minStart) / (minStop - minStart)); float value float maxStop float maxStart float minStop float minStart"}
{"url": "43", "code": "public static Word2Vec readWord2VecFromText(@NonNull File vectors, @NonNull File hs, @NonNull File h_codes,                                                 @NonNull File h_points, @NonNull VectorsConfiguration configuration) throws IOException {         // first we load syn0         Pair<InMemoryLookupTable, VocabCache> pair = loadTxt(vectors);         InMemoryLookupTable lookupTable = pair.getFirst();         lookupTable.setNegative(configuration.getNegative());         if (configuration.getNegative() > 0)             lookupTable.initNegative();         VocabCache<VocabWord> vocab = (VocabCache<VocabWord>) pair.getSecond();          // now we load syn1         BufferedReader reader = new BufferedReader(new FileReader(hs));         String line = null;         List<INDArray> rows = new ArrayList<>();         while ((line = reader.readLine()) != null) {             String[] split = line.split(\" \");             double array[] = new double[split.length];             for (int i = 0; i < split.length; i++) {                 array[i] = Double.parseDouble(split[i]);             }             rows.add(Nd4j.create(array, new long[]{array.length}, lookupTable.getSyn0().dataType()));         }         reader.close();          // it's possible to have full model without syn1         if (!rows.isEmpty()) {             INDArray syn1 = Nd4j.vstack(rows);             lookupTable.setSyn1(syn1);         }          // now we transform mappings into huffman tree points         reader = new BufferedReader(new FileReader(h_points));         while ((line = reader.readLine()) != null) {             String[] split = line.split(\" \");             VocabWord word = vocab.wordFor(decodeB64(split[0]));             List<Integer> points = new ArrayList<>();             for (int i = 1; i < split.length; i++) {                 points.add(Integer.parseInt(split[i]));             }             word.setPoints(points);         }         reader.close();           // now we transform mappings into huffman tree codes         reader = new BufferedReader(new FileReader(h_codes));         while ((line = reader.readLine()) != null) {             String[] split = line.split(\" \");             VocabWord word = vocab.wordFor(decodeB64(split[0]));             List<Byte> codes = new ArrayList<>();             for (int i = 1; i < split.length; i++) {                 codes.add(Byte.parseByte(split[i]));             }             word.setCodes(codes);             word.setCodeLength((short) codes.size());         }         reader.close();          Word2Vec.Builder builder = new Word2Vec.Builder(configuration).vocabCache(vocab).lookupTable(lookupTable)                 .resetModel(false);          TokenizerFactory factory = getTokenizerFactory(configuration);          if (factory != null)             builder.tokenizerFactory(factory);          Word2Vec w2v = builder.build();          return w2v;     }\n", "docstring": "method allows read paragraph vectors externally originated vectors syn technically method compatible implementation\n", "func_name": "43", "dfs": "@NonNull VectorsConfiguration configuration @NonNull File h_points @NonNull File h_codes @NonNull File hs @NonNull File vectors"}
{"url": "44", "code": "public static String getI18nString(ResourceBundle bundle, String key, String def) {         String s = bundle != null ? bundle.getString(key) : null;         return s != null ? s : def;     }\n", "docstring": "returns internationalized version string available otherwise returns def\n", "func_name": "44", "dfs": "return s != null? s: def; String s = bundle != null? bundle.getString(key): null; String def String key ResourceBundle bundle"}
{"url": "45", "code": "@Override     protected void extractAndTakeAction(String timestamp, JSONArray jsonAllRows, List<String> joinFields, RequestType requestType, ActionType action) {         Map<Object,List<Object>> newBaseAllRows = new LinkedHashMap<>();         JSONObject eachRow = null;         for (int i = 0; i < jsonAllRows.length(); i++) {             JSONObject jsonItem = jsonAllRows.getJSONObject(i);             eachRow = dataItemAt(jsonItem, requestType, action);             String actualTimestamp = timestamp;             if (timestamp == null) {                 if (requestType == RequestType.SELECT) {                     actualTimestamp = eachRow.optString(\"timestamp\");                     // Because the timestamp is within each row remove them once you extract it.                     eachRow.remove(\"timestamp\");                 } else {                     actualTimestamp = jsonItem.optString(\"timestamp\");                 }             }             Tuple2<Object, List<Object>> row = mapPkToRow(actualTimestamp, eachRow, joinFields);             Object pk = row._1();// Primary key.             List<Object> rowVal = row._2();             if (action == ActionType.FIRST_CUT) {// First cut (no join).                 if (pk != null) {//TODO: Only non-nulls will go through. Address this later.                     baseAllRows.put(pk, rowVal);                 }             } else {// Some Join action.                 if (pk != null) {//TODO: Only non-nulls will go through. Address this later.                     if (baseAllRows.containsKey(pk)) {// If any item in set B exist in set A.                         rowVal.removeAll(splitCompositeKeys(pk.toString()));// Remove key(which is already available in baseAllRows)                         if (!joinFields.contains(\"timestamp\")) {// If join field is not \"timestamp\" then remove timestamp data value from to be joined set.                             rowVal.remove(0);// Because the 1st field is always timestamp.(See extractKeyAndRow() method)                         }                         if (action == ActionType.JOIN || action == ActionType.RIGHT_JOIN) {                             newBaseAllRows.put(pk, baseAllRows.remove(pk));// Remove from existing map and add to new map.                             newBaseAllRows.get(pk).addAll(rowVal);// Update the new map with partial to be joined data.                         } else if (action == ActionType.LEFT_JOIN) {// Left join                             baseAllRows.get(pk).addAll(rowVal);                         }                     } else {// For right join we still need to continue with each row in set B.                         if (action == ActionType.RIGHT_JOIN) {// Right join                             newBaseAllRows.put(pk, rowVal);                         }                     }                 }             }             if (i == 0) {// Fill headers (only once)                 fillHeaders(eachRow, joinFields, action);             }         }         if (!newBaseAllRows.isEmpty()) {// For join and right join.             baseAllRows = newBaseAllRows;         }     }\n", "docstring": "generate tuple list field names map join fei row list json array\n", "func_name": "45", "dfs": "ActionType action RequestType requestType List<String> joinFields JSONArray jsonAllRows String timestamp"}
{"url": "46", "code": "public void setTrailList(java.util.Collection<Trail> trailList) {         if (trailList == null) {             this.trailList = null;             return;         }          this.trailList = new com.amazonaws.internal.SdkInternalList<Trail>(trailList);     }\n", "docstring": "list trail objects\n", "func_name": "46", "dfs": "this.trailList = new com.amazonaws.internal.SdkInternalList<Trail>(trailList); return; this.trailList = null; trailList == null java.util.Collection<Trail> trailList"}
{"url": "47", "code": "public void waitForCompletion(final long timeout, final TimeUnit unit)     throws InterruptedException, ExecutionException, TimeoutException {   doneLatch.await(timeout, unit);  }\n", "docstring": "wait completion operation timed version\n", "func_name": "47", "dfs": "doneLatch.await(timeout,unit); final TimeUnit unit final long timeout"}
{"url": "48", "code": "public static JsonSimple parse(String input) throws IOException {         ByteArrayInputStream bytes = new ByteArrayInputStream(                 input.getBytes(\"UTF-8\"));         return parse(bytes);     } public static JsonSimple parse(InputStream input) throws IOException {         JsonSimple inputData = new JsonSimple(input);         JsonSimple responseData = new JsonSimple();          // Go through every top level node         JsonObject object = inputData.getJsonObject();         for (Object key : object.keySet()) {             // Ignoring some non-form related nodes             String strKey = validString(key);             if (!EXCLUDED_FIELDS.contains(strKey)) {                 // And parse them into the repsonse                 String data = validString(object.get(key));                 parseField(responseData, strKey, data);             }         }         return responseData;     }\n", "docstring": "wrapper stream based parsing method accepts string internally create stream accept parse raw json data input stream field name string literals broken meaningful json data structures\n", "func_name": "48", "dfs": "return parse(bytes); ByteArrayInputStream bytes = new ByteArrayInputStream(input.getBytes(\\\"UTF-8\\\")); String input JsonSimple responseData = new JsonSimple(); JsonSimple inputData = new JsonSimple(input); InputStream input"}
{"url": "49", "code": "public void marshall(DeleteVaultNotificationsRequest deleteVaultNotificationsRequest, ProtocolMarshaller protocolMarshaller) {          if (deleteVaultNotificationsRequest == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(deleteVaultNotificationsRequest.getAccountId(), ACCOUNTID_BINDING);             protocolMarshaller.marshall(deleteVaultNotificationsRequest.getVaultName(), VAULTNAME_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "49", "dfs": "protocolMarshaller.marshall(deleteVaultNotificationsRequest.getVaultName(),VAULTNAME_BINDING); protocolMarshaller.marshall(deleteVaultNotificationsRequest.getAccountId(),ACCOUNTID_BINDING); throw new SdkClientException(\\\"Invalid argument passed to marshall(...)\\\"); deleteVaultNotificationsRequest == null ProtocolMarshaller protocolMarshaller DeleteVaultNotificationsRequest deleteVaultNotificationsRequest"}
{"url": "50", "code": "private static ServiceProviderFinder _getServiceProviderFinderFromInitParam(ExternalContext context)     {         String initializerClassName = context.getInitParameter(SERVICE_PROVIDER_FINDER_PARAM);         if (initializerClassName != null)         {             try             {                 // get Class object                 Class<?> clazz = ClassUtils.classForName(initializerClassName);                 if (!ServiceProviderFinder.class.isAssignableFrom(clazz))                 {                     throw new FacesException(\"Class \" + clazz                              + \" does not implement ServiceProviderFinder\");                 }                                  // create instance and return it                 return (ServiceProviderFinder) ClassUtils.newInstance(clazz);             }             catch (ClassNotFoundException cnfe)             {                 throw new FacesException(\"Could not find class of specified ServiceProviderFinder\", cnfe);             }         }         return null;     }\n", "docstring": "gets service provider finder web xml config param\n", "func_name": "50", "dfs": "ExternalContext context"}
{"url": "52", "code": "public static <T> void concat(T[] sourceFirst, T[] sourceSecond, T[] dest) {         System.arraycopy(sourceFirst, 0, dest, 0, sourceFirst.length);         System.arraycopy(sourceSecond, 0, dest, sourceFirst.length, sourceSecond.length);     }\n", "docstring": "copies order code source first code source second code\n", "func_name": "52", "dfs": "System.arraycopy(sourceSecond,0,dest,sourceFirst.length,sourceSecond.length); System.arraycopy(sourceFirst,0,dest,0,sourceFirst.length); T[] dest T[] sourceSecond T[] sourceFirst"}
{"url": "53", "code": "protected void onRootChoiceUpdate(final AjaxRequestTarget target) {   childTextField.setModelObject(getModelObject().getSelectedChildOption());   target.add(DropdownAutocompleteTextFieldPanel.this.childTextField);  }\n", "docstring": "callback method overwritten provide additional action root choice updated\n", "func_name": "53", "dfs": "target.add(this.childTextField); childTextField.setModelObject(getModelObject().getSelectedChildOption()); final AjaxRequestTarget target"}
{"url": "55", "code": "public FessMessages addErrorsCrudInvalidMode(String property, String arg0, String arg1) {         assertPropertyNotNull(property);         add(property, new UserMessage(ERRORS_crud_invalid_mode, arg0, arg1));         return this;     }\n", "docstring": "add created action message key errors crud invalid mode parameters pre message invalid mode expected value pre\n", "func_name": "55", "dfs": "return this; add(property,new UserMessage(ERRORS_crud_invalid_mode,arg0,arg1)); assertPropertyNotNull(property); String arg1 String arg0 String property"}
{"url": "56", "code": "public IterativeState<T,R> setState(IterativeState<T,R> new_state)      {          IterativeState<T,R> old_state = this.state;          this.state = new_state;          return old_state;      }\n", "docstring": "sets supplied state iterative callback\n", "func_name": "56", "dfs": "return old_state; this.state = new_state; IterativeState<T,R> old_state = this.state; IterativeState<T,R> new_state"}
{"url": "57", "code": "protected final List<MvcRequestMatcher> createMvcMatchers(HttpMethod method,    String... mvcPatterns) {   Assert.state(!this.anyRequestConfigured, \"Can't configure mvcMatchers after anyRequest\");   ObjectPostProcessor<Object> opp = this.context.getBean(ObjectPostProcessor.class);   if (!this.context.containsBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME)) {    throw new NoSuchBeanDefinitionException(\"A Bean named \" + HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME +\" of type \" + HandlerMappingIntrospector.class.getName()     + \" is required to use MvcRequestMatcher. Please ensure Spring Security & Spring MVC are configured in a shared ApplicationContext.\");   }   HandlerMappingIntrospector introspector = this.context.getBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME,    HandlerMappingIntrospector.class);   List<MvcRequestMatcher> matchers = new ArrayList<>(     mvcPatterns.length);   for (String mvcPattern : mvcPatterns) {    MvcRequestMatcher matcher = new MvcRequestMatcher(introspector, mvcPattern);    opp.postProcess(matcher);     if (method != null) {     matcher.setMethod(method);    }    matchers.add(matcher);   }   return matchers;  }\n", "docstring": "creates link request match instances method patterns passed\n", "func_name": "57", "dfs": "return matchers; matchers.add(matcher); matcher.setMethod(method); method != null opp.postProcess(matcher); MvcRequestMatcher matcher = new MvcRequestMatcher(introspector,mvcPattern); mvcPatterns String mvcPattern List<MvcRequestMatcher> matchers = new ArrayList<>(mvcPatterns.length); HandlerMappingIntrospector introspector = this.context.getBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME,); throw new NoSuchBeanDefinitionException(\\\"A Bean named \\\" + HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME + \\\" of type \\\" + .getName() + \\\" is required to use MvcRequestMatcher. Please ensure Spring Security & Spring MVC are configured in a shared ApplicationContext.\\\"); !this.context.containsBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME) ObjectPostProcessor<Object> opp = this.context.getBean(); Assert.state(!this.anyRequestConfigured,\\\"Can't configure mvcMatchers after anyRequest\\\"); String mvcPatterns HttpMethod method"}
{"url": "58", "code": "@Override     public int replace(Replaceable text,                        int start,                        int limit,                        int[] cursor) {          // First delegate to subordinate replacer         int len = replacer.replace(text, start, limit, cursor);         limit = start + len;          // Now transliterate         limit = translit.transliterate(text, start, limit);          return limit - start;     }\n", "docstring": "unicode replace api\n", "func_name": "58", "dfs": "int[] cursor int limit int start Replaceable text"}
{"url": "59", "code": "public static Document restoreDots(Document document) {         return modifyKeys(document, key -> key.replace(TO_REPLACE_DOTS, \".\"), TO_REPLACE_DOTS);     }\n", "docstring": "restore dots keys\n", "func_name": "59", "dfs": "Document document"}
{"url": "60", "code": "public static base_response delete(nitro_service client, nssimpleacl resource) throws Exception {   nssimpleacl deleteresource = new nssimpleacl();   deleteresource.aclname = resource.aclname;   return deleteresource.delete_resource(client);  }\n", "docstring": "use api delete simple\n", "func_name": "60", "dfs": "return deleteresource.delete_resource(client); deleteresource.aclname = resource.aclname; nssimpleacl deleteresource = new nssimpleacl(); nssimpleacl resource nitro_service client"}
{"url": "61", "code": "protected String resolveExpressionBlock(String expression, EvaluationContext context, boolean urlEncode, EvaluationStrategy strategy, List<String> errors) {         try {             String body = expression.substring(1); // strip prefix              // if expression doesn't start with ( then check it's an allowed top level context reference             if (!body.startsWith(\"(\")) {                 String topLevel = StringUtils.split(body, '.')[0].toLowerCase();                 if (!m_allowedTopLevels.contains(topLevel)) {                     return expression;                 }             }              Object evaluated = evaluateExpression(body, context, strategy);              String rendered = Conversions.toString(evaluated, context); // render result as string             return urlEncode ? ExpressionUtils.urlquote(rendered) : rendered;         }         catch (EvaluationError ex) {             logger.debug(\"Unable to evaluate expression\", ex);             errors.add(ex.getMessage());              return expression; // if we can't evaluate expression, include it as is in the output         }     }\n", "docstring": "resolves expression block found template\n", "func_name": "61", "dfs": "List<String> errors EvaluationStrategy strategy boolean urlEncode EvaluationContext context String expression"}
{"url": "62", "code": "private void removeFolder(File dir) throws IOException     {       if (PrivilegedFileHelper.isDirectory(dir))       {            for (File subFile : PrivilegedFileHelper.listFiles(dir))          {             removeFolder(subFile);          }                    if (!PrivilegedFileHelper.delete(dir))          {             throw new IOException(\"Index folder was not deleted : \" + PrivilegedFileHelper.getCanonicalPath(dir));          }       }       else       {          if (!PrivilegedFileHelper.delete(dir))          {             throw new IOException(\"Index file was not deleted : \" + PrivilegedFileHelper.getCanonicalPath(dir));          }       }    }\n", "docstring": "remove folder\n", "func_name": "62", "dfs": "PrivilegedFileHelper.isDirectory(dir) !PrivilegedFileHelper.delete(dir) throw new IOException(\\\"Index file was not deleted : \\\" + PrivilegedFileHelper.getCanonicalPath(dir)); !PrivilegedFileHelper.delete(dir) throw new IOException(\\\"Index folder was not deleted : \\\" + PrivilegedFileHelper.getCanonicalPath(dir)); removeFolder(subFile); PrivilegedFileHelper.listFiles(dir) File subFile File dir"}
{"url": "63", "code": "public List<AccessControlEntry> getPermissionEntries()    {       List<AccessControlEntry> list = new ArrayList<AccessControlEntry>();       for (int i = 0, length = accessList.size(); i < length; i++)       {          AccessControlEntry entry = accessList.get(i);          list.add(new AccessControlEntry(entry.getIdentity(), entry.getPermission()));       }       return list;    }\n", "docstring": "gives permission entries\n", "func_name": "63", "dfs": "return list; i < length list.add(new AccessControlEntry(entry.getIdentity(),entry.getPermission())); AccessControlEntry entry = accessList.get(i); i++ int i = 0length = accessList.size() List<AccessControlEntry> list = new ArrayList<AccessControlEntry>();"}
{"url": "64", "code": "public static String unquote(String string) {     if (string.startsWith(\"'\") && string.endsWith(\"'\")) {       string = string.substring(1, string.length() - 1);              if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) ||     (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) ||     (string.indexOf(\"\\\\\\\\\") != -1) ||     (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1) ||    (string.indexOf(\"\\\\u001E\") != -1)) {  string = unbackQuoteChars(string);       }     }      return string;   }\n", "docstring": "unquotes previously quoted string necessary removes single quotes around inverse quote string\n", "func_name": "64", "dfs": "return string; string = unbackQuoteChars(string); (string.indexOf(\\\"\\n\\\") != -1) || (string.indexOf(\\\"\\r\\\") != -1) || (string.indexOf(\\\"\\'\\\") != -1) || (string.indexOf(\\\"\\\\\\\"\\\") != -1) || (string.indexOf(\\\"\\\\\\\\\") != -1) || (string.indexOf(\\\"\\t\\\") != -1) || (string.indexOf(\\\"\\%\\\") != -1) || (string.indexOf(\\\"\\u001E\\\") != -1) string = string.substring(1,string.length() - 1); string.startsWith(\\\"'\\\") && string.endsWith(\\\"'\\\") String string"}
{"url": "65", "code": "public FessMessages addSuccessFailureUrlDeleteAll(String property) {         assertPropertyNotNull(property);         add(property, new UserMessage(SUCCESS_failure_url_delete_all));         return this;     }\n", "docstring": "add created action message key success failure url delete parameters pre message deleted failure urls pre\n", "func_name": "65", "dfs": "return this; add(property,new UserMessage(SUCCESS_failure_url_delete_all)); assertPropertyNotNull(property); String property"}
{"url": "66", "code": "public void setManagedByVDC(ClusterComputeResource cluster, boolean status) throws InvalidState, NotFound, RuntimeFault, RemoteException {         getVimService().setManagedByVDC(getMOR(), cluster.getMOR(), status);     }\n", "docstring": "sets whether cluster managed virtual datacenter setting prevent users disabling cluster\n", "func_name": "66", "dfs": "getVimService().setManagedByVDC(getMOR(),cluster.getMOR(),status); boolean status ClusterComputeResource cluster"}
{"url": "67", "code": "public void setOutgoingLinks(FSArray v) {     if (Descriptor_Type.featOkTst && ((Descriptor_Type)jcasType).casFeat_outgoingLinks == null)       jcasType.jcas.throwFeatMissing(\"outgoingLinks\", \"de.julielab.jules.types.wikipedia.Descriptor\");     jcasType.ll_cas.ll_setRefValue(addr, ((Descriptor_Type)jcasType).casFeatCode_outgoingLinks, jcasType.ll_cas.ll_getFSRef(v));} public void setOutgoingLinks(int i, Title v) {      if (Descriptor_Type.featOkTst && ((Descriptor_Type)jcasType).casFeat_outgoingLinks == null)       jcasType.jcas.throwFeatMissing(\"outgoingLinks\", \"de.julielab.jules.types.wikipedia.Descriptor\");     jcasType.jcas.checkArrayBounds(jcasType.ll_cas.ll_getRefValue(addr, ((Descriptor_Type)jcasType).casFeatCode_outgoingLinks), i);     jcasType.ll_cas.ll_setRefArrayValue(jcasType.ll_cas.ll_getRefValue(addr, ((Descriptor_Type)jcasType).casFeatCode_outgoingLinks), i, jcasType.ll_cas.ll_getFSRef(v));}\n", "docstring": "setter outgoing links sets list outgoing links pointing wikipedia pages starting wikipedia page indexed setter outgoing links sets indexed value list outgoing links pointing wikipedia pages starting wikipedia page\n", "func_name": "67", "dfs": "jcasType.ll_cas.ll_setRefValue(addr,((Descriptor_Type)jcasType).casFeatCode_outgoingLinks,jcasType.ll_cas.ll_getFSRef(v)); jcasType.jcas.throwFeatMissing(\\\"outgoingLinks\\\",\\\"de.julielab.jules.types.wikipedia.Descriptor\\\"); Descriptor_Type.featOkTst && ((Descriptor_Type)jcasType).casFeat_outgoingLinks == null FSArray v jcasType.ll_cas.ll_setRefArrayValue(jcasType.ll_cas.ll_getRefValue(addr,((Descriptor_Type)jcasType).casFeatCode_outgoingLinks),i,jcasType.ll_cas.ll_getFSRef(v)); jcasType.jcas.checkArrayBounds(jcasType.ll_cas.ll_getRefValue(addr,((Descriptor_Type)jcasType).casFeatCode_outgoingLinks),i); jcasType.jcas.throwFeatMissing(\\\"outgoingLinks\\\",\\\"de.julielab.jules.types.wikipedia.Descriptor\\\"); Descriptor_Type.featOkTst && ((Descriptor_Type)jcasType).casFeat_outgoingLinks == null Title v int i"}
{"url": "68", "code": "public TypeSignature getTypeDescriptor() {         if (typeDescriptorStr == null) {             return null;         }         if (typeDescriptor == null) {             try {                 typeDescriptor = TypeSignature.parse(typeDescriptorStr, declaringClassName);                 typeDescriptor.setScanResult(scanResult);             } catch (final ParseException e) {                 throw new IllegalArgumentException(e);             }         }         return typeDescriptor;     }\n", "docstring": "returns parsed type descriptor field available\n", "func_name": "68", "dfs": "return typeDescriptor; throw new IllegalArgumentException(e); final ParseException e typeDescriptor.setScanResult(scanResult); typeDescriptor = TypeSignature.parse(typeDescriptorStr,declaringClassName); typeDescriptor == null return null; typeDescriptorStr == null"}
{"url": "69", "code": "private int addExtendedName(int maxlength)     {         for (int i = TYPE_NAMES_.length - 1; i >= 0; i --) {             // for each category, count the length of the category name             // plus 9 =             // 2 for <>             // 1 for -             // 6 for most hex digits per code point             int length = 9 + add(m_nameSet_, TYPE_NAMES_[i]);             if (length > maxlength) {                 maxlength = length;             }         }         return maxlength;     }\n", "docstring": "adds extended names name set equivalent part calc ext name sets lengths\n", "func_name": "69", "dfs": "int maxlength"}
{"url": "70", "code": "protected static double weightedDistance(NumberVector v1, NumberVector v2, long[] weightVector) {     double sqrDist = 0;     for(int i = BitsUtil.nextSetBit(weightVector, 0); i >= 0; i = BitsUtil.nextSetBit(weightVector, i + 1)) {       double manhattanI = v1.doubleValue(i) - v2.doubleValue(i);       sqrDist += manhattanI * manhattanI;     }     return FastMath.sqrt(sqrDist);   }\n", "docstring": "computes weighted distance two specified vectors according given preference vector\n", "func_name": "70", "dfs": "return FastMath.sqrt(sqrDist); sqrDist += manhattanI * manhattanI; double manhattanI = v1.doubleValue(i) - v2.doubleValue(i); i = BitsUtil.nextSetBit(weightVector,i + 1) i >= 0 int i = BitsUtil.nextSetBit(weightVector,0) double sqrDist = 0; long[] weightVector NumberVector v2 NumberVector v1"}
{"url": "71", "code": "private void digestInteger(MessageDigest digest, int value) {         byte[] valueBytes = new byte[4];         Util.numberToBytes(value, valueBytes, 0, 4);         digest.update(valueBytes);     }\n", "docstring": "helper method add java integer value message digest\n", "func_name": "71", "dfs": "digest.update(valueBytes); Util.numberToBytes(value,valueBytes,0,4); byte[] valueBytes = new byte[][]; int value MessageDigest digest"}
{"url": "72", "code": "public static TypeAnnotationPosition         methodInvocationTypeArg(final List<TypePathEntry> location,                                 final JCLambda onLambda,                                 final int type_index,                                 final int pos) {         return new TypeAnnotationPosition(TargetType.METHOD_INVOCATION_TYPE_ARGUMENT,                                           pos, Integer.MIN_VALUE, onLambda,                                           type_index, Integer.MIN_VALUE,                                           location);     } public static TypeAnnotationPosition         methodInvocationTypeArg(final List<TypePathEntry> location,                                 final int type_index) {         return methodInvocationTypeArg(location, null, type_index, -1);     }\n", "docstring": "create code type annotation position method invocation type argument create code type annotation position method invocation type argument\n", "func_name": "72", "dfs": "return new TypeAnnotationPosition(TargetType.METHOD_INVOCATION_TYPE_ARGUMENT,pos,Integer.MIN_VALUE,onLambda,type_index,Integer.MIN_VALUE,location); final int pos final int type_index final JCLambda onLambda final List<TypePathEntry> location return methodInvocationTypeArg(location,null,type_index,-1); final int type_index final List<TypePathEntry> location"}
{"url": "73", "code": "protected boolean isPotentialLazyCrossReference(EStructuralFeature feature) {   return !feature.isDerived() && !feature.isTransient()      && feature instanceof EReference && ((EReference)feature).isResolveProxies();  }\n", "docstring": "return code code given feature may hold proxy resolved\n", "func_name": "73", "dfs": "return !feature.isDerived() && !feature.isTransient() && feature instanceof EReference && ((EReference)feature).isResolveProxies(); EStructuralFeature feature"}
{"url": "74", "code": "public Response unprotectResponse(Response response) throws IOException {         try {             if (!supportsProtection() || !HttpHeaders.hasBody(response)) {                 return response;             }              if (!response.header(\"content-type\").toLowerCase().contains(\"application/jose+json\")) {                 return response;             }              JWSObject jwsObject = JWSObject.deserialize(response.body().string());             JWSHeader jwsHeader = jwsObject.jwsHeader();              if (!jwsHeader.kid().equals(serverSignatureKey.kid()) || !jwsHeader.alg().equals(\"RS256\")) {                 throw new IOException(\"Invalid protected response\");             }              byte[] data = (jwsObject.originalProtected() + \".\" + jwsObject.payload()).getBytes(MESSAGE_ENCODING);             byte[] signature = MessageSecurityHelper.base64UrltoByteArray(jwsObject.signature());              RsaKey serverSignatureRsaKey = new RsaKey(serverSignatureKey.kid(), serverSignatureKey.toRSA(false));             boolean signed = serverSignatureRsaKey.verifyAsync(getSha256(data), signature, \"RS256\").get();             if (!signed) {                 throw new IOException(\"Wrong signature.\");             }              String decrypted = unprotectPayload(jwsObject.payload());              MediaType contentType = response.body().contentType();             ResponseBody body = ResponseBody.create(contentType, decrypted);             return response.newBuilder().body(body).build();         } catch (ExecutionException e) {             // unexpected;             return null;         } catch (InterruptedException e) {             // unexpected;             return null;         } catch (NoSuchAlgorithmException e) {             // unexpected;             return null;         }     }\n", "docstring": "unprotect response needed replaces body unencrypted version\n", "func_name": "74", "dfs": "Response response"}
{"url": "75", "code": "private static void resetMapperForCQL3(boolean isCql3Enabled)     {         if (isCql3Enabled)         {             validationClassMapper.put(Byte.class, Int32Type.class);             validationClassMapper.put(byte.class, Int32Type.class);             validationClassMapper.put(Short.class, Int32Type.class);             validationClassMapper.put(short.class, Int32Type.class);             validationClassMapper.put(java.sql.Time.class, TimestampType.class);             validationClassMapper.put(java.sql.Date.class, TimestampType.class);             validationClassMapper.put(java.util.Date.class, TimestampType.class);             validationClassMapper.put(java.sql.Timestamp.class, TimestampType.class);          }     }\n", "docstring": "reset mapper\n", "func_name": "75", "dfs": "isCql3Enabled validationClassMapper.put(,); validationClassMapper.put(,); validationClassMapper.put(,); validationClassMapper.put(,); validationClassMapper.put(,); validationClassMapper.put(,); validationClassMapper.put(,); validationClassMapper.put(,); boolean isCql3Enabled"}
{"url": "76", "code": "private void callUnbind(NameComponent[] path) throws NamingException {         if (_nc == null)             throw IIOPLogger.ROOT_LOGGER.notANamingContext(path.toString());         try {             _nc.unbind(path);         } catch (NotFound e) {             // If leaf is the one missing, return success             // as per JNDI spec              if (leafNotFound(e, path[path.length - 1])) {                 // do nothing             } else {                 throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, path);             }         } catch (Exception e) {             throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, path);         }     }\n", "docstring": "calls unbind api cos naming uses exception mapper class map exceptions\n", "func_name": "76", "dfs": "NameComponent[] path"}
{"url": "77", "code": "@Deprecated     public static boolean nodeExists(Object json, String path) {         return !getNode(json, path).isMissingNode();     }\n", "docstring": "returns node exists\n", "func_name": "77", "dfs": "return !getNode(json,path).isMissingNode(); String path Object json"}
{"url": "78", "code": "@SneakyThrows     public static PublicKey extractPublicKeyFromResource(final String secretKeyToUse) {         LOGGER.debug(\"Attempting to extract public key from [{}]...\", secretKeyToUse);         val resource = ResourceUtils.getResourceFrom(secretKeyToUse);         val factory = new PublicKeyFactoryBean();         factory.setAlgorithm(RsaKeyUtil.RSA);         factory.setResource(resource);         factory.setSingleton(false);         return factory.getObject();     }\n", "docstring": "extract key resource key\n", "func_name": "78", "dfs": "return factory.getObject(); factory.setSingleton(false); factory.setResource(resource); factory.setAlgorithm(RsaKeyUtil.RSA); val factory = new PublicKeyFactoryBean(); val resource = ResourceUtils.getResourceFrom(secretKeyToUse); LOGGER.debug(\\\"Attempting to extract public key from [{}]...\\\",secretKeyToUse); final String secretKeyToUse"}
{"url": "79", "code": "synchronized public Set getClassesForPackage( String pack ) {         insureInitialized();         Set set = new HashSet();         Collection c = (Collection)packageMap.get( pack );         if ( c != null )             set.addAll( c );          if ( compPaths != null )             for (int i=0; i<compPaths.size(); i++) {                 c = ((BshClassPath)compPaths.get(i)).getClassesForPackage(                     pack );                 if ( c != null )                     set.addAll( c );             }         return set;     }\n", "docstring": "return set class names specified including component paths\n", "func_name": "79", "dfs": "return set; i < compPaths.size() c != null set.addAll(c); c = ((BshClassPath)compPaths.get(i)).getClassesForPackage(pack); i++ int i = 0 compPaths != null set.addAll(c); c != null Collection c = (Collection)packageMap.get(pack); Set set = new HashSet(); insureInitialized(); String pack"}
{"url": "80", "code": "ServerSessionContext registerResult(long sequence, ServerStateMachine.Result result) {     results.put(sequence, result);     return this;   }\n", "docstring": "registers session result results stored memory servers order provide linear able semantics command applied state machine command return value stored sequence number client acknowledges receipt command output result cleared memory\n", "func_name": "80", "dfs": "return this; results.put(sequence,result); ServerStateMachine.Result result long sequence"}
{"url": "81", "code": "private void checkMarkupLevel(final int markupLevel) {         if (markupLevel >= this.matchedMarkupLevels.length) {             final int newLen = Math.max(markupLevel + 1, this.matchedMarkupLevels.length + MATCHED_MARKUP_LEVELS_LEN);             final boolean[] newMatchedMarkupLevels = new boolean[newLen];             Arrays.fill(newMatchedMarkupLevels, false);             System.arraycopy(this.matchedMarkupLevels, 0, newMatchedMarkupLevels, 0, this.matchedMarkupLevels.length);             this.matchedMarkupLevels = newMatchedMarkupLevels;         }     }\n", "docstring": "level handling\n", "func_name": "81", "dfs": "markupLevel >= this.matchedMarkupLevels.length this.matchedMarkupLevels = newMatchedMarkupLevels; System.arraycopy(this.matchedMarkupLevels,0,newMatchedMarkupLevels,0,this.matchedMarkupLevels.length); Arrays.fill(newMatchedMarkupLevels,false); final boolean[] newMatchedMarkupLevels = new boolean[][]; final int newLen = Math.max(markupLevel + 1,this.matchedMarkupLevels.length + MATCHED_MARKUP_LEVELS_LEN); final int markupLevel"}
{"url": "82", "code": "public static MozuUrl deletePackageUrl(String packageId, String returnId)   {    UrlFormatter formatter = new UrlFormatter(\"/api/commerce/returns/{returnId}/packages/{packageId}\");    formatter.formatUrl(\"packageId\", packageId);    formatter.formatUrl(\"returnId\", returnId);    return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.TENANT_POD) ;   }\n", "docstring": "get resource url delete\n", "func_name": "82", "dfs": "return new MozuUrl(formatter.getResourceUrl(),MozuUrl.UrlLocation.TENANT_POD); formatter.formatUrl(\\\"returnId\\\",returnId); formatter.formatUrl(\\\"packageId\\\",packageId); UrlFormatter formatter = new UrlFormatter(\\\"/api/commerce/returns/{returnId}/packages/{packageId}\\\"); String returnId String packageId"}
{"url": "83", "code": "private void emitNode() throws TTIOException {         switch (mRtx.getNode().getKind()) {         case ROOT:             mEvent = mFac.createStartDocument();             break;         case ELEMENT:             final long key = mRtx.getNode().getDataKey();             final QName qName = mRtx.getQNameOfCurrentNode();             mEvent = mFac.createStartElement(qName, new AttributeIterator(mRtx), new NamespaceIterator(mRtx));             mRtx.moveTo(key);             break;         case TEXT:             mEvent = mFac.createCharacters(mRtx.getValueOfCurrentNode());             break;         default:             throw new IllegalStateException(\"Kind not known!\");         }     }\n", "docstring": "emit node\n", "func_name": "83", "dfs": "mRtx.getNode().getKind() throw new IllegalStateException(\\\"Kind not known!\\\"); mEvent = mFac.createCharacters(mRtx.getValueOfCurrentNode()); mRtx.moveTo(key); mEvent = mFac.createStartElement(qName,new AttributeIterator(mRtx),new NamespaceIterator(mRtx)); final QName qName = mRtx.getQNameOfCurrentNode(); final long key = mRtx.getNode().getDataKey(); mEvent = mFac.createStartDocument();"}
{"url": "84", "code": "public void enableOverride(int overrideId, int pathId, String clientUUID) throws Exception {         // get profileId from pathId         int profileId = PathOverrideService.getInstance().getPath(pathId).getProfileId();         int newPriority = 0;          // we want to limit -1, -2 to only be added once since they are the Custom responses/requests         if (overrideId == Constants.PLUGIN_REQUEST_OVERRIDE_CUSTOM) {             if (this.getEnabledEndpoint(pathId, overrideId, null, clientUUID) != null) {                 return;             }         }          // need to first determine the highest enabled order value for this path         HashMap<String, Object> priorities = sqlService.getFirstResult(             \"SELECT * FROM \" + Constants.DB_TABLE_ENABLED_OVERRIDE +                 \" WHERE \" + Constants.REQUEST_RESPONSE_PATH_ID + \"=\" + pathId +                 \" AND \" + Constants.GENERIC_CLIENT_UUID + \"='\" + clientUUID +                 \"' ORDER BY + \" + Constants.ENABLED_OVERRIDES_PRIORITY + \" DESC\"         );         if (priorities != null) {             newPriority = Integer.valueOf(priorities.get(Constants.ENABLED_OVERRIDES_PRIORITY.toUpperCase()).toString()) + 1;         }          PreparedStatement statement = null;         try (Connection sqlConnection = sqlService.getConnection()) {              PreparedStatement query = null;             ResultSet results = null;             SQLService sqlService = SQLService.getInstance();             com.groupon.odo.proxylib.models.Method method = null;             query = sqlConnection.prepareStatement(                 \"SELECT * FROM \" + Constants.DB_TABLE_OVERRIDE +                     \" WHERE \" + Constants.GENERIC_ID + \" = ?\"             );             query.setString(1, String.valueOf(overrideId));             results = query.executeQuery();             JSONSerializer serializer = new JSONSerializer();             if (results.next()) {                 String className = results.getString(Constants.OVERRIDE_CLASS_NAME);                 String methodName = results.getString(Constants.OVERRIDE_METHOD_NAME);                 method = PluginManager.getInstance().getMethod(className, methodName);             }              statement = sqlConnection.prepareStatement(                 \"INSERT INTO \" + Constants.DB_TABLE_ENABLED_OVERRIDE +                     \"(\" + Constants.GENERIC_PROFILE_ID + \",\" + Constants.GENERIC_CLIENT_UUID + \",\" +                     Constants.REQUEST_RESPONSE_PATH_ID + \",\" + Constants.ENABLED_OVERRIDES_OVERRIDE_ID + \",\" +                     Constants.ENABLED_OVERRIDES_PRIORITY + \",\" + Constants.ENABLED_OVERRIDES_ARGUMENTS +  \",\" +                     Constants.ENABLED_OVERRIDES_RESPONSE_CODE + \")\" +                     \" VALUES (?, ?, ?, ?, ?, ?, ?);\"             );             statement.setInt(1, profileId);             statement.setString(2, clientUUID);             statement.setInt(3, pathId);             statement.setInt(4, overrideId);             statement.setInt(5, newPriority);             if (method == null) {                 statement.setString(6, \"\");             } else {                 ArrayList<String> argDefaults = new ArrayList<String>();                 for (int i = 0; i < method.getMethodArguments().length; i++) {                     if (i < method.getMethodDefaultArguments().length && method.getMethodDefaultArguments()[i] != null) {                         argDefaults.add(String.valueOf(method.getMethodDefaultArguments()[i]));                     } else {                         argDefaults.add(\"\");                     }                 }                 statement.setString(6, serializer.serialize(argDefaults));             }             statement.setString(7,\"200\");             statement.executeUpdate();         } catch (Exception e) {             e.printStackTrace();         } finally {             try {                 if (statement != null) {                     statement.close();                 }             } catch (Exception e) {             }         }     }\n", "docstring": "enable specific path\n", "func_name": "84", "dfs": "String clientUUID int pathId int overrideId"}
{"url": "85", "code": "public static <T> Middleware<AsyncHandler<Response<T>>, AsyncHandler<Response<ByteString>>>   htmlSerializeResponse(final String templateName) {     return handler ->         requestContext -> handler.invoke(requestContext)             .thenApply(response -> response                 .withPayload(serialize(templateName, response.payload().orElse(null)))                 .withHeader(CONTENT_TYPE, HTML));   }\n", "docstring": "sync middle ware response object\n", "func_name": "85", "dfs": "final String templateName"}
{"url": "86", "code": "public void updateSite(String siteRoot) {          try {             CmsObject cloneCms = OpenCms.initCmsObject(m_cms);             if (siteRoot == null) {                 siteRoot = \"/system\";             }             cloneCms.getRequestContext().setSiteRoot(siteRoot);             m_cms = cloneCms;         } catch (CmsException e1) {             LOG.error(e1.getLocalizedMessage(), e1);         }         updateValidation();     }\n", "docstring": "updates site root\n", "func_name": "86", "dfs": "updateValidation(); LOG.error(e1.getLocalizedMessage(),e1); CmsException e1 m_cms = cloneCms; cloneCms.getRequestContext().setSiteRoot(siteRoot); siteRoot = \\\"/system\\\"; siteRoot == null CmsObject cloneCms = OpenCms.initCmsObject(m_cms); String siteRoot"}
{"url": "87", "code": "public static ByteBuffer combine(final Collection<ByteBuffer> buffers) {          final ByteBuffer buf = ByteBuffer.allocate(remaining(buffers));          for (final Iterator iter = buffers.iterator(); iter.hasNext();) {              final ByteBuffer curBuf = (ByteBuffer) iter.next();              buf.put(curBuf);          }          buf.flip();          return buf;      }\n", "docstring": "combines remaining data given code collection code code buffer code single consolidated code buffer code\n", "func_name": "87", "dfs": "return buf; buf.flip(); iter.hasNext() buf.put(curBuf); final ByteBuffer curBuf = (ByteBuffer)iter.next(); Iterator iter = buffers.iterator() final ByteBuffer buf = ByteBuffer.allocate(remaining(buffers)); final Collection<ByteBuffer> buffers"}
{"url": "88", "code": "private void copy(final InputStream inputStream, final FileOutputStream outputStream) throws IOException {         final byte[] buffer = new byte[1024*4];         int n;         try {             while (-1 != (n = inputStream.read(buffer))) {                 outputStream.write(buffer, 0, n);             }         } finally {             inputStream.close();             outputStream.close();         }     }\n", "docstring": "copies input stream output stream using buffer\n", "func_name": "88", "dfs": "-1 != (n = inputStream.read(buffer))  int n; final byte[] buffer = new byte[][]; outputStream.write(buffer,0,n); final FileOutputStream outputStream final InputStream inputStream"}
{"url": "89", "code": "@Override     public T addAsServiceProviderAndClasses(Class<?> serviceInterface, Class<?>... serviceImpls)         throws IllegalArgumentException {         Validate.notNull(serviceInterface, \"ServiceInterface must be specified\");         Validate.notNullAndNoNullValues(serviceImpls, \"ServiceImpls must be specified and can not contain null values\");          addAsServiceProvider(serviceInterface, serviceImpls);         addClass(serviceInterface);         return addClasses(serviceImpls);     }\n", "docstring": "non java doc\n", "func_name": "89", "dfs": "return addClasses(serviceImpls); addClass(serviceInterface); addAsServiceProvider(serviceInterface,serviceImpls); Validate.notNullAndNoNullValues(serviceImpls,\\\"ServiceImpls must be specified and can not contain null values\\\"); Validate.notNull(serviceInterface,\\\"ServiceInterface must be specified\\\"); Class<?> serviceImpls Class<?> serviceInterface"}
{"url": "90", "code": "public static String collapseDots(String path) {     path = removeExtraneousSlashes(path);     // Optimization: Most paths don't contain dots.     if (!path.contains(\".\")) {       return path;     }      List<String> dstFragments = new ArrayList<>();     for (String fragment : Splitter.on('/').split(path)) {       if (fragment.equals(\"..\")) {         if (!dstFragments.isEmpty()) {           dstFragments.remove(dstFragments.size() - 1);         }       } else if (!fragment.equals(\".\")) {         dstFragments.add(fragment);       }     }      // Special case for Join.join([\"\"]); -> \"/\"     if (dstFragments.size() == 1 && dstFragments.get(0).isEmpty()) {       return \"/\";     }     return Joiner.on(\"/\").join(dstFragments);   }\n", "docstring": "removes entries within given path extra move beyond first directory given removed\n", "func_name": "90", "dfs": "path = removeExtraneousSlashes(path); String path"}
{"url": "91", "code": "public void setStorage(java.util.Collection<ValidStorageOptions> storage) {         if (storage == null) {             this.storage = null;             return;         }          this.storage = new java.util.ArrayList<ValidStorageOptions>(storage);     }\n", "docstring": "valid storage options instance\n", "func_name": "91", "dfs": "this.storage = new java.util.ArrayList<ValidStorageOptions>(storage); return; this.storage = null; storage == null java.util.Collection<ValidStorageOptions> storage"}
{"url": "92", "code": "public static void memInfo(final Map<String, Object> infos) {         infos.put(\"heap.used\", MEM_BEAN.getHeapMemoryUsage());         infos.put(\"offHeap.used\", MEM_BEAN.getNonHeapMemoryUsage());         infos.put(\"heap.pendingFinalize\", MEM_BEAN.getObjectPendingFinalizationCount());     }\n", "docstring": "collects system information delivered link memory bean\n", "func_name": "92", "dfs": "infos.put(\\\"heap.pendingFinalize\\\",MEM_BEAN.getObjectPendingFinalizationCount()); infos.put(\\\"offHeap.used\\\",MEM_BEAN.getNonHeapMemoryUsage()); infos.put(\\\"heap.used\\\",MEM_BEAN.getHeapMemoryUsage()); final Map<String,Object> infos"}
{"url": "93", "code": "static private void parseHeader(String base, XMLStreamReader rdr, List<String> cols, List<String> md) throws XMLStreamException, SparqlException {     logger.debug(\"xml:base is initially {}\", base);     base = getBase(base, rdr);     testOpen(rdr, rdr.nextTag(), HEAD, \"Missing header from XML results\");     base = getBase(base, rdr);     boolean endedVars = false;     int eventType;     while ((eventType = rdr.nextTag()) != END_ELEMENT || !nameIs(rdr, HEAD)) {       if (eventType == START_ELEMENT) {         if (nameIs(rdr, VARIABLE)) {           if (endedVars) throw new SparqlException(\"Encountered a variable after header metadata\");           String var = rdr.getAttributeValue(null, \"name\");           if (var != null) cols.add(var);           else logger.warn(\"<variable> element without 'name' attribute\");         } else if (nameIs(rdr, LINK)) {           String b = getBase(base, rdr); // Copy to a new var since we're looping.           String href = rdr.getAttributeValue(null, HREF);           if (href != null) md.add(resolve(b, href));           else logger.warn(\"<link> element without 'href' attribute\");           endedVars = true;         }       }     }     // ending on </head>. next() should be <results> or <boolean>     testClose(rdr, eventType, HEAD, \"Unexpected element in header: \" + rdr.getLocalName());   }\n", "docstring": "parse head element variables metadata\n", "func_name": "93", "dfs": "List<String> md List<String> cols XMLStreamReader rdr String base"}
{"url": "94", "code": "public static String getName(final String aURLString) {         int pathnameEndIndex;         if (isWindows()) {             if (aURLString.contains(SHARP)) {                 pathnameEndIndex = aURLString.lastIndexOf(SHARP);             } else {                 pathnameEndIndex = aURLString.lastIndexOf(WINDOWS_SEPARATOR);                 if (pathnameEndIndex == -1) {                     pathnameEndIndex = aURLString.lastIndexOf(UNIX_SEPARATOR);                 }             }         } else {             if (aURLString.contains(SHARP)) {                 pathnameEndIndex = aURLString.lastIndexOf(SHARP);             }             pathnameEndIndex = aURLString.lastIndexOf(UNIX_SEPARATOR);         }          String schemaLocation;         if (aURLString.contains(SHARP)) {             schemaLocation = aURLString.substring(0, pathnameEndIndex);         } else {             schemaLocation = aURLString.substring(pathnameEndIndex + 1);         }          return schemaLocation;     }\n", "docstring": "get filename path\n", "func_name": "94", "dfs": "return schemaLocation; schemaLocation = aURLString.substring(pathnameEndIndex + 1); pathnameEndIndex = aURLString.lastIndexOf(UNIX_SEPARATOR); pathnameEndIndex = aURLString.lastIndexOf(SHARP); aURLString.contains(SHARP) pathnameEndIndex = aURLString.lastIndexOf(UNIX_SEPARATOR); pathnameEndIndex == -1 aURLString.contains(SHARP) pathnameEndIndex = aURLString.lastIndexOf(WINDOWS_SEPARATOR); pathnameEndIndex = aURLString.lastIndexOf(SHARP); schemaLocation = aURLString.substring(0,pathnameEndIndex); aURLString.contains(SHARP) String schemaLocation; isWindows() int pathnameEndIndex; final String aURLString"}
{"url": "95", "code": "public static MmtfSummaryDataBean getStructureInfo(Structure structure) {   MmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();   // Get all the atoms   List<Atom> theseAtoms = new ArrayList<>();   List<Chain> allChains = new ArrayList<>();   Map<String, Integer> chainIdToIndexMap = new LinkedHashMap<>();   int chainCounter = 0;   int bondCount = 0;   mmtfSummaryDataBean.setAllAtoms(theseAtoms);   mmtfSummaryDataBean.setAllChains(allChains);   mmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);   for (int i=0; i<structure.nrModels(); i++){    List<Chain> chains = structure.getModel(i);    allChains.addAll(chains);    for (Chain chain : chains) {     String idOne = chain.getId();     if (!chainIdToIndexMap.containsKey(idOne)) {      chainIdToIndexMap.put(idOne, chainCounter);     }     chainCounter++;     for (Group g : chain.getAtomGroups()) {      for(Atom atom: getAtomsForGroup(g)){       theseAtoms.add(atom);       // If both atoms are in the group       if (atom.getBonds()!=null){        bondCount+=atom.getBonds().size();       }      }     }    }   }   // Assumes all bonds are referenced twice   mmtfSummaryDataBean.setNumBonds(bondCount/2);   return mmtfSummaryDataBean;   }\n", "docstring": "get summary information structure\n", "func_name": "95", "dfs": "MmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean(); Structure structure"}
{"url": "96", "code": "public HttpServerInterceptorChain<I, O, II, OO> next(final Interceptor<II, OO> next) {         return new HttpServerInterceptorChain<>(new TransformingInterceptor<I, O, II, OO>() {             @Override             public RequestHandler<I, O> intercept(RequestHandler<II, OO> handler) {                 return interceptor.intercept(next.intercept(handler));             }         });     }\n", "docstring": "add next interceptor chain\n", "func_name": "96", "dfs": "return new HttpServerInterceptorChain<>(new final Interceptor<II,OO> next"}
{"url": "97", "code": "public static <T> boolean arrayContainsRef(T[] array, T value) {    for (int i = 0; i < array.length; i++) {     if (array[i] == value) {      return true;     }    }    return false;   }\n", "docstring": "checks given array contains specified value method works strict reference comparison\n", "func_name": "97", "dfs": "return false; i < array.length array[i] == value return true; i++ int i = 0 T value T[] array"}
{"url": "98", "code": "protected boolean isExtendingTraceeContextProvider(final Object instance) {          if (instance == null) {             return false;         }          return ImplicitContextData.class.isAssignableFrom(instance.getClass()) || WrappedContextData.class.isAssignableFrom(instance.getClass());      }\n", "docstring": "checks whether passed instance extends link implicit context data link trace context logger context provider api wrapped context data types\n", "func_name": "98", "dfs": "return .isAssignableFrom(instance.getClass()) || .isAssignableFrom(instance.getClass()); return false; instance == null final Object instance"}
{"url": "99", "code": "public void setSourceSegments(java.util.Collection<SegmentReference> sourceSegments) {         if (sourceSegments == null) {             this.sourceSegments = null;             return;         }          this.sourceSegments = new java.util.ArrayList<SegmentReference>(sourceSegments);     }\n", "docstring": "base segment build segment source segment defines starting universe endpoints add dimensions segment filters source segment based dimensions specify specify one dimensional segment specify one imported segment\n", "func_name": "99", "dfs": "this.sourceSegments = new java.util.ArrayList<SegmentReference>(sourceSegments); return; this.sourceSegments = null; sourceSegments == null java.util.Collection<SegmentReference> sourceSegments"}
{"url": "100", "code": "private void zSetAllColumnEditorsAndRenderers(JTable table) {         // These variables decide how many samples to look at in each column.         int maxStartRowsToRead = 30;         int maxBulkRowsToRead = 70;         int maxFoundSamplesToExamine = 21;         // Gather some variables that we will need..         TableModel model = table.getModel();         int columnCount = model.getColumnCount();         int rowCount = model.getRowCount();         // Do nothing if the table is empty.         if (columnCount < 1 || rowCount < 1) {             return;         }         // Calculate the increment for looping through the bulk rows.         int bulkRowIncrement = Math.max(1, (rowCount / maxBulkRowsToRead));         // Loop through all the columns.         columnLoop:         for (int columnIndex = 0; columnIndex < columnCount; ++columnIndex) {             TableColumn column = table.getColumnModel().getColumn(columnIndex);             ArrayList<Class> nonNullTypes = new ArrayList<Class>();             // Loop through all the rows that should be sampled.             rowLoop:             for (int rowIndex = 0; (rowIndex < rowCount);                     rowIndex += ((rowIndex < maxStartRowsToRead) ? 1 : bulkRowIncrement)) {                 // Get the value in each row.                 Object value = model.getValueAt(rowIndex, columnIndex);                 if (value == null) {                     continue;                 }                 // Save any found non-null types.                 nonNullTypes.add(value.getClass());                 // If we have already found \"maxFoundSamplesToExamine\" types, then use those                  // samples to determine the column type.                 if (nonNullTypes.size() >= maxFoundSamplesToExamine) {                     Class mostCommonType = InternalUtilities.getMostCommonElementInList(nonNullTypes);                     column.setCellRenderer(table.getDefaultRenderer(mostCommonType));                     column.setCellEditor(table.getDefaultEditor(mostCommonType));                     continue columnLoop;                 }             } // End: rowLoop             // There are no more rows to examine.             // If we found any non-null types at all, then use those to choose the column type.             if (nonNullTypes.size() > 0) {                 Class mostCommonType = InternalUtilities.getMostCommonElementInList(nonNullTypes);                 column.setCellRenderer(table.getDefaultRenderer(mostCommonType));                 column.setCellEditor(table.getDefaultEditor(mostCommonType));             } else {                 // When no types are found in a column, we will use the generic editor.                 column.setCellRenderer(table.getDefaultRenderer(Object.class));                 column.setCellEditor(table.getDefaultEditor(Object.class));             }         } // End: columnLoop     }\n", "docstring": "set column editors render ers\n", "func_name": "100", "dfs": "JTable table"}
{"url": "101", "code": "@SuppressWarnings(\"unchecked\")     @Override     public Map<String, String> getGuiMapForContainer(String containerKey, String locale) {         logger.entering(new Object[] { containerKey, locale });          Map<String, String> instanceMap = new HashMap<>();         List<Object> allObj = getAllObjects();          for (Object temp : allObj) {             Map<String, Object> map = (Map<String, Object>) temp;             if (map == null) {                 logger.log(Level.WARNING, \"Kindly remove the Null document from \"                         + \"the Yaml file. Ignoring the Null document.\");                 continue;             }              if (!map.get(KEY).equals(containerKey)) {                 continue;             }              // Add child elements of Container             if (map.containsKey(ELEMENTS)) {                 List<Map<String, String>> elementList = (ArrayList<Map<String, String>>) map.get(ELEMENTS);                 for (Map<String, String> eachElementMap : elementList) {                     String value = eachElementMap.get(locale);                     if (value == null) {                         value = eachElementMap.get(getDefaultLocale());                     }                     instanceMap.put(eachElementMap.get(KEY), value);                 }             } else if (map.containsKey(ELEMENTSv2)) {                 Map<String, Map<String, String>> elementMap = (Map<String, Map<String, String>>) map.get(ELEMENTSv2);                 for (Entry<String, Map<String, String>> eachElement : elementMap.entrySet()) {                     String value = eachElement.getValue().get(locale);                     if (value == null) {                         value = eachElement.getValue().get(getDefaultLocale());                     }                     String key = eachElement.getValue().get(KEY);                     if (key == null) {                         key = eachElement.getKey();                     }                     instanceMap.put(key, value);                 }             }          }         // can this be changed to put try outside the loop          logger.exiting(instanceMap);         return instanceMap;     }\n", "docstring": "user needs provide locale data needs read successfully reading data input stream placed hash map returned users\n", "func_name": "101", "dfs": "String locale String containerKey"}
{"url": "102", "code": "public Class<?> classForName( String name ) {         if ( isClassBeingDefined( name ) )             throw new InterpreterError(                 \"Attempting to load class in the process of being defined: \"                 +name );          Class<?> clas = null;         try {             clas = plainClassForName( name );         } catch ( ClassNotFoundException e ) { /*ignore*/ }          // try scripted class         if ( clas == null && declaringInterpreter.getCompatibility() )             clas = loadSourceClass( name );          return clas;     }\n", "docstring": "load specified class name taking account added class path reloaded classes etc note trivial implementation see class path class manager mpl fully functional class management\n", "func_name": "102", "dfs": "clas = plainClassForName(name); Class<?> clas = null; throw new InterpreterError(\\\"Attempting to load class in the process of being defined: \\\" + name); isClassBeingDefined(name) String name"}
{"url": "103", "code": "@Override public ProjectFile read(InputStream stream) throws MPXJException    {       File file = null;       try       {          file = InputStreamHelper.writeStreamToTempFile(stream, \".sqlite\");          return read(file);       }        catch (IOException ex)       {          throw new MPXJException(\"\", ex);       }        finally       {          FileHelper.deleteQuietly(file);       }    } @Override public ProjectFile read(File file) throws MPXJException    {       File databaseFile;       if (file.isDirectory())       {          databaseFile = new File(file, \"state.sql\");       }       else       {          databaseFile = file;       }       return readFile(databaseFile);    } private ProjectFile read() throws Exception    {       m_project = new ProjectFile();       m_eventManager = m_project.getEventManager();        ProjectConfig config = m_project.getProjectConfig();       config.setAutoCalendarUniqueID(false);       config.setAutoTaskUniqueID(false);       config.setAutoResourceUniqueID(false);        m_project.getProjectProperties().setFileApplication(\"Merlin\");       m_project.getProjectProperties().setFileType(\"SQLITE\");        m_eventManager.addProjectListeners(m_projectListeners);        populateEntityMap();       processProject();       processCalendars();       processResources();       processTasks();       processAssignments();       processDependencies();        return m_project;    }\n", "docstring": "read project data return project file instance\n", "func_name": "103", "dfs": "return read(file);  throw new MPXJException(\\\"\\\",ex); IOException ex file = InputStreamHelper.writeStreamToTempFile(stream,\\\".sqlite\\\"); File file = null; InputStream stream return readFile(databaseFile); databaseFile = file; databaseFile = new File(file,\\\"state.sql\\\"); file.isDirectory() File databaseFile; File file return m_project; processDependencies(); processAssignments(); processTasks(); processResources(); processCalendars(); processProject(); populateEntityMap(); m_eventManager.addProjectListeners(m_projectListeners); m_project.getProjectProperties().setFileType(\\\"SQLITE\\\"); m_project.getProjectProperties().setFileApplication(\\\"Merlin\\\"); config.setAutoResourceUniqueID(false); config.setAutoTaskUniqueID(false); config.setAutoCalendarUniqueID(false); ProjectConfig config = m_project.getProjectConfig(); m_eventManager = m_project.getEventManager(); m_project = new ProjectFile();"}
