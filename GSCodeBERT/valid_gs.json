{"url": "327064", "code": "public boolean deleteLedgerMetadata(EditLogLedgerMetadata ledger, int version)       throws IOException {     String ledgerPath = fullyQualifiedPathForLedger(ledger);     try {       zooKeeper.delete(ledgerPath, version);       return true;     } catch (KeeperException.NoNodeException e) {       LOG.warn(ledgerPath + \" does not exist. Returning false, ignoring \" +           e);     } catch (KeeperException.BadVersionException e) {       keeperException(\"Unable to delete \" + ledgerPath + \", version does not match.\" +           \" Updated by another process?\", e);     } catch (KeeperException e) {       keeperException(\"Unrecoverable ZooKeeper error deleting \" + ledgerPath,           e);     } catch (InterruptedException e) {       interruptedException(\"Interrupted deleting \" + ledgerPath, e);     }     return false;   }\n", "docstring": "removes ledger related metadata bookkeeper delete ledger\n", "func_name": "327064", "dfs": "return false; interruptedException(\\\"Interrupted deleting \\\" + ledgerPath,e); InterruptedException e keeperException(\\\"Unrecoverable ZooKeeper error deleting \\\" + ledgerPath,e); KeeperException e keeperException(\\\"Unable to delete \\\" + ledgerPath + \\\", version does not match.\\\" + \\\" Updated by another process?\\\",e); KeeperException.BadVersionException e LOG.warn(ledgerPath + \\\" does not exist. Returning false, ignoring \\\" + e); KeeperException.NoNodeException e return true; zooKeeper.delete(ledgerPath,version); String ledgerPath = fullyQualifiedPathForLedger(ledger); int version EditLogLedgerMetadata ledger"}
{"url": "327066", "code": "public Sheet createSheetInWorkspace(long workspaceId, Sheet sheet) throws SmartsheetException {         return this.createResource(\"workspaces/\" + workspaceId + \"/sheets\", Sheet.class, sheet);     }\n", "docstring": "create sheet given work space\n", "func_name": "327066", "dfs": "return this.createResource(\\\"workspaces/\\\" + workspaceId + \\\"/sheets\\\",,sheet); Sheet sheet long workspaceId"}
{"url": "327067", "code": "@Override   public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, float boost)       throws IOException {     return baseQuery.createWeight(searcher, needsScores, boost);   }\n", "docstring": "non java doc\n", "func_name": "327067", "dfs": "return baseQuery.createWeight(searcher,needsScores,boost); float boost boolean needsScores IndexSearcher searcher"}
{"url": "327068", "code": "public void marshall(PostCommentReplyRequest postCommentReplyRequest, ProtocolMarshaller protocolMarshaller) {          if (postCommentReplyRequest == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(postCommentReplyRequest.getInReplyTo(), INREPLYTO_BINDING);             protocolMarshaller.marshall(postCommentReplyRequest.getClientRequestToken(), CLIENTREQUESTTOKEN_BINDING);             protocolMarshaller.marshall(postCommentReplyRequest.getContent(), CONTENT_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327068", "dfs": "protocolMarshaller.marshall(postCommentReplyRequest.getContent(),CONTENT_BINDING); protocolMarshaller.marshall(postCommentReplyRequest.getClientRequestToken(),CLIENTREQUESTTOKEN_BINDING); protocolMarshaller.marshall(postCommentReplyRequest.getInReplyTo(),INREPLYTO_BINDING); throw new SdkClientException(\\\"Invalid argument passed to marshall(...)\\\"); postCommentReplyRequest == null ProtocolMarshaller protocolMarshaller PostCommentReplyRequest postCommentReplyRequest"}
{"url": "327069", "code": "public static String getDetailOnlyPageName(         CmsObject cms,         CmsResource pageResource,         String detailPath,         String locale) {          return getDetailOnlyPageNameWithoutLocaleCheck(detailPath, getDetailContainerLocale(cms, locale, pageResource));     }\n", "docstring": "returns site root path detail container page site root path detail content\n", "func_name": "327069", "dfs": "return getDetailOnlyPageNameWithoutLocaleCheck(detailPath,getDetailContainerLocale(cms,locale,pageResource)); String locale String detailPath CmsResource pageResource CmsObject cms"}
{"url": "327070", "code": "public long getPrice(Configuration configuration) {         long total = 0;         for (KnapsackItem knapsackItem : getKnapsackItems()) {             if (configuration.valueAt(knapsackItem.getIndex()) == 1) {                 total += knapsackItem.getPrice();             }         }         return total;     }\n", "docstring": "returns price items given configuration\n", "func_name": "327070", "dfs": "return total; total += knapsackItem.getPrice(); configuration.valueAt(knapsackItem.getIndex()) == 1 getKnapsackItems() KnapsackItem knapsackItem long total = 0; Configuration configuration"}
{"url": "327071", "code": "public static base_response delete(nitro_service client, nsip resource) throws Exception {   nsip deleteresource = new nsip();   deleteresource.ipaddress = resource.ipaddress;   deleteresource.td = resource.td;   return deleteresource.delete_resource(client);  }\n", "docstring": "use api delete sip\n", "func_name": "327071", "dfs": "return deleteresource.delete_resource(client); deleteresource.td = resource.td; deleteresource.ipaddress = resource.ipaddress; nsip deleteresource = new nsip(); nsip resource nitro_service client"}
{"url": "327072", "code": "public float invokeFloat(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {         return ((Number) invoke(operationName, stubStrategy, params)).floatValue();     }\n", "docstring": "sends request message server receives reply server returns code code result caller\n", "func_name": "327072", "dfs": "return ((Number)invoke(operationName,stubStrategy,params)).floatValue(); Object[] params StubStrategy stubStrategy String operationName"}
{"url": "327073", "code": "static Injector build(final GuiceRegistry registry,                        ClassScannerFactory scannerFactory,                        final List<PropertyFile> configs,                        final List<GuiceRole> roles,                        final GuiceSetup staticSetup,                        final boolean autoLoadProperties,                        final boolean autoLoadRoles,                        final ClassLoader classloader)  {   final ServiceLoader<GuiceRole> loader = ServiceLoader.load(GuiceRole.class);    // Find additional guice roles from jar files using the Service Provider Interface   if (autoLoadRoles)   {    Iterator<GuiceRole> it = loader.iterator();    while (it.hasNext())    {     final GuiceRole role = it.next();      log.debug(\"Discovered guice role: \" + role);      roles.add(role);    }   }    //  Make sure that the first most basic level of properties is the system environment variables   configs.add(0, getAllEnvironmentVariables());    // Allow all GuiceRole implementations to add/remove/reorder configuration sources   for (GuiceRole role : roles)   {    log.debug(\"Adding requested guice role: \" + role);    role.adjustConfigurations(configs);   }    GuiceConfig properties = new GuiceConfig();    // Generate a random instance ID for this instance of the guice environment   final String instanceId = SimpleId.alphanumeric(32);    // Make the randomly generated instance id available to others   properties.set(GuiceProperties.INSTANCE_ID, instanceId);     for (PropertyFile config : configs)    properties.setAll(config);    // Load all the core property files?   if (autoLoadProperties)   {    applyConfigs(classloader, properties);   }    // This is a bit of a hack really, but let's insert the GuiceRole for network config if network config is enabled   if (hasNetworkConfiguration(properties))   {    final NetworkConfigGuiceRole role = new NetworkConfigGuiceRole();     roles.add(role);   }    // Read the override configuration property to find the override config file   // Load the override config file and pass that along too.   PropertyFile overrideFile = load(properties.get(GuiceProperties.OVERRIDE_FILE_PROPERTY));    // If there are overrides then rebuild the configuration to reflect it   if (overrideFile != null)   {    log.debug(\"Applying overrides: \" + overrideFile.getFile());    properties.setOverrides(overrideFile.toMap());   }     // Set up the class scanner factory (if the scanner property is set and one has not been provided)   if (scannerFactory == null)   {    List<String> packages = properties.getList(GuiceProperties.SCAN_PACKAGES, Collections.emptyList());     if (packages != null && !packages.isEmpty())     scannerFactory = new ClassScannerFactory(packages.toArray(new String[packages.size()]));    else     throw new IllegalArgumentException(\"Property \" + GuiceProperties.SCAN_PACKAGES + \" has not been set!\");   }    final GuiceSetup setup;   if (staticSetup == null)   {    // Load the Setup property and load the Setup class    final Class<? extends GuiceSetup> setupClass = getClass(properties, GuiceSetup.class, GuiceProperties.SETUP_PROPERTY);     try    {     if (setupClass == null)      throw new IllegalArgumentException(\"Could not find a setup class!\");      setup = setupClass.newInstance();      log.debug(\"Constructed GuiceSetup: \" + setupClass);    }    catch (InstantiationException | IllegalAccessException e)    {     throw new IllegalArgumentException(\"Error constructing instance of \" + setupClass, e);    }   }   else   {    log.debug(\"Using static GuiceSetup: \" + staticSetup);    setup = staticSetup;   }    return createInjector(registry, scannerFactory, properties, setup, roles);  }\n", "docstring": "build ice environment achieved following stages load ice role implementations using link service loader service provider allow ice role instances add remove change base configuration load configuration file resources environment properties load network configuration enabled add special ice role network configuration auto reload network configuration enabled load configuration file present set class path scanner using property link ice properties packages instantiate link ice setup class specified link ice properties setup property hand ice setup roles configuration class path scanner link create injector ice registry class scanner factory ice config ice setup list\n", "func_name": "327073", "dfs": "final ServiceLoader<GuiceRole> loader = ServiceLoader.load(); final ClassLoader classloader final boolean autoLoadRoles final boolean autoLoadProperties final GuiceSetup staticSetup final List<GuiceRole> roles final List<PropertyFile> configs ClassScannerFactory scannerFactory final GuiceRegistry registry"}
{"url": "327074", "code": "public ECDSASignature sign(byte[] messageHash) {         ECDSASignature sig = doSign(messageHash);         // Now we have to work backwards to figure out the recId needed to recover the         // signature.         int recId = -1;         byte[] thisKey = this.pub.getEncoded(/* compressed */ false);         for (int i = 0; i < 4; i++) {             byte[] k = ECKey.recoverPubBytesFromSignature(i, sig, messageHash);             if (k != null && Arrays.equals(k, thisKey)) {                 recId = i;                 break;             }         }         if (recId == -1)             throw new RuntimeException(\"Could not construct a recoverable key. This should never happen.\");         sig.v = (byte) (recId + 27);         return sig;     }\n", "docstring": "takes cca hash bytes data returns cds signature\n", "func_name": "327074", "dfs": "ECDSASignature sig = doSign(messageHash); byte[] messageHash"}
{"url": "327075", "code": "public void marshall(HttpHeader httpHeader, ProtocolMarshaller protocolMarshaller) {          if (httpHeader == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(httpHeader.getHeaderName(), HEADERNAME_BINDING);             protocolMarshaller.marshall(httpHeader.getHeaderValue(), HEADERVALUE_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327075", "dfs": "protocolMarshaller.marshall(httpHeader.getHeaderValue(),HEADERVALUE_BINDING); protocolMarshaller.marshall(httpHeader.getHeaderName(),HEADERNAME_BINDING); throw new SdkClientException(\\\"Invalid argument passed to marshall(...)\\\"); httpHeader == null ProtocolMarshaller protocolMarshaller HttpHeader httpHeader"}
{"url": "327076", "code": "public void clear(long index) {         int wordNum = (int)(index >> 6); // div 64         if (wordNum>=wlen) return;         int bit = (int)index & 0x3f;     // mod 64         long bitmask = 1L << bit;         bits[wordNum] &= ~bitmask;     }\n", "docstring": "clears bit allowing access beyond current set size without changing size\n", "func_name": "327076", "dfs": "int wordNum = (int)(index >> 6); long index"}
{"url": "327077", "code": "public void add(CSVRecord record) {         if (records == null)             records = new ArrayList<>();         records.add(record);     }\n", "docstring": "add record\n", "func_name": "327077", "dfs": "records.add(record); records = new ArrayList<>(); records == null CSVRecord record"}
{"url": "327078", "code": "public void runCalendarEntry(Map<String,Object> properties)     {         ProcessRunnerTask task = new ProcessRunnerTask(null, null, properties);         ((Application)this.getTask().getApplication()).getTaskScheduler().addTask(task);     }\n", "docstring": "run calendar entry method\n", "func_name": "327078", "dfs": "((Application)this.getTask().getApplication()).getTaskScheduler().addTask(task); ProcessRunnerTask task = new ProcessRunnerTask(null,null,properties); Map<String,Object> properties"}
{"url": "327079", "code": "public static boolean isValidInt(@Nullable final String integerStr) {         if (StringUtils.isBlank(integerStr)) {             return false;         }         final String stripedInteger = StringUtils.strip(integerStr);         try {             NumberUtils.createInteger(stripedInteger);             return true;         } catch (NumberFormatException e) {             return false;         }     } public static boolean isValidInt(@Nullable final String integerStr, final int lowerBound, final int upperBound, final boolean includeLowerBound, final boolean includeUpperBound) {         if (lowerBound > upperBound) {             throw new IllegalArgumentException(ExceptionValues.INVALID_BOUNDS);         } else if (!isValidInt(integerStr)) {             return false;         }         final int aInteger = toInteger(integerStr);         final boolean respectsLowerBound = includeLowerBound ? lowerBound <= aInteger : lowerBound < aInteger;         final boolean respectsUpperBound = includeUpperBound ? aInteger <= upperBound : aInteger < upperBound;         return respectsLowerBound && respectsUpperBound;     } public static boolean isValidInt(@Nullable final String integerStr, final int lowerBound, final int upperBound) {         return isValidInt(integerStr, lowerBound, upperBound, true, false);     }\n", "docstring": "given integer string checks valid integer based apaches number utils create integer given integer string checks valid integer base apaches number utils create integer lower bound upper bound given integer string checks valid integer base apaches number utils create integer lower bound upper bound including lower bound excluding upper bound\n", "func_name": "327079", "dfs": "return true; NumberUtils.createInteger(stripedInteger); final String stripedInteger = StringUtils.strip(integerStr); return false; StringUtils.isBlank(integerStr) @Nullable final String integerStr return respectsLowerBound && respectsUpperBound; final boolean respectsUpperBound = includeUpperBound? aInteger <= upperBound: aInteger < upperBound; final boolean respectsLowerBound = includeLowerBound? lowerBound <= aInteger: lowerBound < aInteger; final int aInteger = toInteger(integerStr); return false; !isValidInt(integerStr) throw new IllegalArgumentException(ExceptionValues.INVALID_BOUNDS); lowerBound > upperBound final boolean includeUpperBound final boolean includeLowerBound final int upperBound final int lowerBound @Nullable final String integerStr return isValidInt(integerStr,lowerBound,upperBound,true,false); final int upperBound final int lowerBound @Nullable final String integerStr"}
{"url": "327080", "code": "@XmlElementDecl(namespace = \"http://www.w3.org/ns/prov#\", name = \"wasInformedBy\")     public JAXBElement<WasInformedBy> createWasInformedBy(WasInformedBy value) {         return new JAXBElement<WasInformedBy>(_WasInformedBy_QNAME, WasInformedBy.class, null, value);     }\n", "docstring": "create instance link axb element code link informed code\n", "func_name": "327080", "dfs": "return new JAXBElement<WasInformedBy>(_WasInformedBy_QNAME,,null,value); WasInformedBy value"}
{"url": "327081", "code": "public static Thread newThread(String name, Runnable runnable, boolean daemon) {         Thread thread = new Thread(runnable, name);         thread.setDaemon(daemon);         return thread;     }\n", "docstring": "create thread\n", "func_name": "327081", "dfs": "return thread; thread.setDaemon(daemon); Thread thread = new Thread(runnable,name); boolean daemon Runnable runnable String name"}
{"url": "327082", "code": "@GET     @Path(\"{uuid}\")     public Violation getViolationByUuid(@PathParam(\"uuid\") UUID violationUuid) throws NotFoundException{         logger.debug(\"StartOf getViolationByUuid - REQUEST for /violations/{}\", violationUuid);         ViolationHelperE violationRestHelper = getViolationHelper();         Violation violation = violationRestHelper.getViolationByUUID(violationUuid);         if (violation==null){             logger.info(\"getViolationByUuid NotFoundException: There is no violation with id \" + violationUuid + \" in the SLA Repository Database\");                         throw new NotFoundException(\"There is no violation with id \" + violationUuid + \" in the SLA Repository Database\");                 }         logger.debug(\"EndOf getViolationByUuid\");         return violation;     }\n", "docstring": "returns information specific violation given violation database returns empty payload\n", "func_name": "327082", "dfs": "return violation; logger.debug(\\\"EndOf getViolationByUuid\\\"); throw new NotFoundException(\\\"There is no violation with id \\\" + violationUuid + \\\" in the SLA Repository Database\\\"); logger.info(\\\"getViolationByUuid NotFoundException: There is no violation with id \\\" + violationUuid + \\\" in the SLA Repository Database\\\"); violation == null Violation violation = violationRestHelper.getViolationByUUID(violationUuid); ViolationHelperE violationRestHelper = getViolationHelper(); logger.debug(\\\"StartOf getViolationByUuid - REQUEST for /violations/{}\\\",violationUuid); @PathParam(\\\"uuid\\\") UUID violationUuid"}
{"url": "327083", "code": "private static ValidationResult validateFormatStringVariable(       ExpressionTree formatStringTree,       final Symbol formatStringSymbol,       final List<? extends ExpressionTree> args,       final VisitorState state) {     if (formatStringSymbol.getKind() != ElementKind.LOCAL_VARIABLE) {       return ValidationResult.create(           null,           String.format(               \"Variables used as format strings that are not local variables must be compile time\"                   + \" constants.\\n%s is neither a local variable nor a compile time constant.\",               formatStringTree));     }      // Find the Tree for the block in which the variable is defined. If it is not defined in this     // class (though it may have been in a super class). We require compile time constant values in     // that case.     Symbol owner = formatStringSymbol.owner;     TreePath path = TreePath.getPath(state.getPath(), formatStringTree);     while (path != null && ASTHelpers.getSymbol(path.getLeaf()) != owner) {       path = path.getParentPath();     }      // A local variable must be declared in a parent tree to be accessed. This case should be     // impossible.     if (path == null) {       throw new IllegalStateException(           String.format(               \"Could not find the Tree where local variable %s is declared. \"                   + \"This should be impossible.\",               formatStringTree));     }      // Scan down from the scope where the variable was declared     ValidationResult result =         path.getLeaf()             .accept(                 new TreeScanner<ValidationResult, Void>() {                   @Override                   public ValidationResult visitVariable(VariableTree node, Void unused) {                     if (ASTHelpers.getSymbol(node) == formatStringSymbol) {                       if (node.getInitializer() == null) {                         return ValidationResult.create(                             null,                             String.format(                                 \"Variables used as format strings must be initialized when they are\"                                     + \" declared.\\nInvalid declaration: %s\",                                 node));                       }                       return validateStringFromAssignment(node, node.getInitializer(), args, state);                     }                     return super.visitVariable(node, unused);                   }                    @Override                   public ValidationResult reduce(ValidationResult r1, ValidationResult r2) {                     if (r1 == null && r2 == null) {                       return null;                     }                     return MoreObjects.firstNonNull(r1, r2);                   }                 },                 null);      return result;   }\n", "docstring": "helps\n", "func_name": "327083", "dfs": "formatStringSymbol.getKind() != ElementKind.LOCAL_VARIABLE return ValidationResult.create(null,String.format(\\\"Variables used as format strings that are not local variables must be compile time\\\" + \\\" final VisitorState state final List<? extends ExpressionTree> args final Symbol formatStringSymbol ExpressionTree formatStringTree"}
{"url": "327084", "code": "@SuppressWarnings(\"WeakerAccess\")     public static <K,V> PersistentHashMap<K,V> ofEq(Equator<K> eq, Iterable<Map.Entry<K,V>> es) {         if (es == null) { return empty(eq); }         MutableHashMap<K,V> map = emptyMutable(eq);         for (Map.Entry<K,V> entry : es) {             if (entry != null) {                 map.assoc(entry.getKey(), entry.getValue());             }         }         return map.immutable();     }\n", "docstring": "returns persistent hash map given keys paired values skipping null entries\n", "func_name": "327084", "dfs": "return map.immutable(); map.assoc(entry.getKey(),entry.getValue()); entry != null es Map.Entry<K,V> entry MutableHashMap<K,V> map = emptyMutable(eq); return empty(eq); es == null Iterable<Map.Entry<K,V>> es Equator<K> eq"}
{"url": "327085", "code": "@Override     public Set<String> keySet() {         Set<String> keys = new HashSet<>();         keysR(root.getLeft(), -1, keys);         return keys;     }\n", "docstring": "returns copy keys contained trie set\n", "func_name": "327085", "dfs": "return keys; keysR(root.getLeft(),-1,keys); Set<String> keys = new HashSet<>();"}
{"url": "327086", "code": "@Override  public void setFromName(String fromName, java.util.Locale locale) {   _commerceNotificationTemplate.setFromName(fromName, locale);  }\n", "docstring": "sets localized name commerce notification template language\n", "func_name": "327086", "dfs": "_commerceNotificationTemplate.setFromName(fromName,locale); java.util.Locale locale String fromName"}
{"url": "327088", "code": "public String[] getRegisteredIDs(RESTRequest request,                                      int clientID,                                      String source_objName,                                      String listener_objName) {         //Get the client area         ClientNotificationArea clientArea = getInboxIfAvailable(clientID, null);          List<ServerNotification> registrations = clientArea.getServerRegistrations(request, source_objName);          if (registrations != null) {             List<String> ids = new ArrayList<String>();              //loop registrations to match request             for (ServerNotification registration : registrations) {                 if (registration.listener.getCanonicalName().equals(listener_objName)) {                     //found a matching registration, so add ID to list                     ids.add(registration.filter + \"_\" + registration.handback);                 }             }              return ids.toArray(new String[ids.size()]);         }          return null;     }\n", "docstring": "return array ids strings represent server side notifications given source mbe given listener mbe\n", "func_name": "327088", "dfs": "String listener_objName String source_objName int clientID RESTRequest request"}
{"url": "327089", "code": "private void npnReceived(ServerHello mesg) throws IOException     {         NextProtoNegoExtension extension = (NextProtoNegoExtension)mesg.extensions.get(ExtensionType.EXT_NEXT_PROTOCOL_NEGOTIATION);         if (extension != null)         {             protocols = extension.getProtocols();             if (NextProtoNego.debug)                 System.err.println(new StringBuilder(\"[C] NPN protocols \").append(protocols).append(\" received from server for \").append(conn != null ? conn : engine));         }         else         {             if (NextProtoNego.debug)                 System.err.println(new StringBuilder(\"[C] NPN protocols not sent by server for \").append(conn != null ? conn : engine));         }     }\n", "docstring": "changes begin\n", "func_name": "327089", "dfs": "extension != null NextProtoNego.debug System.err.println(new StringBuilder(\\\"[C] NPN protocols not sent by server for \\\").append(conn != null? conn: engine)); NextProtoNego.debug System.err.println(new StringBuilder(\\\"[C] NPN protocols \\\").append(protocols).append(\\\" received from server for \\\").append(conn != null? conn: engine)); protocols = extension.getProtocols(); NextProtoNegoExtension extension = (NextProtoNegoExtension)mesg.extensions.get(ExtensionType.EXT_NEXT_PROTOCOL_NEGOTIATION); ServerHello mesg"}
{"url": "327090", "code": "public void generateMethodTypesScript(Map<String,Integer> typeMap,             Set<MethodTypes> methodTypes) {         String sep = \"\";         StringBuilder vars = new StringBuilder(\"var methods = {\");         for (Map.Entry<String,Integer> entry : typeMap.entrySet()) {             vars.append(sep);             sep = \",\";             vars.append(\"\\\"\")                     .append(entry.getKey())                     .append(\"\\\":\")                     .append(entry.getValue());         }         vars.append(\"};\").append(DocletConstants.NL);         sep = \"\";         vars.append(\"var tabs = {\");         for (MethodTypes entry : methodTypes) {             vars.append(sep);             sep = \",\";             vars.append(entry.value())                     .append(\":\")                     .append(\"[\")                     .append(\"\\\"\")                     .append(entry.tabId())                     .append(\"\\\"\")                     .append(sep)                     .append(\"\\\"\")                     .append(configuration.getText(entry.resourceKey()))                     .append(\"\\\"]\");         }         vars.append(\"};\")                 .append(DocletConstants.NL);         addStyles(HtmlStyle.altColor, vars);         addStyles(HtmlStyle.rowColor, vars);         addStyles(HtmlStyle.tableTab, vars);         addStyles(HtmlStyle.activeTableTab, vars);         script.addContent(new RawHtml(vars.toString()));     }\n", "docstring": "generated javascript variables document\n", "func_name": "327090", "dfs": "script.addContent(new RawHtml(vars.toString())); addStyles(HtmlStyle.activeTableTab,vars); addStyles(HtmlStyle.tableTab,vars); addStyles(HtmlStyle.rowColor,vars); addStyles(HtmlStyle.altColor,vars); vars.append(\\\"};\\\").append(DocletConstants.NL); vars.append(entry.value()).append(\\\":\\\").append(\\\"[\\\").append(\\\"\\\"\\\").append(entry.tabId()).append(\\\"\\\"\\\").append(sep).append(\\\"\\\"\\\").append(configuration.getText(entry.resourceKey())).append(\\\"\\\"]\\\"); sep = \\\",\\\"; vars.append(sep); methodTypes MethodTypes entry vars.append(\\\"var tabs = {\\\"); sep = \\\"\\\"; vars.append(\\\"};\\\").append(DocletConstants.NL); vars.append(\\\"\\\"\\\").append(entry.getKey()).append(\\\"\\\":\\\").append(entry.getValue()); sep = \\\",\\\"; vars.append(sep); typeMap.entrySet() Map.Entry<String,Integer> entry StringBuilder vars = new StringBuilder(\\\"var methods = {\\\"); String sep = \\\"\\\"; Set<MethodTypes> methodTypes Map<String,Integer> typeMap"}
{"url": "327091", "code": "public void insert(final Parse constituent) {     Span ic = constituent.span;     if (span.contains(ic)) {       //double oprob=c.prob;       int pi=0;       int pn = parts.size();       for (; pi < pn; pi++) {         Parse subPart = (Parse) parts.get(pi);         //System.err.println(\"Parse.insert:con=\"+constituent+\" sp[\"+pi+\"] \"+subPart+\" \"+subPart.getType());         Span sp = subPart.span;         if (sp.getStart() >= ic.getEnd()) {           break;         }         // constituent contains subPart         else if (ic.contains(sp)) {           //System.err.println(\"Parse.insert:con contains subPart\");           parts.remove(pi);           pi--;           constituent.parts.add(subPart);           subPart.setParent(constituent);           //System.err.println(\"Parse.insert: \"+subPart.hashCode()+\" -> \"+subPart.getParent().hashCode());           pn = parts.size();         }         else if (sp.contains(ic)) {           //System.err.println(\"Parse.insert:subPart contains con\");           subPart.insert(constituent);           return;         }       }       //System.err.println(\"Parse.insert:adding con=\"+constituent+\" to \"+this);       parts.add(pi, constituent);       constituent.setParent(this);       //System.err.println(\"Parse.insert: \"+constituent.hashCode()+\" -> \"+constituent.getParent().hashCode());     }     else {       throw (new InternalError(\"Inserting constituent not contained in the sentence!\"));     }   }\n", "docstring": "inserts specified constituent parse based text span method assumes specified constituent inserted parse\n", "func_name": "327091", "dfs": "final Parse constituent"}
{"url": "327092", "code": "public EClass getAMB() {   if (ambEClass == null) {    ambEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(322);   }   return ambEClass;  }\n", "docstring": "begin user doc end user doc\n", "func_name": "327092", "dfs": "return ambEClass; ambEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(322); ambEClass == null"}
{"url": "327093", "code": "private GraphicsDocument createLabelDocument(StringWriter writer, LabelStyleInfo labelStyleInfo)    throws RenderException {    if (TileMetadata.PARAM_SVG_RENDERER.equalsIgnoreCase(renderer)) {    DefaultSvgDocument document = new DefaultSvgDocument(writer, false);    document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);    document.registerWriter(InternalTileImpl.class, new SvgLabelTileWriter(getTransformer(), labelStyleInfo,      geoService, textService));    return document;   } else if (TileMetadata.PARAM_VML_RENDERER.equalsIgnoreCase(renderer)) {    DefaultVmlDocument document = new DefaultVmlDocument(writer);    int coordWidth = tile.getScreenWidth();    int coordHeight = tile.getScreenHeight();    document.registerWriter(InternalFeatureImpl.class, new VmlFeatureWriter(getTransformer(), coordWidth,      coordHeight));    document.registerWriter(InternalTileImpl.class, new VmlLabelTileWriter(coordWidth, coordHeight,      getTransformer(), labelStyleInfo, geoService, textService));    document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);    return document;   } else {    throw new RenderException(ExceptionCode.RENDERER_TYPE_NOT_SUPPORTED, renderer);   }  }\n", "docstring": "create document parses tile label fragment using graphics writer classes\n", "func_name": "327093", "dfs": "TileMetadata.PARAM_SVG_RENDERER.equalsIgnoreCase(renderer) TileMetadata.PARAM_VML_RENDERER.equalsIgnoreCase(renderer) throw new RenderException(ExceptionCode.RENDERER_TYPE_NOT_SUPPORTED,renderer); return document; document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS); document.registerWriter(,new VmlLabelTileWriter(coordWidth,coordHeight,getTransformer(),labelStyleInfo,geoService,textService)); document.registerWriter(,new VmlFeatureWriter(getTransformer(),coordWidth,coordHeight)); int coordHeight = tile.getScreenHeight(); int coordWidth = tile.getScreenWidth(); DefaultVmlDocument document = new DefaultVmlDocument(writer); return document; document.registerWriter(,new SvgLabelTileWriter(getTransformer(),labelStyleInfo,geoService,textService)); document.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS); DefaultSvgDocument document = new DefaultSvgDocument(writer,false); LabelStyleInfo labelStyleInfo StringWriter writer"}
{"url": "327094", "code": "public static List<String> findAll(CharSequence self, CharSequence regex) {         return findAll(self, Pattern.compile(regex.toString()));     } public static <T> List<T> findAll(CharSequence self, CharSequence regex, @ClosureParams(value=SimpleType.class, options=\"java.lang.String[]\") Closure<T> closure) {         return findAll(self, Pattern.compile(regex.toString()), closure);     } public static List<String> findAll(CharSequence self, Pattern pattern) {         Matcher matcher = pattern.matcher(self.toString());         boolean hasGroup = hasGroup(matcher);         List<String> list = new ArrayList<String>();         for (Iterator iter = iterator(matcher); iter.hasNext();) {             if (hasGroup) {                 list.add((String) ((List) iter.next()).get(0));             } else {                 list.add((String) iter.next());             }         }         return new ArrayList<String>(list);     } public static <T> List<T> findAll(CharSequence self, Pattern pattern, @ClosureParams(value=SimpleType.class, options=\"java.lang.String[]\") Closure<T> closure) {         Matcher matcher = pattern.matcher(self.toString());         return DefaultGroovyMethods.collect(matcher, closure);     }\n", "docstring": "returns possibly empty list occurrences regular expression provided sequence found within sequence example regex match returns empty list pre foo find fish pre regular expression matches returned list regex capture groupings ignored full match returned pre def expected one fish two fish red fish blue fish expected one fish two fish red fish blue fish find fish pre need work capture groups use closure version method use groovy match operators use match finds occurrences regular expression string within sequence matches passed specified closure closure expected full match first parameter capture groups placed subsequent parameters matches closure called empty list returned example regex match returns empty list pre foo find fish match first word return first word pre regular expression matches passed closure capture groups one parameter match pre could would fox find match match pre capture groups first parameter match followed one parameter capture group pre def orig woc ket pocket woc ket pocket orig find ock match first letter first letter match pre returns possibly empty list occurrences regular expression pattern format found within sequence example pattern match returns empty list pre foo find fish pre regular expression matches returned list regex capture groupings ignored full match returned pre def expected one fish two fish red fish blue fish expected one fish two fish red fish blue fish find fish pre finds occurrences compiled regular expression pattern within sequence matches passed specified closure closure expected full match first parameter capture groups placed subsequent parameters matches closure called empty list returned example pattern match returns empty list pre foo find fish match first word return first word pre regular expression matches passed closure capture groups one parameter match pre could would fox find match match pre capture groups first parameter match followed one parameter capture group pre def orig woc ket pocket woc ket pocket orig find ock match first letter first letter match pre\n", "func_name": "327094", "dfs": "return findAll(self,Pattern.compile(regex.toString())); CharSequence regex CharSequence self return findAll(self,Pattern.compile(regex.toString()),closure); @ClosureParams(value=SimpleType.class,options=\\\"java.lang.String[]\\\") Closure<T> closure CharSequence regex CharSequence self return new ArrayList<String>(list); iter.hasNext() list.add((String)iter.next()); list.add((String)((List)iter.next()).get(0)); hasGroup Iterator iter = iterator(matcher) List<String> list = new ArrayList<String>(); boolean hasGroup = hasGroup(matcher); Matcher matcher = pattern.matcher(self.toString()); Pattern pattern CharSequence self return DefaultGroovyMethods.collect(matcher,closure); Matcher matcher = pattern.matcher(self.toString()); @ClosureParams(value=SimpleType.class,options=\\\"java.lang.String[]\\\") Closure<T> closure Pattern pattern CharSequence self"}
{"url": "327095", "code": "protected void fill(int fromIndex, int endIndex) {         fromIndex = fromIndex == -1 ? 0 : fromIndex;         endIndex = endIndex == -1 || endIndex > this.timeSeries.length ? this.timeSeries.length : endIndex;          final T val;         if (applyZero()) {             val = zero();         } else {             val = null;         }          // set the values         for (int i = fromIndex; i < endIndex; i++) {             set(i, val);         }     }\n", "docstring": "resets values index end index\n", "func_name": "327095", "dfs": "applyZero() val = null; val = zero(); final T val; endIndex = endIndex == -1 || endIndex > this.timeSeries.length? this.timeSeries.length: endIndex; fromIndex = fromIndex == -1? 0: fromIndex; int endIndex int fromIndex"}
{"url": "327096", "code": "public final String getConfigurationValue(String key)     {         //get value         String value=this.serviceConfiguration.getConfigurationValue(key);                  return value;     }\n", "docstring": "returns value component configuration based provided configuration key value trimmed trimmed configuration value empty string null returned instead\n", "func_name": "327096", "dfs": "String key"}
{"url": "327097", "code": "public boolean setListOption(String fieldName, String[] exportValues, String[] displayValues) {         if (exportValues == null && displayValues == null)             return false;         if (exportValues != null && displayValues != null && exportValues.length != displayValues.length)             throw new IllegalArgumentException(\"The export and the display array must have the same size.\");         int ftype = getFieldType(fieldName);         if (ftype != FIELD_TYPE_COMBO && ftype != FIELD_TYPE_LIST)             return false;         Item fd = (Item)fields.get(fieldName);         String[] sing = null;         if (exportValues == null && displayValues != null)             sing = displayValues;         else if (exportValues != null && displayValues == null)             sing = exportValues;         PdfArray opt = new PdfArray();         if (sing != null) {             for (int k = 0; k < sing.length; ++k)                 opt.add(new PdfString(sing[k], PdfObject.TEXT_UNICODE));         }         else {             for (int k = 0; k < exportValues.length; ++k) {                 PdfArray a = new PdfArray();                 a.add(new PdfString(exportValues[k], PdfObject.TEXT_UNICODE));                 a.add(new PdfString(displayValues[k], PdfObject.TEXT_UNICODE));                 opt.add(a);             }         }         fd.writeToAll( PdfName.OPT, opt, Item.WRITE_VALUE | Item.WRITE_MERGED );         return true;     }\n", "docstring": "sets option list fields type list combo one code export values code code display values code may code null code method set list set value appearance calling code set field code required example pre pdf reader pdf pdf reader input pdf pdfs tamper stp pdfs tamper pdf file output stream output pdf cro fields stp get cro fields set list option combo box string string first second third set field combo box stp close pre\n", "func_name": "327097", "dfs": "return true; fd.writeToAll(PdfName.OPT,opt,Item.WRITE_VALUE | Item.WRITE_MERGED); k < exportValues.length opt.add(a); a.add(new PdfString(displayValues[k],PdfObject.TEXT_UNICODE)); a.add(new PdfString(exportValues[k],PdfObject.TEXT_UNICODE)); PdfArray a = new PdfArray(); ++k int k = 0 k < sing.length opt.add(new PdfString(sing[k],PdfObject.TEXT_UNICODE)); sing = exportValues; exportValues != null && displayValues == null sing = displayValues; ++k int k = 0 sing != null PdfArray opt = new PdfArray(); exportValues == null && displayValues != null String[] sing = null; Item fd = (Item)fields.get(fieldName); return false; ftype != FIELD_TYPE_COMBO && ftype != FIELD_TYPE_LIST int ftype = getFieldType(fieldName); throw new IllegalArgumentException(\\\"The export and the display array must have the same size.\\\"); exportValues != null && displayValues != null && exportValues.length != displayValues.length return false; exportValues == null && displayValues == null String[] displayValues String[] exportValues String fieldName"}
{"url": "327099", "code": "public boolean addAll(Collection otherCollection,                           Transaction transaction)                     throws ObjectManagerException     {         boolean modified = false;         try {             for (Iterator iterator = otherCollection.iterator();;)                 modified = add((Token) iterator.next(transaction), transaction);         } catch (java.util.NoSuchElementException exception) {             // No FFDC code needed.             // We have run off the end of the other collection.         } // try.            return modified;     }\n", "docstring": "non java doc\n", "func_name": "327099", "dfs": "Transaction transaction Collection otherCollection"}
{"url": "327100", "code": "public Cluster withClusterSecurityGroups(ClusterSecurityGroupMembership... clusterSecurityGroups) {         if (this.clusterSecurityGroups == null) {             setClusterSecurityGroups(new com.amazonaws.internal.SdkInternalList<ClusterSecurityGroupMembership>(clusterSecurityGroups.length));         }         for (ClusterSecurityGroupMembership ele : clusterSecurityGroups) {             this.clusterSecurityGroups.add(ele);         }         return this;     }\n", "docstring": "list cluster security group associated cluster security group represented element contains code cluster security group name code code cluster security group status code sub elements cluster security groups used cluster created amazon virtual cloud clusters created use security groups listed security groups parameter note method appends values existing list use link set cluster security groups java util collection link cluster security groups java util collection want existing values\n", "func_name": "327100", "dfs": "return this; this.clusterSecurityGroups.add(ele); setClusterSecurityGroups(new com.amazonaws.internal.SdkInternalList<ClusterSecurityGroupMembership>(clusterSecurityGroups.length)); clusterSecurityGroups ClusterSecurityGroupMembership ele this.clusterSecurityGroups == null ClusterSecurityGroupMembership clusterSecurityGroups"}
{"url": "327101", "code": "public WebApp start() {   log = LoggerFactory.getLogger(WebApp.class);    log.debug(\"Initializing Madvoc WebApp\");    //// params & props   for (final Map<String, Object> params : paramsList) {    madvocContainer.defineParams(params);   }   for (final Props props : propsList) {    madvocContainer.defineParams(props);   }   propsList = null;     //// components   registerMadvocComponents();    madvocComponents.forEach(    madvocComponent -> madvocContainer.registerComponent(madvocComponent.type(), madvocComponent.consumer()));   madvocComponents = null;    madvocComponentInstances.forEach(madvocContainer::registerComponentInstance);   madvocComponentInstances = null;    configureDefaults();     //// listeners   madvocContainer.fireEvent(Init.class);    //// component configuration   componentConfigs.accept(madvocContainer);   componentConfigs = null;    initialized();    madvocContainer.fireEvent(Start.class);    if (!madvocRouterConsumers.isEmpty()) {     final MadvocRouter madvocRouter = MadvocRouter.create();     madvocContainer.registerComponentInstance(madvocRouter);     madvocRouterConsumers.accept(madvocRouter);   }   madvocRouterConsumers = null;    started();    madvocContainer.fireEvent(Ready.class);    ready();    return this;  }\n", "docstring": "initializes starts web application\n", "func_name": "327101", "dfs": "log.debug(\\\"Initializing Madvoc WebApp\\\"); log = LoggerFactory.getLogger();"}
{"url": "327102", "code": "public void setLogPaths(java.util.Collection<String> logPaths) {         if (logPaths == null) {             this.logPaths = null;             return;         }          this.logPaths = new java.util.ArrayList<String>(logPaths);     }\n", "docstring": "parameter longer used instead specify amazon game lift store log files server process shuts use amazon game lift server api code process ready code specify one directory paths code log parameters code see information href https docs amazon com game lift latest developer guide game lift sdk server api ref html game lift sdk server api ref data pes process server api reference\n", "func_name": "327102", "dfs": "this.logPaths = new java.util.ArrayList<String>(logPaths); return; this.logPaths = null; logPaths == null java.util.Collection<String> logPaths"}
{"url": "327103", "code": "public static boolean isCertPathBuilderException(Throwable cause) {         if (cause == null)             return false;         if (cause instanceof java.security.cert.CertPathBuilderException)             return true;         return isCertPathBuilderException(cause.getCause());     }\n", "docstring": "checks cause instance cert path builder exception\n", "func_name": "327103", "dfs": "return isCertPathBuilderException(cause.getCause()); return true; cause instanceof java.security.cert.CertPathBuilderException return false; cause == null Throwable cause"}
{"url": "327104", "code": "public static <T> void write(final String fileName, Graph<T> g, boolean writeMapping) throws IOException {     File file = new File(fileName.endsWith(\".col\") ? fileName : fileName + \".col\");     Map<Node<T>, Long> node2id = new LinkedHashMap<>();     long i = 1;     for (Node<T> node : g.nodes()) {       node2id.put(node, i++);     }      StringBuilder sb = new StringBuilder(\"p edge \");     Set<Pair<Node<T>, Node<T>>> edges = new LinkedHashSet<>();     Set<Node<T>> doneNodes = new LinkedHashSet<>();     for (Node<T> d : g.nodes()) {       for (Node<T> n : d.neighbours()) {         if (!doneNodes.contains(n)) {           edges.add(new Pair<>(d, n));         }       }       doneNodes.add(d);     }     sb.append(node2id.size()).append(\" \").append(edges.size()).append(System.lineSeparator());      for (Pair<Node<T>, Node<T>> edge : edges) {       sb.append(\"e \").append(node2id.get(edge.first())).append(\" \").append(node2id.get(edge.second())).append(System.lineSeparator());     }      try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))) {       writer.append(sb);       writer.flush();     }     if (writeMapping) {       String mappingFileName = (fileName.endsWith(\".col\") ? fileName.substring(0, fileName.length() - 4) : fileName) + \".map\";       writeMapping(new File(mappingFileName), node2id);     }   }\n", "docstring": "writes given graph internal data structure imacs file\n", "func_name": "327104", "dfs": "writeMapping writeMapping(new File(mappingFileName),node2id); String mappingFileName = (fileName.endsWith(\\\".col\\\")? fileName.substring(0,fileName.length() - 4): fileName) + \\\".map\\\"; writer.flush(); writer.append(sb); sb.append(\\\"e \\\").append(node2id.get(edge.first())).append(\\\" \\\").append(node2id.get(edge.second())).append(System.lineSeparator()); edges Pair<Node<T>,Node<T>> edge sb.append(node2id.size()).append(\\\" \\\").append(edges.size()).append(System.lineSeparator()); doneNodes.add(d); edges.add(new Pair<>(d,n)); !doneNodes.contains(n) d.neighbours() Node<T> n g.nodes() Node<T> d Set<Node<T>> doneNodes = new LinkedHashSet<>(); Set<Pair<Node<T>,Node<T>>> edges = new LinkedHashSet<>(); StringBuilder sb = new StringBuilder(\\\"p edge \\\"); node2id.put(node,i++); g.nodes() Node<T> node long i = 1; Map<Node<T>,Long> node2id = new LinkedHashMap<>(); File file = new File(fileName.endsWith(\\\".col\\\")? fileName: fileName + \\\".col\\\"); boolean writeMapping Graph<T> g final String fileName"}
{"url": "327105", "code": "private void gibbs(int K, float alpha, float beta) {          this.K = K;          this.alpha = alpha;          this.beta = beta;            // init sampler statistics          if (SAMPLE_LAG > 0) {              thetasum = new float[documents.length][K];              phisum = new float[K][V];              numstats = 0;          }            // initial state of the Markov chain:          initialState(K);            System.out.println(\"Sampling \" + ITERATIONS              + \" iterations with burn-in of \" + BURN_IN + \" (B/S=\"              + THIN_INTERVAL + \").\");            for (int i = 0; i < ITERATIONS; i++) {                // for all z_i              for (int m = 0; m < z.length; m++) {                  for (int n = 0; n < z[m].length; n++) {                        // (z_i = z[m][n])                      // sample from p(z_i|z_-i, w)                      int topic = sampleFullConditional(m, n);                      z[m][n] = topic;                  }              }                if ((i < BURN_IN) && (i % THIN_INTERVAL == 0)) {                  System.out.print(\"B\");                  dispcol++;              }              // display progress              if ((i > BURN_IN) && (i % THIN_INTERVAL == 0)) {                  System.out.print(\"S\");                  dispcol++;              }              // get statistics after burn-in              if ((i > BURN_IN) && (SAMPLE_LAG > 0) && (i % SAMPLE_LAG == 0)) {                  updateParams();                  System.out.print(\"|\");                  if (i % THIN_INTERVAL != 0)                      dispcol++;              }              if (dispcol >= 100) {                  System.out.println();                  dispcol = 0;              }          }      }\n", "docstring": "main method select initial state repeat large number times select element update conditional elements appropriate output summary run\n", "func_name": "327105", "dfs": "this.beta = beta; this.alpha = alpha; this.K = K; float beta float alpha int K"}
{"url": "327106", "code": "@Override   public String requestDepositAddress(Currency currency, String... arguments) throws IOException {      final BitsoDepositAddress response = getBitsoBitcoinDepositAddress();     return response.getDepositAddress();   }\n", "docstring": "returns currently set deposit address generate address repeated calls return address\n", "func_name": "327106", "dfs": "return response.getDepositAddress(); final BitsoDepositAddress response = getBitsoBitcoinDepositAddress(); String arguments Currency currency"}
{"url": "327107", "code": "public void marshall(GetCampaignRequest getCampaignRequest, ProtocolMarshaller protocolMarshaller) {          if (getCampaignRequest == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(getCampaignRequest.getApplicationId(), APPLICATIONID_BINDING);             protocolMarshaller.marshall(getCampaignRequest.getCampaignId(), CAMPAIGNID_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327107", "dfs": "protocolMarshaller.marshall(getCampaignRequest.getCampaignId(),CAMPAIGNID_BINDING); protocolMarshaller.marshall(getCampaignRequest.getApplicationId(),APPLICATIONID_BINDING); throw new SdkClientException(\\\"Invalid argument passed to marshall(...)\\\"); getCampaignRequest == null ProtocolMarshaller protocolMarshaller GetCampaignRequest getCampaignRequest"}
{"url": "327108", "code": "public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {   UserDetails user = registeredUsers.get(id);    if (user == null) {    throw new UsernameNotFoundException(id);   }    return user;  }\n", "docstring": "implementation\n", "func_name": "327108", "dfs": "return user; throw new UsernameNotFoundException(id); user == null UserDetails user = registeredUsers.get(id); String id"}
{"url": "327109", "code": "protected Model getModel(EnforcerRuleHelper helper) throws EnforcerRuleException     {         MavenProject project = getMavenProject(helper);         Model model;         Reader reader = null;         try {             reader = new FileReader(project.getFile());             MavenXpp3Reader xpp3Reader = new MavenXpp3Reader();             model = xpp3Reader.read(reader);         } catch (Exception e) {             throw new EnforcerRuleException(\"Failed to read pom file [\" + project.getFile() + \"]\", e);         } finally {             if (reader != null) {                 try {                     reader.close();                 } catch (Exception ee) {                     throw new EnforcerRuleException(\"Failed to close stream after reading pom file [\"                         + project.getFile() + \"]\", ee);                 }             }         }         return model;     }\n", "docstring": "maven model present project code pom xml non resolved\n", "func_name": "327109", "dfs": "return model;  throw new EnforcerRuleException(\\\"Failed to read pom file [\\\" + project.getFile() + \\\"]\\\",e); Exception e model = xpp3Reader.read(reader); MavenXpp3Reader xpp3Reader = new MavenXpp3Reader(); reader = new FileReader(project.getFile()); Reader reader = null; Model model; MavenProject project = getMavenProject(helper); EnforcerRuleHelper helper"}
{"url": "327110", "code": "protected Object getInstantiatedClass(String query) {         if (query.equals(Constants.ROBOTIUM_SOLO)) {             return solo;         } else if (query.equals(Constants.REMOTE_TEST_CLASS)) {             return testClass;         }         return null;     }\n", "docstring": "get instantiated solo requested\n", "func_name": "327110", "dfs": "return null; return testClass; query.equals(Constants.REMOTE_TEST_CLASS) return solo; query.equals(Constants.ROBOTIUM_SOLO) String query"}
{"url": "327111", "code": "public static Bbox scale(Bbox bbox, double factor) {   if (factor > 0) {    double scaledWidth = bbox.getWidth() * factor;    double scaledHeight = bbox.getHeight() * factor;    Coordinate center = getCenterPoint(bbox);    return new Bbox(center.getX() - scaledWidth / 2, center.getY() - scaledHeight / 2, scaledWidth,      scaledHeight);   }   throw new IllegalArgumentException(\"Scale factor must always be strictly positive.\");  }\n", "docstring": "return bounding box center position scaled specified factor\n", "func_name": "327111", "dfs": "throw new IllegalArgumentException(\\\"Scale factor must always be strictly positive.\\\"); return new Bbox(center.getX() - scaledWidth / 2,center.getY() - scaledHeight / 2,scaledWidth,scaledHeight); Coordinate center = getCenterPoint(bbox); double scaledHeight = bbox.getHeight() * factor; double scaledWidth = bbox.getWidth() * factor; factor > 0 double factor Bbox bbox"}
{"url": "327112", "code": "public String convertPTD1XPBASEToString(EDataType eDataType, Object instanceValue) {   return instanceValue == null ? null : instanceValue.toString();  }\n", "docstring": "begin user doc end user doc\n", "func_name": "327112", "dfs": "return instanceValue == null? null: instanceValue.toString(); Object instanceValue EDataType eDataType"}
{"url": "327113", "code": "public Any execute(DeviceImpl device, Any in_any) throws DevFailed  {   Util.out4.println(\"SetLoggingLevelCmd::execute(): arrived\");          DevVarLongStringArray dvlsa = null;   try {       dvlsa = extract_DevVarLongStringArray(in_any);   }   catch (DevFailed df) {    Util.out3.println(\"SetLoggingLevelCmd::execute() --> Wrong argument type\");    Except.re_throw_exception(df,                                 \"API_IncompatibleCmdArgumentType\",                                 \"Imcompatible command argument type, expected type is : DevVarLongStringArray\",                                 \"SetLoggingLevelCmd.execute\");   }          Logging.instance().set_logging_level(dvlsa);          return Util.return_empty_any(\"SetLoggingLevel\");  }\n", "docstring": "executes set logging level tango command\n", "func_name": "327113", "dfs": "return Util.return_empty_any(\\\"SetLoggingLevel\\\"); Logging.instance().set_logging_level(dvlsa); Except.re_throw_exception(df,\\\"API_IncompatibleCmdArgumentType\\\",\\\"Imcompatible command argument type, expected type is : DevVarLongStringArray\\\",\\\"SetLoggingLevelCmd.execute\\\"); Util.out3.println(\\\"SetLoggingLevelCmd::execute() --> Wrong argument type\\\"); DevFailed df dvlsa = extract_DevVarLongStringArray(in_any); DevVarLongStringArray dvlsa = null; Util.out4.println(\\\"SetLoggingLevelCmd::execute(): arrived\\\"); Any in_any DeviceImpl device"}
{"url": "327114", "code": "@Nonnull     public BugInstance addSuperclass(PreorderVisitor visitor) {         String className = ClassName.toDottedClassName(visitor.getSuperclassName());         addClass(className);         return this;     }\n", "docstring": "add class annotation superclass class visitor currently visiting\n", "func_name": "327114", "dfs": "return this; addClass(className); String className = ClassName.toDottedClassName(visitor.getSuperclassName()); PreorderVisitor visitor"}
{"url": "327115", "code": "public static <X> TypeInformation<X> getForClass(Class<X> clazz) {   final ArrayList<Type> typeHierarchy = new ArrayList<>();   typeHierarchy.add(clazz);   return new TypeExtractor().privateGetForClass(clazz, typeHierarchy);  }\n", "docstring": "creates type information given class integer string jos\n", "func_name": "327115", "dfs": "return new TypeExtractor().privateGetForClass(clazz,typeHierarchy); typeHierarchy.add(clazz); final ArrayList<Type> typeHierarchy = new ArrayList<>(); Class<X> clazz"}
{"url": "327116", "code": "public NodeSchema toTVEAndFixColumns(Map<String, Pair<String, Integer>> nameMap) {       final NodeSchema ns = copyAndReplaceWithTVE();    // First convert all non-TVE expressions to TVE in a copy        m_columns.clear();        m_columnsMapHelper.clear();        for(int indx = 0; indx < ns.size(); ++indx) {    // then update columns            final SchemaColumn sc = ns.getColumn(indx);            assert(sc.getExpression() instanceof TupleValueExpression);            if(nameMap.containsKey(sc.getColumnName())) {                final String newColName = nameMap.get(sc.getColumnName()).getFirst();                sc.reset(sc.getTableName(), sc.getTableAlias(), newColName, sc.getColumnAlias());                sc.setDifferentiator(indx);                TupleValueExpression exp = (TupleValueExpression) sc.getExpression();                exp.setColumnIndex(indx);                exp.setColumnName(newColName);                exp.setDifferentiator(indx);            }        }        for(SchemaColumn sc : ns) {            addColumn(sc);        }        return this;     }\n", "docstring": "pre columns map param\n", "func_name": "327116", "dfs": "final NodeSchema ns = copyAndReplaceWithTVE(); Map<String,Pair<String,Integer>> nameMap"}
{"url": "327117", "code": "private Set<Artifact> resolveExecutableDependencies( Artifact executablePomArtifact )         throws MojoExecutionException     {          Set<Artifact> executableDependencies = new LinkedHashSet<>();         try         {             ProjectBuildingRequest buildingRequest = getSession().getProjectBuildingRequest();                          MavenProject executableProject =                 this.projectBuilder.build( executablePomArtifact, buildingRequest ).getProject();              for ( ArtifactResult artifactResult : dependencyResolver.resolveDependencies( buildingRequest, executableProject.getModel(), null ) )             {                 executableDependencies.add( artifactResult.getArtifact() );             }         }         catch ( Exception ex )         {             throw new MojoExecutionException( \"Encountered problems resolving dependencies of the executable \"                 + \"in preparation for its execution.\", ex );         }          return executableDependencies;     }\n", "docstring": "resolve executable dependencies specified project\n", "func_name": "327117", "dfs": "return executableDependencies; throw new MojoExecutionException(\\\"Encountered problems resolving dependencies of the executable \\\" + \\\"in preparation for its execution.\\\",ex); Exception ex executableDependencies.add(artifactResult.getArtifact()); dependencyResolver.resolveDependencies(buildingRequest,executableProject.getModel(),null) ArtifactResult artifactResult MavenProject executableProject = this.projectBuilder.build(executablePomArtifact,buildingRequest).getProject(); ProjectBuildingRequest buildingRequest = getSession().getProjectBuildingRequest(); Set<Artifact> executableDependencies = new LinkedHashSet<>(); Artifact executablePomArtifact"}
{"url": "327118", "code": "public static Map<String, String> filterProperties(Properties props, String prefix, boolean removePrefix) {    List<String> excludedProperties = Collections.emptyList();   return filterProperties(props, prefix, removePrefix, excludedProperties);  } public static Map<String, String> filterProperties(Properties props, String prefix, boolean removePrefix,    List<String> excludedProperties) {    Map<String, String> filteredProps = new HashMap<>();   Set<Entry<Object, Object>> entrySet = props.entrySet();   for (Entry<Object, Object> propEntry : entrySet) {    String key = (String) propEntry.getKey();    if (key.startsWith(prefix)) {      String newKey = key;     if (removePrefix) {      newKey = key.substring(prefix.length());     }     if (!excludedProperties.contains(key)) {      filteredProps.put(newKey, (String) propEntry.getValue());     } else {      if (LOGGER.isWarnEnabled()) {       LOGGER.warn(\"The property '\" + key + \"' has been excluded.\");      }     }    }   }    return filteredProps;  }\n", "docstring": "filters properties file using prefix given parameter filters properties file using prefix given parameter\n", "func_name": "327118", "dfs": "return filterProperties(props,prefix,removePrefix,excludedProperties); List<String> excludedProperties = Collections.emptyList(); boolean removePrefix String prefix Properties props return filteredProps; LOGGER.warn(\\\"The property '\\\" + key + \\\"' has been excluded.\\\"); LOGGER.isWarnEnabled() !excludedProperties.contains(key) newKey = key.substring(prefix.length()); removePrefix String newKey = key; filteredProps.put(newKey,(String)propEntry.getValue()); key.startsWith(prefix) String key = (String)propEntry.getKey(); entrySet Entry<Object,Object> propEntry Set<Entry<Object,Object>> entrySet = props.entrySet(); Map<String,String> filteredProps = new HashMap<>(); List<String> excludedProperties boolean removePrefix String prefix Properties props"}
{"url": "327119", "code": "private static String calculateMessageBodyMd5(String messageBody) {         if (log.isDebugEnabled()) {             log.debug(\"Message body: \" + messageBody);         }         byte[] expectedMd5;         try {             expectedMd5 = Md5Utils.computeMD5Hash(messageBody.getBytes(UTF8));         } catch (Exception e) {             throw new AmazonClientException(\"Unable to calculate the MD5 hash of the message body. \" + e.getMessage(),                     e);         }         String expectedMd5Hex = BinaryUtils.toHex(expectedMd5);         if (log.isDebugEnabled()) {             log.debug(\"Expected  MD5 of message body: \" + expectedMd5Hex);         }         return expectedMd5Hex;     }\n", "docstring": "returns hex encoded hash string given message body\n", "func_name": "327119", "dfs": "return expectedMd5Hex; log.debug(\\\"Expected MD5 of message body: \\\" + expectedMd5Hex); log.isDebugEnabled() String expectedMd5Hex = BinaryUtils.toHex(expectedMd5); throw new AmazonClientException(\\\"Unable to calculate the MD5 hash of the message body. \\\" + e.getMessage(),e); Exception e expectedMd5 = Md5Utils.computeMD5Hash(messageBody.getBytes(UTF8)); byte[] expectedMd5; log.debug(\\\"Message body: \\\" + messageBody); log.isDebugEnabled() String messageBody"}
{"url": "327120", "code": "public void handleSimpleCORS(final HttpServletRequest request,              final HttpServletResponse response, final FilterChain filterChain)              throws IOException, ServletException {          CORSFilter.CORSRequestType requestType =                  checkRequestType(request);          if (!(requestType == CORSFilter.CORSRequestType.SIMPLE          || requestType == CORSFilter.CORSRequestType.ACTUAL)) {              String message =                      \"Expects a HttpServletRequest object of type \"                              + CORSFilter.CORSRequestType.SIMPLE                              + \" or \"                              + CORSFilter.CORSRequestType.ACTUAL;              throw new IllegalArgumentException(message);          }            final String origin =                  request.getHeader(CORSFilter.REQUEST_HEADER_ORIGIN);          final String method = request.getMethod();            // Section 6.1.2          if (!isOriginAllowed(origin)) {              handleInvalidCORS(request, response, filterChain);              return;          }            if (!allowedHttpMethods.contains(method)) {              handleInvalidCORS(request, response, filterChain);              return;          }            // Section 6.1.3          // Add a single Access-Control-Allow-Origin header.          if (anyOriginAllowed && !supportsCredentials) {              // If resource doesn't support credentials and if any origin is              // allowed              // to make CORS request, return header with '*'.              response.addHeader(                      CORSFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN, \"*\");          } else {              // If the resource supports credentials add a single              // Access-Control-Allow-Origin header, with the value of the Origin              // header as value.              response.addHeader(                      CORSFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,                      origin);          }          // Section 6.1.3          // If the resource supports credentials, add a single          // Access-Control-Allow-Credentials header with the case-sensitive          // string \"true\" as value.          if (supportsCredentials) {              response.addHeader(                      CORSFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,                      \"true\");          }            // Section 6.1.4          // If the list of exposed headers is not empty add one or more          // Access-Control-Expose-Headers headers, with as values the header          // field names given in the list of exposed headers.          if ((exposedHeaders != null) && (exposedHeaders.size() > 0)) {              String exposedHeadersString = join(exposedHeaders, \",\");              response.addHeader(                      CORSFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS,                      exposedHeadersString);          }            // Forward the request down the filter chain.          filterChain.doFilter(request, response);      }\n", "docstring": "handles cor request type link cor request type simple\n", "func_name": "327120", "dfs": "final String method = request.getMethod(); final String origin = request.getHeader(CORSFilter.REQUEST_HEADER_ORIGIN); throw new IllegalArgumentException(message); String message = \\\"Expects a HttpServletRequest object of type \\\" + CORSFilter.CORSRequestType.SIMPLE + \\\" or \\\" + CORSFilter.CORSRequestType.ACTUAL; !(requestType == CORSFilter.CORSRequestType.SIMPLE || requestType == CORSFilter.CORSRequestType.ACTUAL) CORSFilter.CORSRequestType requestType = checkRequestType(request); final FilterChain filterChain final HttpServletResponse response final HttpServletRequest request"}
{"url": "327121", "code": "@SuppressWarnings(\"deprecation\")     @RequestMapping(value = \"/api/backup\", method = RequestMethod.GET)     public     @ResponseBody     String getBackup(Model model, HttpServletResponse response) throws Exception {         response.addHeader(\"Content-Disposition\", \"attachment; filename=backup.json\");         response.setContentType(\"application/json\");          Backup backup = BackupService.getInstance().getBackupData();         ObjectMapper objectMapper = new ObjectMapper();         ObjectWriter writer = objectMapper.writerWithDefaultPrettyPrinter();          return writer.withView(ViewFilters.Default.class).writeValueAsString(backup);     }\n", "docstring": "get backup data\n", "func_name": "327121", "dfs": "return writer.withView().writeValueAsString(backup); ObjectWriter writer = objectMapper.writerWithDefaultPrettyPrinter(); ObjectMapper objectMapper = new ObjectMapper(); Backup backup = BackupService.getInstance().getBackupData(); response.setContentType(\\\"application/json\\\"); response.addHeader(\\\"Content-Disposition\\\",\\\"attachment; filename=backup.json\\\"); HttpServletResponse response Model model"}
{"url": "327122", "code": "public int indexOfValue(int value) {         for (int i = 0; i < mSize; i++)             if (mValues[i] == value)                 return i;          return -1;     }\n", "docstring": "returns index\n", "func_name": "327122", "dfs": "return -1; i < mSize mValues[i] == value return i; i++ int i = 0 int value"}
{"url": "327123", "code": "public float getScalarFloat(StructureMembers.Member m) {     Array data = getArray(m);     return data.getFloat(Index.scalarIndexImmutable);   }\n", "docstring": "get member data type\n", "func_name": "327123", "dfs": "return data.getFloat(Index.scalarIndexImmutable); Array data = getArray(m); StructureMembers.Member m"}
{"url": "327124", "code": "protected void warpImageTaylor(GrayF32 before, GrayF32 flowX , GrayF32 flowY , GrayF32 after) {   interp.setBorder(FactoryImageBorder.single(before.getImageType().getImageClass(), BorderType.EXTENDED));   interp.setImage(before);    for( int y = 0; y < before.height; y++ ) {    int pixelIndex = y*before.width;    for (int x = 0; x < before.width; x++, pixelIndex++ ) {     float u = flowX.data[pixelIndex];     float v = flowY.data[pixelIndex];      float wx = x + u;     float wy = y + v;      after.data[pixelIndex] = interp.get(wx, wy);    }   }  }\n", "docstring": "takes flow previous lower resolution layer uses initialize flow current layer adjusts change image scale\n", "func_name": "327124", "dfs": "y < before.height x < before.width after.data[pixelIndex] = interp.get(wx,wy); float wy = y + v; float wx = x + u; float v = flowY.data[pixelIndex]; float u = flowX.data[pixelIndex]; pixelIndex++ x++ int x = 0 int pixelIndex = y * before.width; y++ int y = 0 interp.setImage(before); interp.setBorder(FactoryImageBorder.single(before.getImageType().getImageClass(),BorderType.EXTENDED)); GrayF32 after GrayF32 flowY GrayF32 flowX GrayF32 before"}
{"url": "327125", "code": "public static NodeList xpathNodeList(Node document, String xpathExpression, Map<String, String> namespaceMapping) throws XPathException,                 MarshallingException     {         return (NodeList) executeXPath(document, xpathExpression, namespaceMapping, XPathConstants.NODESET);     } public static NodeList xpathNodeList(Node document, XPathExpression xpathExpression) throws XPathException, MarshallingException     {         return (NodeList) executeXPath(document, xpathExpression, XPathConstants.NODESET);     }\n", "docstring": "runs given path returns runs given path returns\n", "func_name": "327125", "dfs": "return (NodeList)executeXPath(document,xpathExpression,namespaceMapping,XPathConstants.NODESET); Map<String,String> namespaceMapping String xpathExpression Node document return (NodeList)executeXPath(document,xpathExpression,XPathConstants.NODESET); XPathExpression xpathExpression Node document"}
{"url": "327126", "code": "protected boolean getBoolean(String key, boolean defaultValue) {          try {              return getConfig().getBoolean(key, defaultValue);          } catch (ConversionException e) {              logConversionException(key, e);          }          return defaultValue;      }\n", "docstring": "gets code given configuration key default value returned key exist code\n", "func_name": "327126", "dfs": "return defaultValue; logConversionException(key,e); ConversionException e return getConfig().getBoolean(key,defaultValue); boolean defaultValue String key"}
{"url": "327127", "code": "@Override  public Connection getConnection() {   try {    String jdbcUrl = props.get(PROPS_JDBC_URL);    String jdbcUser = props.get(PROPS_JDBC_USER);    String jdbcPassword = props.get(PROPS_JDBC_PASSWORD);     Connection connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword);     String schema = getSchema();    if (schema != null) {     connection.setSchema(schema);    }    connection.setAutoCommit(getAutoCommit());    connection.setReadOnly(getReadOnly());    int transactionIsolation = getTransactionIsolation();    if (transactionIsolation > 0) {     connection.setTransactionIsolation(transactionIsolation);    }    return connection;   } catch (SQLException ex) {    ex.printStackTrace();    return null;   }  }\n", "docstring": "inherit doc\n", "func_name": "327127", "dfs": "return connection; connection.setTransactionIsolation(transactionIsolation); transactionIsolation > 0 int transactionIsolation = getTransactionIsolation(); connection.setReadOnly(getReadOnly()); connection.setAutoCommit(getAutoCommit()); connection.setSchema(schema); schema != null String schema = getSchema(); Connection connection = DriverManager.getConnection(jdbcUrl,jdbcUser,jdbcPassword); String jdbcPassword = props.get(PROPS_JDBC_PASSWORD); String jdbcUser = props.get(PROPS_JDBC_USER); String jdbcUrl = props.get(PROPS_JDBC_URL);"}
{"url": "327128", "code": "public AnnotationValueImpl addAnnotationValue(String name, Object value) {         AnnotationValueImpl annotationValue = new AnnotationValueImpl(value);          addAnnotationValue(name, annotationValue);          return annotationValue;     } public AnnotationValueImpl addAnnotationValue(String name, String enumClassName, String enumName) {         AnnotationValueImpl annotationValue = new AnnotationValueImpl(enumClassName, enumName);          addAnnotationValue(name, annotationValue);          return annotationValue;     }\n", "docstring": "base value enumeration class name enumeration literal value\n", "func_name": "327128", "dfs": "return annotationValue; addAnnotationValue(name,annotationValue); AnnotationValueImpl annotationValue = new AnnotationValueImpl(value); Object value String name return annotationValue; addAnnotationValue(name,annotationValue); AnnotationValueImpl annotationValue = new AnnotationValueImpl(enumClassName,enumName); String enumName String enumClassName String name"}
{"url": "327129", "code": "private void doText(Element received, Element source) {         if (log.isDebugEnabled()) {             log.debug(\"Validating node value for element: \" + received.getLocalName());         }          String receivedText = DomUtils.getTextValue(received);         String sourceText = DomUtils.getTextValue(source);          if (receivedText != null) {             Assert.isTrue(sourceText != null,                     ValidationUtils.buildValueMismatchErrorMessage(\"Node value not equal for element '\"                             + received.getLocalName() + \"'\", null, receivedText.trim()));              Assert.isTrue(receivedText.trim().equals(sourceText.trim()),                     ValidationUtils.buildValueMismatchErrorMessage(\"Node value not equal for element '\"                             + received.getLocalName() + \"'\", sourceText.trim(),                             receivedText.trim()));         } else {             Assert.isTrue(sourceText == null,                     ValidationUtils.buildValueMismatchErrorMessage(\"Node value not equal for element '\"                             + received.getLocalName() + \"'\", sourceText.trim(), null));         }          if (log.isDebugEnabled()) {             log.debug(\"Node value '\" + receivedText.trim() + \"': OK\");         }     }\n", "docstring": "handle text node validation\n", "func_name": "327129", "dfs": "log.isDebugEnabled() log.debug(\\\"Node value '\\\" + receivedText.trim() + \\\"': OK\\\"); Assert.isTrue(sourceText == null,ValidationUtils.buildValueMismatchErrorMessage(\\\"Node value not equal for element '\\\" + received.getLocalName() + \\\"'\\\",sourceText.trim(),null)); Assert.isTrue(receivedText.trim().equals(sourceText.trim()),ValidationUtils.buildValueMismatchErrorMessage(\\\"Node value not equal for element '\\\" + received.getLocalName() + \\\"'\\\",sourceText.trim(),receivedText.trim())); Assert.isTrue(sourceText != null,ValidationUtils.buildValueMismatchErrorMessage(\\\"Node value not equal for element '\\\" + received.getLocalName() + \\\"'\\\",null,receivedText.trim())); receivedText != null String sourceText = DomUtils.getTextValue(source); String receivedText = DomUtils.getTextValue(received); log.debug(\\\"Validating node value for element: \\\" + received.getLocalName()); log.isDebugEnabled() Element source Element received"}
{"url": "327130", "code": "@SuppressWarnings(\"unchecked\")  public JSONNavi<T> array() {   if (failure)    return this;   if (current == null && readonly)    failure(\"Can not create Array child in readonly\", null);   if (current != null) {    if (isArray())     return this;    if (isObject())     failure(\"can not use Object feature on Array.\", null);    failure(\"Can not use current possition as Object\", null);   } else {    current = mapper.createArray();   }   if (root == null)    root = (T) current;   else    store();   return this;  }\n", "docstring": "set current value json array also skip call arrays create automatically\n", "func_name": "327130", "dfs": "return this; store(); root = (T)current; current = mapper.createArray(); root == null failure(\\\"Can not use current possition as Object\\\",null); failure(\\\"can not use Object feature on Array.\\\",null); isObject() return this; isArray() current != null failure(\\\"Can not create Array child in readonly\\\",null); current == null && readonly return this; failure"}
{"url": "327131", "code": "public void init(ContextConfig config) {          this.config = config;                    PropertyMap properties = config.getProperties();          String edenSpace = properties.getString(\"EdenSpace\");          if (edenSpace != null) {              this.setEdenMemoryPool(edenSpace);          }                    String survivorSpace = properties.getString(\"SurvivorSpace\");          if (survivorSpace != null) {              this.setSurvivorMemoryPool(survivorSpace);          }                    String tenuredGen = properties.getString(\"TenuredGen\");          if (tenuredGen != null) {              this.setTenuredMemoryPool(tenuredGen);          }                    String permGen = properties.getString(\"PermGen\");          if (permGen != null) {              this.setPermGenMemoryPool(permGen);          }                    String youngCollector = properties.getString(\"YoungCollector\");          if (youngCollector != null) {              this.setYoungCollector(youngCollector);          }                    String tenuredCollector = properties.getString(\"TenuredCollector\");          if (tenuredCollector != null) {              this.setTenuredCollector(tenuredCollector);          }                    // enable contention          getThreadMXBean().setThreadCpuTimeEnabled(true);          getThreadMXBean().setThreadContentionMonitoringEnabled(true);                    // load the settings if possible          loadJMXSettings();      }\n", "docstring": "initialize context instance following configuration parameters supported\n", "func_name": "327131", "dfs": "tenuredCollector != null this.setTenuredCollector(tenuredCollector); String tenuredCollector = properties.getString(\\\"TenuredCollector\\\"); this.setYoungCollector(youngCollector); youngCollector != null String youngCollector = properties.getString(\\\"YoungCollector\\\"); this.setPermGenMemoryPool(permGen); permGen != null String permGen = properties.getString(\\\"PermGen\\\"); this.setTenuredMemoryPool(tenuredGen); tenuredGen != null String tenuredGen = properties.getString(\\\"TenuredGen\\\"); this.setSurvivorMemoryPool(survivorSpace); survivorSpace != null String survivorSpace = properties.getString(\\\"SurvivorSpace\\\"); this.setEdenMemoryPool(edenSpace); edenSpace != null String edenSpace = properties.getString(\\\"EdenSpace\\\"); PropertyMap properties = config.getProperties(); this.config = config; ContextConfig config"}
{"url": "327132", "code": "public static ChaincodeCollectionConfiguration fromYamlFile(File configFile) throws InvalidArgumentException, IOException, ChaincodeCollectionConfigurationException {         return fromFile(configFile, false);     }\n", "docstring": "creates chain code collection configuration instance configured details supplied yam file\n", "func_name": "327132", "dfs": "return fromFile(configFile,false); File configFile"}
{"url": "327133", "code": "public static String contentShowTagAction(         I_CmsXmlContentContainer container,         PageContext context,         String element,         Locale locale,         boolean escape) {          // get the current users OpenCms context         CmsObject cms = CmsFlexController.getCmsObject(context.getRequest());          // get loaded content from content container         I_CmsXmlDocument xmlContent = container.getXmlDocument();          if (CmsStringUtil.isEmpty(element)) {             element = container.getXmlDocumentElement();         } else {             element = CmsXmlUtils.concatXpath(container.getXmlDocumentElement(), element);         }          String content;         if (CmsMacroResolver.isMacro(element)) {             // this is a macro, initialize a macro resolver             String resourcename = CmsJspTagResourceLoad.getResourceName(cms, container);             CmsMacroResolver resolver = CmsMacroResolver.newInstance().setCmsObject(cms).setJspPageContext(                 context).setResourceName(resourcename).setKeepEmptyMacros(true);             // resolve the macro             content = resolver.resolveMacros(element);         } else if (xmlContent == null) {             // no XML content- no output             content = null;         } else {              // determine the locale to display             if (locale == null) {                 // no locale was set, use default from parent tag (usually \"contentload\")                 locale = container.getXmlDocumentLocale();             }             // now get the content element value to display              if (xmlContent.hasValue(element, locale)) {                 try {                     // read the element from the content                     content = xmlContent.getStringValue(cms, element, locale);                 } catch (Exception e) {                     LOG.error(Messages.get().getBundle().key(Messages.LOG_ERR_CONTENT_SHOW_1, element), e);                     content = null;                 }             } else {                 content = null;             }              // make sure that no null String is returned             if (content == null) {                 content = CmsMessages.formatUnknownKey(element);             }             if (escape) {                 // HTML escape the value                 content = CmsEncoder.escapeHtml(content);             }         }          return content;     }\n", "docstring": "internal action method show element xml content document\n", "func_name": "327133", "dfs": "boolean escape Locale locale String element PageContext context I_CmsXmlContentContainer container"}
{"url": "327134", "code": "@Override  public long writeBooleans(boolean value, long count) {   if (count < 0L) throw new IllegalArgumentException(\"negative count\");   if (position + count > size) throw new EndOfBitStreamException();   int boundary = BitBoundary.BYTE.bitsFrom(position);   int bits = value ? -1 : 0;   if (count <= boundary) return write(bits, (int) count);    long c = write(bits, boundary);   long d = (count - c) >> 3;   fillBytes(bits, d);   d <<= 3;   position += d;   c += d;   c += write(bits, (int) (count - c));    return c;  }\n", "docstring": "bit writer methods\n", "func_name": "327134", "dfs": "return c; c += write(bits,(int)(count - c)); c += d; position += d; d <<= 3; fillBytes(bits,d); long d = (count - c) >> 3; long c = write(bits,boundary); return write(bits,(int)count); count <= boundary int bits = value? -1: 0; int boundary = BitBoundary.BYTE.bitsFrom(position); throw new EndOfBitStreamException(); position + count > size throw new IllegalArgumentException(\\\"negative count\\\"); count < 0L long count boolean value"}
{"url": "327135", "code": "private static int[] getUnionForAppendInstrumentationLevel(                                                                int[] oldCounters, int[] newCounters) {          int[] merged = new int[newCounters.length + oldCounters.length];         int i, j, k = -1;          // Copying the Old Counters to the merged array         for (i = 0; i < oldCounters.length; i++) {             merged[i] = oldCounters[i];             k++;         }          // Checking for the duplicate elements         boolean flag = false;         for (i = 0; i < newCounters.length; i++, flag = false) {             for (j = 0; (j < oldCounters.length) && (flag == false); j++) {                 if (newCounters[i] == oldCounters[j]) {                     flag = true; // If the array element is a duplicate then                     // breaking the loop.                 }             }             if (flag == false) {                 k++;                 merged[k] = newCounters[i]; // If the array element is not                 // present, then adding it to the                 // Merged array.             }         }          // Forming an array without duplicates.         int[] final_result = new int[k + 1];         for (i = 0; i <= k; i++)             final_result[i] = merged[i];         return final_result;      }\n", "docstring": "implementation\n", "func_name": "327135", "dfs": "int i,j,k = -1; int[] merged = new int[][]; int[] newCounters int[] oldCounters"}
{"url": "327136", "code": "public CmsFile writeFile(CmsFile resource) throws CmsException {          return getResourceType(resource).writeFile(this, m_securityManager, resource);     }\n", "docstring": "writes resource open cms including content\n", "func_name": "327136", "dfs": "return getResourceType(resource).writeFile(this,m_securityManager,resource); CmsFile resource"}
{"url": "327137", "code": "public String getLastName() {     if (AuthorInfo_Type.featOkTst && ((AuthorInfo_Type)jcasType).casFeat_lastName == null)       jcasType.jcas.throwFeatMissing(\"lastName\", \"de.julielab.jules.types.AuthorInfo\");     return jcasType.ll_cas.ll_getStringValue(addr, ((AuthorInfo_Type)jcasType).casFeatCode_lastName);}\n", "docstring": "get ter lastname gets last name author\n", "func_name": "327137", "dfs": "return jcasType.ll_cas.ll_getStringValue(addr,((AuthorInfo_Type)jcasType).casFeatCode_lastName); jcasType.jcas.throwFeatMissing(\\\"lastName\\\",\\\"de.julielab.jules.types.AuthorInfo\\\"); AuthorInfo_Type.featOkTst && ((AuthorInfo_Type)jcasType).casFeat_lastName == null"}
{"url": "327138", "code": "public static <T> Callable<T> decorate(final Callable<T> callable) {     return new ContextPropagatingCallable<T>(callable);   }\n", "docstring": "decorates callable link context propagating callable making possible access link context within decorated callable\n", "func_name": "327138", "dfs": "return new ContextPropagatingCallable<T>(callable); final Callable<T> callable"}
{"url": "327139", "code": "public static void basicExample001() throws IOException {         final String rawMessage = new StringBuilder(\"BYE sip:bob@127.0.0.1:5060 SIP/2.0\\r\\n\")                 .append(\"Via: SIP/2.0/UDP 127.0.1.1:5061;branch=z9hG4bK-28976-1-7\\r\\n\")                 .append(\"From: alice <sip:alice@127.0.1.1:5061>;tag=28976SIPpTag001\\r\\n\")                 .append(\"To: bob <sip:bob@127.0.0.1:5060>;tag=28972SIPpTag011\\r\\n\")                 .append(\"Call-ID: 1-28976@127.0.1.1\\r\\n\")                 .append(\"CSeq: 2 BYE\\r\\n\")                 .append(\"Contact: sip:alice@127.0.1.1:5061\\r\\n\")                 .append(\"Max-Forwards: 70\\r\\n\")                 .append(\"Subject: Example BYE Message\\r\\n\")                 .append(\"Content-Length: 0\\r\\n\")                 .append(\"\\r\\n\").toString();          // Every object in SIP Lib has a frame-method, which         // will attempt to frame the raw content into that object.         // This is true for SIP messages, SIP header, SIP URIs         // etc etc. All frame-methods are overloaded and accept         // Strings, Buffers and byte-arrays.         final SipMessage msg = SipMessage.frame(rawMessage);          // Once the message has successfully been parsed you         // can access headers etc within the SIP message.         final FromHeader from = msg.getFromHeader();          // All headers that typically are needed for any application, and         // in particular for SIP stacks, have explicit methods and returns         // explicit objects. You may still use the generic getHeader but then         // you will get a generic SIP header back.         final ContactHeader contact = msg.getContactHeader();          // Instead of having to do SipMessage.getMethod().equals(\"BYE\") etc         // the SIP message has many convenience methods for making the code         // more readable, less error prone and less boiler place to write.         if (msg.isBye()) {             System.out.println(\"Yay, this was a BYE message\");         }          if (msg.isRequest()) {             System.out.println(\"Yay, this was SIP request\");         }     }\n", "docstring": "basic example showing parse sip message based string example ones creating raw message typically would read network perhaps file building tool sort\n", "func_name": "327139", "dfs": "final String rawMessage = new StringBuilder(\\\"BYE sip:bob@127.0.0.1:5060"}
{"url": "327140", "code": "boolean matchLevels(List<GridRecord> records) {      // first create a new list     List<LevelCoord> levelList = new ArrayList<LevelCoord>(records.size());     for (GridRecord record : records) {       LevelCoord lc = new LevelCoord(record.getLevel1(), record.getLevel2());       if (!levelList.contains(lc)) {         levelList.add(lc);       }     }      Collections.sort(levelList);     if (positive.equals(\"down\")) {       Collections.reverse(levelList);     }      // gotta equal existing list     return levelList.equals(levels);   }\n", "docstring": "match levels\n", "func_name": "327140", "dfs": "List<GridRecord> records"}
{"url": "327141", "code": "public Observation addComponent(ObservationComponentComponent t) { //3        if (t == null)          return this;        if (this.component == null)          this.component = new ArrayList<ObservationComponentComponent>();        this.component.add(t);        return this;      }\n", "docstring": "syntactic sugar\n", "func_name": "327141", "dfs": "ObservationComponentComponent t"}
{"url": "327143", "code": "public void setTIRID(Integer newTIRID) {   Integer oldTIRID = tirid;   tirid = newTIRID;   if (eNotificationRequired())    eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.INCLUDE_TILE__TIRID, oldTIRID, tirid));  }\n", "docstring": "begin user doc end user doc\n", "func_name": "327143", "dfs": "eNotificationRequired() eNotify(new ENotificationImpl(this,Notification.SET,AfplibPackage.INCLUDE_TILE__TIRID,oldTIRID,tirid)); tirid = newTIRID; Integer oldTIRID = tirid; Integer newTIRID"}
{"url": "327144", "code": "public void prepare(String sql, com.couchbase.lite.internal.database.sqlite.SQLiteStatementInfo outStatementInfo) {         if (sql == null) {             throw new IllegalArgumentException(\"sql must not be null.\");         }          final int cookie = mRecentOperations.beginOperation(\"prepare\", sql, null);         try {             final PreparedStatement statement = acquirePreparedStatement(sql);             try {                 if (outStatementInfo != null) {                     outStatementInfo.numParameters = statement.mNumParameters;                     outStatementInfo.readOnly = statement.mReadOnly;                      final int columnCount = nativeGetColumnCount(                             mConnectionPtr, statement.mStatementPtr);                     if (columnCount == 0) {                         outStatementInfo.columnNames = EMPTY_STRING_ARRAY;                     } else {                         outStatementInfo.columnNames = new String[columnCount];                         for (int i = 0; i < columnCount; i++) {                             outStatementInfo.columnNames[i] = nativeGetColumnName(                                     mConnectionPtr, statement.mStatementPtr, i);                         }                     }                 }             } finally {                 releasePreparedStatement(statement);             }         } catch (RuntimeException ex) {             mRecentOperations.failOperation(cookie, ex);             throw ex;         } finally {             mRecentOperations.endOperation(cookie);         }     }\n", "docstring": "prepares statement execution bind parameters execute method used check syntax errors compilation prior execution statement code statement info argument null provided link com couch base lite internal database lite lite statement info object populated information statement prepared statement makes reference arguments may eventually bound consequently possible cache certain prepared statements select insert update statements statement cache able stored cache later take advantage behavior optimization connection pool provides method acquire connection already given sql statement prepared statement cache ready execution\n", "func_name": "327144", "dfs": "outStatementInfo != null   throw ex; mRecentOperations.failOperation(cookie,ex); RuntimeException ex i < columnCount outStatementInfo.columnNames[i] = nativeGetColumnName(mConnectionPtr,statement.mStatementPtr,i); i++ int i = 0 outStatementInfo.columnNames = new String[][]; outStatementInfo.columnNames = EMPTY_STRING_ARRAY; columnCount == 0 final int columnCount = nativeGetColumnCount(mConnectionPtr,statement.mStatementPtr); outStatementInfo.readOnly = statement.mReadOnly; outStatementInfo.numParameters = statement.mNumParameters; final PreparedStatement statement = acquirePreparedStatement(sql); final int cookie = mRecentOperations.beginOperation(\\\"prepare\\\",sql,null); throw new IllegalArgumentException(\\\"sql must not be null.\\\"); sql == null com.couchbase.lite.internal.database.sqlite.SQLiteStatementInfo outStatementInfo String sql"}
{"url": "327145", "code": "public static ScalarOperation<Double> doubleMultiplicationOp() {   return new ScalarOperation<Double>(new ScalarFunction<Double>() {     @Override    public Double scale(Double a, double b) {     return a * b;    }    }, 1d);  }\n", "docstring": "builds scaling operation doubles multiplying operation factor\n", "func_name": "327145", "dfs": "return new ScalarOperation<Double>(new"}
{"url": "327146", "code": "@Override     public String getMetaZoneDisplayName(String mzID, NameType type) {         if (mzID == null || mzID.length() == 0) {             return null;         }         return loadMetaZoneNames(mzID).getName(type);     }\n", "docstring": "non java doc\n", "func_name": "327146", "dfs": "return loadMetaZoneNames(mzID).getName(type); return null; mzID == null || mzID.length() == 0 NameType type String mzID"}
{"url": "327147", "code": "public static String addTrailingSeparator(String path) {          int l = path.length();         if ((l == 0) || (path.charAt(l - 1) != '/')) {             return path.concat(\"/\");         } else {             return path;         }     }\n", "docstring": "adds trailing separator path required\n", "func_name": "327147", "dfs": "(l == 0) || (path.charAt(l - 1) != '/') return path; return path.concat(\\\"/\\\"); int l = path.length(); String path"}
{"url": "327148", "code": "public int indexOf(Field field)     {         requireNonNull(field, \"field cannot be null\");         Integer index = fieldIndexes.get(field);         checkArgument(index != null, \"Field %s not found\", field);         return index;     }\n", "docstring": "gets index specified field\n", "func_name": "327148", "dfs": "return index; checkArgument(index != null,\\\"Field %s not found\\\",field); Integer index = fieldIndexes.get(field); requireNonNull(field,\\\"field cannot be null\\\"); Field field"}
{"url": "327149", "code": "public String[] resolveParamNames(final Method actionClassMethod) {   MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod);    String[] names = new String[methodParameters.length];    for (int i = 0; i < methodParameters.length; i++) {    names[i] = methodParameters[i].getName();   }    return names;  }\n", "docstring": "returns method parameter names\n", "func_name": "327149", "dfs": "return names; names[i] = methodParameters[i].getName(); i++ i < methodParameters.length int i = 0 String[] names = new String[][]; MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod); final Method actionClassMethod"}
{"url": "327150", "code": "@Nullable   public static List<LbConfig> getChildPolicyFromXdsConfig(LbConfig xdsConfig) {     Map<String, ?> map = xdsConfig.getRawConfigValue();     List<?> rawChildPolicies = getList(map, XDS_CONFIG_CHILD_POLICY_KEY);     if (rawChildPolicies != null) {       return unwrapLoadBalancingConfigList(checkObjectList(rawChildPolicies));     }     return null;   }\n", "docstring": "extracts list child policies load balancer config\n", "func_name": "327150", "dfs": "return null; return unwrapLoadBalancingConfigList(checkObjectList(rawChildPolicies)); rawChildPolicies != null List<?> rawChildPolicies = getList(map,XDS_CONFIG_CHILD_POLICY_KEY); Map<String,?> map = xdsConfig.getRawConfigValue(); LbConfig xdsConfig"}
{"url": "327151", "code": "public HsqlName getSubqueryTableName() {          HsqlName hsqlName = new HsqlName(this, SqlInvariants.SYSTEM_SUBQUERY,                                          false, SchemaObject.TABLE);          hsqlName.schema = SqlInvariants.SYSTEM_SCHEMA_HSQLNAME;          return hsqlName;     }\n", "docstring": "name string different objects serial number\n", "func_name": "327151", "dfs": "return hsqlName; hsqlName.schema = SqlInvariants.SYSTEM_SCHEMA_HSQLNAME; HsqlName hsqlName = new HsqlName(this,SqlInvariants.SYSTEM_SUBQUERY,false,SchemaObject.TABLE);"}
{"url": "327152", "code": "public Observable<Page<RouteFilterInner>> listNextAsync(final String nextPageLink) {         return listNextWithServiceResponseAsync(nextPageLink)             .map(new Func1<ServiceResponse<Page<RouteFilterInner>>, Page<RouteFilterInner>>() {                 @Override                 public Page<RouteFilterInner> call(ServiceResponse<Page<RouteFilterInner>> response) {                     return response.body();                 }             });     }\n", "docstring": "gets route filters subscription\n", "func_name": "327152", "dfs": "return listNextWithServiceResponseAsync(nextPageLink).map(new final String nextPageLink"}
{"url": "327153", "code": "public void marshall(BrokerNodeGroupInfo brokerNodeGroupInfo, ProtocolMarshaller protocolMarshaller) {          if (brokerNodeGroupInfo == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(brokerNodeGroupInfo.getBrokerAZDistribution(), BROKERAZDISTRIBUTION_BINDING);             protocolMarshaller.marshall(brokerNodeGroupInfo.getClientSubnets(), CLIENTSUBNETS_BINDING);             protocolMarshaller.marshall(brokerNodeGroupInfo.getInstanceType(), INSTANCETYPE_BINDING);             protocolMarshaller.marshall(brokerNodeGroupInfo.getSecurityGroups(), SECURITYGROUPS_BINDING);             protocolMarshaller.marshall(brokerNodeGroupInfo.getStorageInfo(), STORAGEINFO_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327153", "dfs": "protocolMarshaller.marshall(brokerNodeGroupInfo.getStorageInfo(),STORAGEINFO_BINDING); protocolMarshaller.marshall(brokerNodeGroupInfo.getSecurityGroups(),SECURITYGROUPS_BINDING); protocolMarshaller.marshall(brokerNodeGroupInfo.getInstanceType(),INSTANCETYPE_BINDING); protocolMarshaller.marshall(brokerNodeGroupInfo.getClientSubnets(),CLIENTSUBNETS_BINDING); protocolMarshaller.marshall(brokerNodeGroupInfo.getBrokerAZDistribution(),BROKERAZDISTRIBUTION_BINDING); throw new SdkClientException(\\\"Invalid argument passed to marshall(...)\\\"); brokerNodeGroupInfo == null ProtocolMarshaller protocolMarshaller BrokerNodeGroupInfo brokerNodeGroupInfo"}
{"url": "327154", "code": "public void marshall(RemoveAttributesRequest removeAttributesRequest, ProtocolMarshaller protocolMarshaller) {          if (removeAttributesRequest == null) {             throw new SdkClientException(\"Invalid argument passed to marshall(...)\");         }          try {             protocolMarshaller.marshall(removeAttributesRequest.getApplicationId(), APPLICATIONID_BINDING);             protocolMarshaller.marshall(removeAttributesRequest.getAttributeType(), ATTRIBUTETYPE_BINDING);             protocolMarshaller.marshall(removeAttributesRequest.getUpdateAttributesRequest(), UPDATEATTRIBUTESREQUEST_BINDING);         } catch (Exception e) {             throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);         }     }\n", "docstring": "marshall given parameter object\n", "func_name": "327154", "dfs": "protocolMarshaller.marshall(removeAttributesRequest.getUpdateAttributesRequest(),UPDATEATTRIBUTESREQUEST_BINDING); protocolMarshaller.marshall(removeAttributesRequest.getAttributeType(),ATTRIBUTETYPE_BINDING); protocolMarshaller.marshall(removeAttributesRequest.getApplicationId(),APPLICATIONID_BINDING); throw new SdkClientException(\\\"Invalid argument passed to marshall(...)\\\"); removeAttributesRequest == null ProtocolMarshaller protocolMarshaller RemoveAttributesRequest removeAttributesRequest"}
{"url": "327155", "code": "public Map<String, T> asMap() {         final Map<String, T> nameToInfoObject = new HashMap<>();         for (final T i : this) {             nameToInfoObject.put(i.getName(), i);         }         return nameToInfoObject;     }\n", "docstring": "get index list map name list item obtained calling code get name list item list item\n", "func_name": "327155", "dfs": "return nameToInfoObject; nameToInfoObject.put(i.getName(),i); this final T i final Map<String,T> nameToInfoObject = new HashMap<>();"}
{"url": "327156", "code": "public static boolean containsNone(String str, char[] invalidChars) {       if (str == null || invalidChars == null) {           return true;       }       int strSize = str.length();       int validSize = invalidChars.length;       for (int i = 0; i < strSize; i++) {           char ch = str.charAt(i);           for (int j = 0; j < validSize; j++) {               if (invalidChars[j] == ch) {                   return false;               }           }       }       return true;   } public static boolean containsNone(String str, String invalidChars) {       if (str == null || invalidChars == null) {           return true;       }       return containsNone(str, invalidChars.toCharArray());   }\n", "docstring": "checks string contain certain characters checks string contain certain characters\n", "func_name": "327156", "dfs": "return true; i < strSize j < validSize invalidChars[j] == ch return false; j++ int j = 0 char ch = str.charAt(i); i++ int i = 0 int validSize = invalidChars.length; int strSize = str.length(); return true; str == null || invalidChars == null char[] invalidChars String str return containsNone(str,invalidChars.toCharArray()); return true; str == null || invalidChars == null String invalidChars String str"}
{"url": "327157", "code": "public SourcedValue getSourced() {         boolean fromCache = true;         int cacheVersion = stampedValue.getStamp();         int latestVersion = parentContainer.getMasterVersion();         String key = parentContainer.getKey();         SourcedValue sourcedValue = null;         if (cacheVersion != latestVersion) {             SourcedValue currentValue = stampedValue.getReference();             SourcedValue newValue = config.getSourcedValue(type, key);              if (stampedValue.compareAndSet(currentValue, newValue, cacheVersion, latestVersion)) {                 sourcedValue = newValue;                 fromCache = false;             }         }         if (fromCache) {             sourcedValue = stampedValue.getReference();         }          if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {             if (sourcedValue != null) {                 Tr.debug(tc, \"get: Key={0}, Value={1}\", key, sourcedValue);             } else {                 Tr.debug(tc, \"get: Key={0} not found\", key);             }         }          return sourcedValue;     }\n", "docstring": "fetch latest version property date resolve latest value inline\n", "func_name": "327157", "dfs": "return sourcedValue; Tr.debug(tc,\\\"get: Key={0} not found\\\",key); sourcedValue != null Tr.debug(tc,\\\"get: Key={0}, Value={1}\\\",key,sourcedValue); sourcedValue = stampedValue.getReference(); sourcedValue = newValue; fromCache = false; stampedValue.compareAndSet(currentValue,newValue,cacheVersion,latestVersion) SourcedValue currentValue = stampedValue.getReference(); SourcedValue newValue = config.getSourcedValue(type,key); TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled() fromCache cacheVersion != latestVersion SourcedValue sourcedValue = null; String key = parentContainer.getKey(); int latestVersion = parentContainer.getMasterVersion(); int cacheVersion = stampedValue.getStamp(); boolean fromCache = true;"}
{"url": "327158", "code": "private static AWSCredentialsProvider getCredentialsProvider(final Properties configProps, final String configPrefix) {   CredentialProvider credentialProviderType;   if (!configProps.containsKey(configPrefix)) {    if (configProps.containsKey(AWSConfigConstants.accessKeyId(configPrefix))     && configProps.containsKey(AWSConfigConstants.secretKey(configPrefix))) {     // if the credential provider type is not specified, but the Access Key ID and Secret Key are given, it will default to BASIC     credentialProviderType = CredentialProvider.BASIC;    } else {     // if the credential provider type is not specified, it will default to AUTO     credentialProviderType = CredentialProvider.AUTO;    }   } else {    credentialProviderType = CredentialProvider.valueOf(configProps.getProperty(configPrefix));   }    switch (credentialProviderType) {    case ENV_VAR:     return new EnvironmentVariableCredentialsProvider();     case SYS_PROP:     return new SystemPropertiesCredentialsProvider();     case PROFILE:     String profileName = configProps.getProperty(       AWSConfigConstants.profileName(configPrefix), null);     String profileConfigPath = configProps.getProperty(       AWSConfigConstants.profilePath(configPrefix), null);     return (profileConfigPath == null)      ? new ProfileCredentialsProvider(profileName)      : new ProfileCredentialsProvider(profileConfigPath, profileName);     case BASIC:     return new AWSCredentialsProvider() {      @Override      public AWSCredentials getCredentials() {       return new BasicAWSCredentials(        configProps.getProperty(AWSConfigConstants.accessKeyId(configPrefix)),        configProps.getProperty(AWSConfigConstants.secretKey(configPrefix)));      }       @Override      public void refresh() {       // do nothing      }     };     case ASSUME_ROLE:     final AWSSecurityTokenService baseCredentials = AWSSecurityTokenServiceClientBuilder.standard()       .withCredentials(getCredentialsProvider(configProps, AWSConfigConstants.roleCredentialsProvider(configPrefix)))       .withRegion(configProps.getProperty(AWSConfigConstants.AWS_REGION))       .build();     return new STSAssumeRoleSessionCredentialsProvider.Builder(       configProps.getProperty(AWSConfigConstants.roleArn(configPrefix)),       configProps.getProperty(AWSConfigConstants.roleSessionName(configPrefix)))       .withExternalId(configProps.getProperty(AWSConfigConstants.externalId(configPrefix)))       .withStsClient(baseCredentials)       .build();     default:    case AUTO:     return new DefaultAWSCredentialsProviderChain();   }  }\n", "docstring": "provider assume role credentials assuming role determined recursively\n", "func_name": "327158", "dfs": "final String configPrefix final Properties configProps"}
{"url": "327159", "code": "public AwsSecurityFindingFilters withThreatIntelIndicatorLastObservedAt(DateFilter... threatIntelIndicatorLastObservedAt) {         if (this.threatIntelIndicatorLastObservedAt == null) {             setThreatIntelIndicatorLastObservedAt(new java.util.ArrayList<DateFilter>(threatIntelIndicatorLastObservedAt.length));         }         for (DateFilter ele : threatIntelIndicatorLastObservedAt) {             this.threatIntelIndicatorLastObservedAt.add(ele);         }         return this;     }\n", "docstring": "date time last observation threat intel indicator note method appends values existing list use link set threat intel indicator last observed java util collection link threat intel indicator last observed java util collection want existing values\n", "func_name": "327159", "dfs": "return this; this.threatIntelIndicatorLastObservedAt.add(ele); setThreatIntelIndicatorLastObservedAt(new java.util.ArrayList<DateFilter>(threatIntelIndicatorLastObservedAt.length)); threatIntelIndicatorLastObservedAt DateFilter ele this.threatIntelIndicatorLastObservedAt == null DateFilter threatIntelIndicatorLastObservedAt"}
{"url": "327160", "code": "private boolean dominates(double point1[], double point2[], int noObjectives) {     int i;     int betterInAnyObjective;      betterInAnyObjective = 0;     for (i = 0; i < noObjectives && point1[i] >= point2[i]; i++) {       if (point1[i] > point2[i]) {         betterInAnyObjective = 1;       }     }      return ((i >= noObjectives) && (betterInAnyObjective > 0));   }\n", "docstring": "returns point dominates points respect first objectives objectives\n", "func_name": "327160", "dfs": "return ((i >= noObjectives) && (betterInAnyObjective > 0)); betterInAnyObjective = 1; point1[i] > point2[i] i++ i < noObjectives && point1[i] >= point2[i] i = 0 betterInAnyObjective = 0; int betterInAnyObjective; int i; int noObjectives double point2 double point1"}
{"url": "327161", "code": "private boolean preValidateAssignedWriter(final ITopicNode topic) {         if (topic.getAssignedWriter(true) == null) {             log.error(String.format(ProcessorConstants.ERROR_NO_WRITER_MSG, topic.getLineNumber(), topic.getText()));             return false;         }          return true;     }\n", "docstring": "checks make sure assigned writer topic valid\n", "func_name": "327161", "dfs": "return true; return false; log.error(String.format(ProcessorConstants.ERROR_NO_WRITER_MSG,topic.getLineNumber(),topic.getText())); topic.getAssignedWriter(true) == null final ITopicNode topic"}
{"url": "327162", "code": "public static void setCookie(HttpServletResponse response, String name,                                  String value, String domain, int maxAge) {         if (value == null) {             value = \"\";         }         Cookie cookie = new Cookie(name, value);         cookie.setMaxAge(maxAge);         if (domain != null && !\"\".equals(domain)) {             cookie.setDomain(domain);         }         cookie.setPath(\"/\");         response.addCookie(cookie);     }\n", "docstring": "https code google com util java source browse trunk utils cookie utils java\n", "func_name": "327162", "dfs": "response.addCookie(cookie); cookie.setPath(\\\"/\\\"); cookie.setDomain(domain); domain != null && !\\\"\\\".equals(domain) cookie.setMaxAge(maxAge); Cookie cookie = new Cookie(name,value); value = \\\"\\\"; value == null int maxAge String domain String value String name HttpServletResponse response"}
{"url": "327163", "code": "private void writeObject(ObjectOutputStream oos) throws IOException {         // Write out the non-transient fields         // (revocationDate, reason, authority)         oos.defaultWriteObject();          // Write out the size (number of mappings) of the extensions map         oos.writeInt(extensions.size());          // For each extension in the map, the following are emitted (in order):         // the OID String (Object), the criticality flag (boolean), the length         // of the encoded extension value byte array (int), and the encoded         // extension value byte array. The extensions themselves are emitted         // in no particular order.         for (Map.Entry<String, Extension> entry : extensions.entrySet()) {             Extension ext = entry.getValue();             oos.writeObject(ext.getId());             oos.writeBoolean(ext.isCritical());             byte[] extVal = ext.getValue();             oos.writeInt(extVal.length);             oos.write(extVal);         }     }\n", "docstring": "serialize code certificate revoked exception instance\n", "func_name": "327163", "dfs": "ObjectOutputStream oos"}
{"url": "327164", "code": "@BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concatEager(Publisher<? extends SingleSource<? extends T>> sources) {         return Flowable.fromPublisher(sources).concatMapEager(SingleInternalHelper.<T>toFlowable());     } @BackpressureSupport(BackpressureKind.FULL)     @CheckReturnValue     @SchedulerSupport(SchedulerSupport.NONE)     public static <T> Flowable<T> concatEager(Iterable<? extends SingleSource<? extends T>> sources) {         return Flowable.fromIterable(sources).concatMapEager(SingleInternalHelper.<T>toFlowable());     }\n", "docstring": "concatenates publisher sequence single sources eagerly single stream values img width height https raw hub com wiki reactive java images operators single con cat eager png alt eager concatenation means subscriber subscribes operator subscribes emitted source publishers observed operator buffers values emitted publishers drains order one previous one completes back pressure back pressure honored towards downstream outer publisher expected support back pressure violating assumption operator signal concatenates sequence single sources eagerly single stream values img width height https raw hub com wiki reactive java images operators single con cat eager png alt eager concatenation means subscriber subscribes operator subscribes source single sources operator buffers values emitted single sources drains order one previous one completes back pressure back pressure honored towards downstream scheduler method operate default particular\n", "func_name": "327164", "dfs": "return Flowable.fromPublisher(sources).concatMapEager(SingleInternalHelper.toFlowable()); Publisher<? extends SingleSource<? extends T>> sources return Flowable.fromIterable(sources).concatMapEager(SingleInternalHelper.toFlowable()); Iterable<? extends SingleSource<? extends T>> sources"}
{"url": "327165", "code": "public String newAuthorizationURL(EnumSet<AccessScope> scopes, String state) {         Util.throwIfNull(scopes);         if(state == null){state = \"\";}          // Build a map of parameters for the URL         HashMap<String,Object> params = new HashMap<String, Object>();         params.put(\"response_type\", \"code\");         params.put(\"client_id\", clientId);         params.put(\"redirect_uri\", redirectURL);         params.put(\"state\", state);          StringBuilder scopeBuffer = new StringBuilder();         for(AccessScope scope : scopes) {             scopeBuffer.append(scope.name()+\",\");         }         params.put(\"scope\",scopeBuffer.substring(0,scopeBuffer.length()-1));          // Generate the URL with the parameters         return QueryUtil.generateUrl(authorizationURL, params);     }\n", "docstring": "generate authorization url\n", "func_name": "327165", "dfs": "state == null state = \\\"\\\"; Util.throwIfNull(scopes); String state EnumSet<AccessScope> scopes"}
{"url": "327166", "code": "public final void fromHttpHeaders(HttpHeaders headers) {     try {       ParseHeaderState state = new ParseHeaderState(this, null);       serializeHeaders(           headers, null, null, null, new HeaderParsingFakeLevelHttpRequest(this, state));       state.finish();     } catch (IOException ex) {       // Should never occur as we are dealing with a FakeLowLevelHttpRequest       throw Throwables.propagate(ex);     }   }\n", "docstring": "puts headers link http headers object link http headers object\n", "func_name": "327166", "dfs": "HttpHeaders headers"}
{"url": "327167", "code": "public void setAnd(java.util.Collection<Expression> and) {         if (and == null) {             this.and = null;             return;         }          this.and = new java.util.ArrayList<Expression>(and);     }\n", "docstring": "return results match code dimension code objects\n", "func_name": "327167", "dfs": "this.and = new java.util.ArrayList<Expression>(and); return; this.and = null; and == null java.util.Collection<Expression> and"}
